Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 24 different repair schemas!!!!
Total 66 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xb3db698
StringConstTester pointer: 0xb3db530
CondTester pointer: 0xb3db460
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((l == (l->next)) && !(__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name))) {
    res = 1;
    break;
}


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((l == (l->next)) && !(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((l == (l->next)) || (__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name))) {
    res = 1;
    break;
}


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((l == (l->next)) || (__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name)))
    return 0;
if (l == (l->next)) {
    res = 1;
    break;
}


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name)))
    return 1;
if (l == (l->next)) {
    res = 1;
    break;
}


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name)))
    break;
if (l == (l->next)) {
    res = 1;
    break;
}


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
cnt1 = cnt1 + 1;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = cnt1 + 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
res = (0);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (0);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
l = (l)->next;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (l)->next;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
l = (*list)->header;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (*list)->header;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
res = 1;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 10
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((l == (l->next)) && !(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==1) {
        if ((l == (l->next)) || (__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 0;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 1;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            break;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==5) {
        cnt1 = cnt1 + 1;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==6) {
        res = (0);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==7) {
        l = (l)->next;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==8) {
        l = (*list)->header;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==9) {
        res = 1;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((l == (l->next)) && !(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((l == (l->next)) || (__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = cnt1 + 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (0);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (l)->next;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (*list)->header;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 4
CondTester, Postprocessing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((l == (l->next)) || (__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->prev != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->next != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr res == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr l->prev == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 == 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr cnt1 == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 != 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 != 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if ((l == (l->next)) || ((!((l == (l->next)) )))) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Final attempt 2/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if ((l == (l->next)) || (((l == (l->next)) ))) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Final attempt 3/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if ((l == (l->next)) || ((0))) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Final attempt 4/4 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if ((l == (l->next)) || ((1))) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
CondTester, Postprocessing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if ((__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->prev != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->next != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr res == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr l->prev == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 == 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr cnt1 == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 != 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr cnt1 != 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if (((0)))
            return 1;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if (((1)))
            return 1;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
Counter: 11
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
res = (res);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (res);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
res = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
newNode(&(l));
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
newNode(&(l));
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
res = (1);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
l = l->next;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = l->next;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
cnt1 = (res);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (res);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
cnt1 = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
memset(l, 0, sizeof (*(l)));
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
l = (*(list))->header;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (*(list))->header;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
cnt1 = (0);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (0);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 20
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if (__get_mutant()==0) {
        res = (res);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==1) {
        res = (cnt1);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==2) {
        newNode(&(l));
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==3) {
        res = (1);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==4) {
        l = l->next;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==5) {
        cnt1 = (res);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==6) {
        cnt1 = (cnt1);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==7) {
        memset(l, 0, sizeof (*(l)));
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==8) {
        l = (*(list))->header;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==9) {
        cnt1 = (0);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (res);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
newNode(&(l));
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
res = (1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 4
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = l->next;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (res);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (cnt1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
memset(l, 0, sizeof (*(l)));
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (*(list))->header;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (0);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Counter: 21
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if (res == 1)
    return res;
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if (res == 1)
    return res;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l, l->next, res, list, cnt1, l->prev, l->name)))
    if (l == (l->next)) {
        res = 1;
        break;
    }


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    if (l == (l->next)) {
        res = 1;
        break;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
l = (l);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (l);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:44
--Src File: prog.c
Fragment 0:
cnt1 = (1);
if (l == (l->next)) {
    res = 1;
    break;
}


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 24
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        //prophet generated patch
        if (__get_mutant()==0) {
        if (res == 1)
            return res;
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==1) {
        if (!(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            if (l == (l->next)) {
                res = 1;
                break;
            }
        }
        else if (__get_mutant()==2) {
        l = (l);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        else if (__get_mutant()==3) {
        cnt1 = (1);
        if (l == (l->next)) {
            res = 1;
            break;
        }
        }
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if (res == 1)
    return res;
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
if (!(__is_neg(7, &(l), sizeof (l), &(l->next), sizeof (l->next), &(res), sizeof (res), &(list), sizeof (list), &(cnt1), sizeof (cnt1), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    if (l == (l->next)) {
        res = 1;
        break;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
l = (l);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {

        //int cond1 = ((l->next != NULL)&& (l!=l->next->prev));
        //BUG comment it out for correct version
        //cond1 = (l==l->next);
        
//Patch 0:
cnt1 = (1);
if (l == (l->next)) {
    res = 1;
    break;
}

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1+1;
    }
    if (res==1)
        return res;

    l = (*list)->header;
    int sz=0;
    while (l!=NULL) {
        sz = sz+1;
        l = l->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Repair process ends without working fix!!
Total 24 different repair schemas!!!!
Total 66 different repair candidate templates for scoring!!!
Total number of compiles: 31
Total number of test eval: 109
