Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 48 different repair schemas!!!!
Total 103 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xabbd188
StringConstTester pointer: 0xabbcfc0
CondTester pointer: 0xabbcef0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if ((__abst_hole(p, ch, e, p->parent, p->left, value, cnt, root, p->right, p->value, p->color)))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if ((__abst_hole(p, ch, e, p->parent, p->left, value, cnt, root, p->right, p->value, p->color)))
    break;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    break;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if ((__abst_hole(p, ch, e, p->parent, p->left, value, cnt, root, p->right, p->value, p->color)))
    return 1;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 1;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 10000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if ((__abst_hole(p, ch, e, p->parent, p->left, value, cnt, root, p->right, p->value, p->color)))
    return 10;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 10;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
ch = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
newEntry(&(ch));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(ch));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((e)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((e)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (p)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (p)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (e)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (e)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
val_i = 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 10
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
                return 0;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
                break;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
                return 1;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
                return 10;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==4) {
            ch = p;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==5) {
            newEntry(&(ch));
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==6) {
            printTree((e)->right);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==7) {
            p = (p)->parent;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==8) {
            p = (e)->parent;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==9) {
            val_i = 0;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 5 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 9 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 12 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    break;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 1;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 10;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(ch));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((e)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (p)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (e)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Postprocessing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 6
Not passed!
Trying a synthesis expr p != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 10
Not passed!
Trying a synthesis expr p->parent == 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr p->left == 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr p->parent != 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr p->left != 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr p->color == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 6
Not passed!
Trying a synthesis expr cnt == 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr cnt != 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr cnt == 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr cnt != 2
Verifing Negative cases!
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (((0)))
                return 0;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (((1)))
                return 0;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
Counter: 11
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
val_i = (cnt);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (cnt);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
val_i = (10);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (10);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
val_i = (1);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (1);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
val_i = (0);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (0);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printf("%s ", (root)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (root)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printf("%s ", (p)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (p)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printf("%s ", (e)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (e)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printf("%s ", (ch)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (ch)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((root)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((root)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((root)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((root)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 20
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (__get_mutant()==0) {
            val_i = (cnt);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==1) {
            val_i = (10);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==2) {
            val_i = (1);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==3) {
            val_i = (0);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==4) {
            printf("%s ", (root)->value);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==5) {
            printf("%s ", (p)->value);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==6) {
            printf("%s ", (e)->value);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==7) {
            printf("%s ", (ch)->value);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==8) {
            printTree((root)->right);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==9) {
            printTree((root)->left);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (cnt);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (10);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (1);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
val_i = (0);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (root)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (p)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (e)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printf("%s ", (ch)->value);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((root)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((root)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Counter: 21
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((p)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((p)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((e)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((e)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((p)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((p)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((ch)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((ch)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
printTree((ch)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((ch)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = p->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = p->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (root)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (root)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
e = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
ch = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 30
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (__get_mutant()==0) {
            printTree((p)->right);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==1) {
            printTree((e)->left);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==2) {
            printTree((p)->left);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==3) {
            printTree((ch)->right);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==4) {
            printTree((ch)->left);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==5) {
            p = p->parent;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==6) {
            p = (root)->parent;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==7) {
            p = (root);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==8) {
            e = (root);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==9) {
            ch = (p);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((p)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((e)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((p)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((ch)->right);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
printTree((ch)->left);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = p->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (root)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Counter: 31
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
e = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (ch)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (ch)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
newEntry(&(root));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(root));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
newEntry(&(p));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(p));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:6
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if ((value == ((void *)0) && e->value == ((void *)0)) || (strcmp(value, e->value) == 0))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((value == ((void *)0) && e->value == ((void *)0)) || (strcmp(value, e->value) == 0))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
newEntry(&(e));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(e));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:8
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
e = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:9
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
ch = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 40
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (__get_mutant()==0) {
            e = (p);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==1) {
            p = (e);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==2) {
            p = (ch)->parent;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==3) {
            p = (ch);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==4) {
            newEntry(&(root));
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==5) {
            newEntry(&(p));
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==6) {
            if ((value == ((void *)0) && e->value == ((void *)0)) || (strcmp(value, e->value) == 0))
                return 0;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==7) {
            newEntry(&(e));
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==8) {
            e = p;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==9) {
            ch = (root);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (ch)->parent;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(root));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(p));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if ((value == ((void *)0) && e->value == ((void *)0)) || (strcmp(value, e->value) == 0))
    return 0;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
newEntry(&(e));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = p;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (root);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Counter: 41
Batcher Size:0
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
p = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:1
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
e = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:2
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
e = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:3
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
ch = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:4
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
cnt++;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
cnt++;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:5
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
memset(p, 0, sizeof (*(p)));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
memset(p, 0, sizeof (*(p)));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(p, ch, e, p->parent, p->left, value, cnt, root, p->right, p->value, p->color)))
    while (p != ((void *)0))
        {
            ch = p;
            p = p->parent;
        }


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if (!(__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    while (p != ((void *)0))
        {
            ch = p;
            p = p->parent;
        }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:7
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:98
--Src File: prog.c
Fragment 0:
ch = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }


BasicTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Spawn 1 instances, now Total 48
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            //prophet generated patch
            if (__get_mutant()==0) {
            p = (p);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==1) {
            e = (e);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==2) {
            e = (ch);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==3) {
            ch = (ch);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==4) {
            cnt++;
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==5) {
            memset(p, 0, sizeof (*(p)));
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            else if (__get_mutant()==6) {
            if (!(__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
                while (p != ((void *)0))
                    {
                        ch = p;
                        p = p->parent;
                    }
            }
            else if (__get_mutant()==7) {
            ch = (e);
            while (p != ((void *)0))
                {
                    ch = p;
                    p = p->parent;
                }
            }
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
p = (p);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
e = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (ch);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
cnt++;
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
memset(p, 0, sizeof (*(p)));
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
if (!(__is_neg(11, &(p), sizeof (p), &(ch), sizeof (ch), &(e), sizeof (e), &(p->parent), sizeof (p->parent), &(p->left), sizeof (p->left), &(value), sizeof (value), &(cnt), sizeof (cnt), &(root), sizeof (root), &(p->right), sizeof (p->right), &(p->value), sizeof (p->value), &(p->color), sizeof (p->color))))
    while (p != ((void *)0))
        {
            ch = p;
            p = p->parent;
        }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
BasicTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Entry {
    struct Entry* parent;
    struct Entry* left;
    struct Entry* right;
    char* value;
    int color;
};

struct TreeMap {
    struct Entry* root;
    int size;
};

void newEntry(struct Entry** n);
void newTreeMap(struct TreeMap** t);
void getFirstEntry(struct TreeMap** tree, struct Entry** p);
void successor(struct Entry** t, struct Entry** p);
int containsValue(struct Entry* root, char* value);
void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res);
void buildTree(int size, char** value, struct Entry** root) ;
int val_i;

void newEntry(struct Entry** n) {
     *n = malloc (sizeof (struct Entry));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->color = 1;
    (*n)->value = NULL;
}

void newTreeMap(struct TreeMap** t) {
    *t = malloc(sizeof (struct TreeMap));
    (*t)->root = NULL;
    (*t)->size = 0;
}

void getFirstEntry(struct TreeMap** tree, struct Entry** p) {
    *p = (*tree)->root;
    if ((*p)!=NULL) {
        while ((*p)->left != NULL)
            *p = (*p)->left;
    }
    return ;
}

void successor(struct Entry** t, struct Entry** p) {
    if ((*t)==NULL) {
        (*p)=NULL;
        return;
    }else if ((*t)->left !=NULL) {
        *p = (*t)->right;
        while ((*p)->left != NULL)
            *p = (*p)->left;
        return;
    } else {
        *p = (*t)->parent;
        struct Entry* ch = *t;
        while (((*p) != NULL) && (ch ==(*p)->right)) {
            ch = *p;
            *p = (*p)->parent;
        }
        return;
    }
}

int containsValue(struct Entry* root, char* value) {
    struct Entry* e = root;
//    printf("contains value %s root %s, %d",value, e->value,strcmp(value, e->value));
    if (e !=NULL) {
        while (e->left != NULL)
            e = e->left;
    }

    int cnt = 0;
    while ((e!= NULL)&& (cnt<10)) {
        cnt++;
        if ((value ==NULL && e->value == NULL) || (strcmp(value, e->value)==0))
            return 0;

        if ((e->right) != NULL) {
            struct Entry* p = e->right;
            while ((p->left != NULL))
                p = p->left;
            e = p;
        }

        else {
            struct Entry* ch = e;

            struct Entry* p = e->parent;
            // BUG RBTERR2
            
//Patch 0:
ch = (e);
while (p != ((void *)0))
    {
        ch = p;
        p = p->parent;
    }

//CodeSeg 1:
            e=p;
        }
    }
   // if (cnt==10)
     //   return 1;
    return 1;
}

void buildFromSorted (int level, int lo, int hi, int redLevel, char** value, struct Entry** res) {
    if (hi < lo) {
        *res = NULL;
        return;
    }
    int mid = (lo+hi)/2;
    struct Entry* left = NULL;
    if (lo < mid)
         buildFromSorted(level+1, lo, mid-1,redLevel, value, &left);

    struct Entry* middle;
    newEntry(&middle);
//     printf("build sort middle value %s, %s,",value[0],value[val_i]);
    middle->value = value[val_i++];


    if (level==redLevel)
        middle->color = 0;
    if (left != NULL) {
        middle->left = left;
        left->parent = middle;
    }

    if (mid < hi) {
        struct Entry* right;
        buildFromSorted(level+1,mid+1,hi, redLevel, value, &right);
        middle->right = right;
        right->parent = middle;
    }
    *res = middle;
}

void buildTree(int size, char** value, struct Entry** root) {
    int level = 0;
    for (int m=size-1;m>=0;m=m/2-1)
        level++;

    buildFromSorted(0,0,size-1,level,value,root);
}

void printTree(struct Entry* root) {
    if (root==NULL) return;
    printf("%s ",root->value);
    printTree(root->left);
     printTree(root->right);
}
int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct TreeMap* t;
    newTreeMap(&t);

    char x[20];
     char* input[20];
    int i=0;
    char find[10];
    fscanf(f,"%s",find);
    fscanf(f,"%s",find);
    while (fscanf(f,"%s",x)==1) {
        if (x[0]!= '"') {
            int len = strlen(x)+1;
            input[i] = (char*) malloc(len * sizeof (char));// (char*) malloc (sizeof (char*len))
           strcpy(input[i],x);
            i = i+1;
        }
    }
    fclose(f);
//    printf("size %d,",i);
    val_i = 0;
//    for (int j=0;j<i;j++)
//        printf("%s ",input[j]);

    struct Entry* root = t->root;
    buildTree(i,input,&root);
//    printf("%s ","after build tree root ");
//    printTree(root);
    int res = containsValue(root, find);
    printf("%d",res);

    return 0;
}

Testing negative cases!
Repair process ends without working fix!!
Total 48 different repair schemas!!!!
Total 103 different repair candidate templates for scoring!!!
Total number of compiles: 18
Total number of test eval: 99
