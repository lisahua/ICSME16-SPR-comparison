Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 2602 different repair schemas!!!!
Total 5858 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xb1c9f00
StringConstTester pointer: 0xb265ac0
CondTester pointer: 0xb216f68
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((x->key == k) && !(__abst_hole(k, x, x->key, y, t, x->left, x->right, x->parent))) {
    return 1;
}


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        
//Patch 0:
if ((x->key == k) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
    return 1;
}

//CodeSeg 1:

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((x->key == k) || (__abst_hole(k, x, x->key, y, t, x->left, x->right, x->parent))) {
    return 1;
}


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        
//Patch 0:
if ((x->key == k) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
    return 1;
}

//CodeSeg 1:

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:138
--Src File: prog.c
Fragment 0:
{
    if ((x[i] == 'L') && !(__abst_hole(i, node, node->left, node->right, len, n, t, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
        node = node->left;
}


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else 
//Patch 0:
{
    if ((x[i] == 'L') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:138
--Src File: prog.c
Fragment 0:
{
    if ((x[i] == 'L') || (__abst_hole(i, node, node->left, node->right, len, n, t, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
        node = node->left;
}


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else 
//Patch 0:
{
    if ((x[i] == 'L') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((x[i] == 'R') && !(__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((x[i] == 'R') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((x[i] == 'R') || (__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((x[i] == 'R') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:88
--Src File: prog.c
Fragment 0:
{
    if ((tmp->key < key) && !(__abst_hole(key, tmp, tmp->key, i, x, tmp->right, t, tmp->left, tmp->parent))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else 
//Patch 0:
{
    if ((tmp->key < key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:88
--Src File: prog.c
Fragment 0:
{
    if ((tmp->key < key) || (__abst_hole(key, tmp, tmp->key, i, x, tmp->right, t, tmp->left, tmp->parent))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else 
//Patch 0:
{
    if ((tmp->key < key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:105
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:105
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:85
--Src File: prog.c
Fragment 0:
if ((tmp->key == key) && !(__abst_hole(key, tmp, tmp->key, i, x, t, tmp->right, tmp->left, tmp->parent))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((tmp->key == key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:85
--Src File: prog.c
Fragment 0:
if ((tmp->key == key) || (__abst_hole(key, tmp, tmp->key, i, x, t, tmp->right, tmp->left, tmp->parent))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((tmp->key == key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if (((x != ((void *)0) && k > x->key)) && !(__abst_hole(k, x, x->key, x->left, x->right, y, t, x->parent)))
    x = x->right;


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         
//Patch 0:
if (((x != ((void *)0) && k > x->key)) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
    x = x->right;

//CodeSeg 1:
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:83
--Src File: prog.c
Fragment 0:
if ((tmp->key == key) && !(__abst_hole(key, tmp, tmp->key, t, t->root, i, x, tmp->right, tmp->left, t->size, tmp->parent)))
    return "RO";


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((tmp->key == key) && !(__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:83
--Src File: prog.c
Fragment 0:
if ((tmp->key == key) || (__abst_hole(key, tmp, tmp->key, t, t->root, i, x, tmp->right, tmp->left, t->size, tmp->parent)))
    return "RO";


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((tmp->key == key) || (__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:50
--Src File: prog.c
Fragment 0:
if (((x != ((void *)0) && k > x->key)) || (__abst_hole(k, x, x->key, x->left, x->right, y, t, x->parent)))
    x = x->right;


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         
//Patch 0:
if (((x != ((void *)0) && k > x->key)) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
    x = x->right;

//CodeSeg 1:
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    continue;


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    continue;


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((x[i] == 'L') && !(__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key))) {
    node->left = n;
}


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((x[i] == 'L') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((x[i] == 'L') || (__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key))) {
    node->left = n;
}


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((x[i] == 'L') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:129
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "RO") == 0) && !(__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        
//Patch 0:
if ((strcmp(x, "RO") == 0) && !(__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}

//CodeSeg 1:
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:129
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "RO") == 0) || (__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        
//Patch 0:
if ((strcmp(x, "RO") == 0) || (__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}

//CodeSeg 1:
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((k < y->key) && !(__abst_hole(k, y, y->key, x, y->left, t, y->right, x->parent, x->key, x->right, x->left, y->parent)))
    y->left = x;
else
    y->right = x;


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((k < y->key) && !(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((x[i] == 'R') && !(__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key))) {
    node->right = n;
}


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((x[i] == 'R') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((x[i] == 'R') || (__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key))) {
    node->right = n;
}


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((x[i] == 'R') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((k < y->key) || (__abst_hole(k, y, y->key, x, y->left, t, y->right, x->parent, x->key, x->right, x->left, y->parent)))
    y->left = x;
else
    y->right = x;


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((k < y->key) || (__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((y == ((void *)0)) && !(__abst_hole(y, t, x, (*t)->root, k, x->key, y->key, y->left, x->right, y->right, x->left, x->parent, (*t)->size, y->parent)))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    
//Patch 0:
if ((y == ((void *)0)) && !(__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}

//CodeSeg 1:
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((y == ((void *)0)) || (__abst_hole(y, t, x, (*t)->root, k, x->key, y->key, y->left, x->right, y->right, x->left, x->parent, (*t)->size, y->parent)))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    
//Patch 0:
if ((y == ((void *)0)) || (__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}

//CodeSeg 1:
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 12464
At location prog.c:83
--Src File: prog.c
Fragment 0:
if ((__abst_hole(key, tmp, tmp->key, t, t->root, i, x, tmp->right, tmp->left, t->size, tmp->parent)))
    return 0;
if (tmp->key == key)
    return "RO";


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 12454
At location prog.c:24
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, (*n)->parent, (*n)->left, (*n)->right, (*n)->key)))
    return;
*n = malloc(sizeof(struct Node));


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
if ((__is_neg(5, &(n), sizeof (n), &((*n)->parent), sizeof ((*n)->parent), &((*n)->left), sizeof ((*n)->left), &((*n)->right), sizeof ((*n)->right), &((*n)->key), sizeof ((*n)->key))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:41
--Src File: prog.c
Fragment 0:
if ((__abst_hole(x, y, t, x->key, k, x->left, x->right, y->key, y->left, y->right, x->parent, y->parent)))
    return 0;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(x->key), sizeof (x->key), &(k), sizeof (k), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 0;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 12453
At location prog.c:41
--Src File: prog.c
Fragment 0:
if ((__abst_hole(x, y, t, k, x->key, x->left, x->right, y->key, y->left, y->right, x->parent, y->parent)))
    return 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(k), sizeof (k), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 12435
At location prog.c:32
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, (*t)->root, (*t)->size)))
    return;
*t = malloc(sizeof(struct Tree));


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->root), sizeof ((*t)->root), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 12430
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 12430
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 12430
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 12430
At location prog.c:103
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 9997
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, tmp, key, t)))
    return 0;
x[i] = 'L';


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    return 0;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 9997
At location prog.c:93
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, tmp, key, t)))
    break;
x[i] = 'L';


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    break;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(k, y, y->key, x, y->left, t, y->right, x->parent, x->key, x->right, x->left, y->parent)))
    return 0;
if (k < y->key)
    y->left = x;
else
    y->right = x;


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    return 0;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 9996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((__abst_hole(k, y, y->key, x, y->left, t, y->right, x->parent, x->key, x->right, x->left, y->parent)))
    return 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    return 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, len, node, t, n, f, ins_loc, res, ins, argv, argc)))
    return 0;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, len, node, t, n, f, ins_loc, res, ins, argv, argc)))
    return 1;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, len, node, t, n, f, ins_loc, res, ins, argv, argc)))
    return 2;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, len, node, t, n, f, ins_loc, res, ins, argv, argc)))
    return 20;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 9993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, len, node, t, n, f, ins_loc, res, ins, argv, argc)))
    break;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 9990
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->left, i, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 0;
node->left = n;


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 9990
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->left, i, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 1;
node->left = n;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 9990
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->left, i, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 2;
node->left = n;


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 9990
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->left, i, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 20;
node->left = n;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 9990
At location prog.c:146
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->left, i, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    break;
node->left = n;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 9988
At location prog.c:86
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, key, tmp, tmp->key, t, tmp->right, tmp->left, tmp->parent)))
    return 0;
x[i] = '\x00';


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
x[i] = '\x00';

//CodeSeg 1:
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 9988
At location prog.c:86
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, key, tmp, tmp->key, t, tmp->right, tmp->left, tmp->parent)))
    break;
x[i] = '\x00';


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    break;
x[i] = '\x00';

//CodeSeg 1:
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 9987
At location prog.c:85
--Src File: prog.c
Fragment 0:
if ((__abst_hole(key, tmp, tmp->key, i, x, t, tmp->right, tmp->left, tmp->parent)))
    return 0;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 9987
At location prog.c:85
--Src File: prog.c
Fragment 0:
if ((__abst_hole(key, tmp, tmp->key, i, x, t, tmp->right, tmp->left, tmp->parent)))
    break;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    break;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 9975
At location prog.c:42
--Src File: prog.c
Fragment 0:
if ((__abst_hole(y, x, k, x->key, t, x->left, x->right, y->key, y->left, y->right, x->parent, y->parent)))
    break;
y = x;


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    break;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 9975
At location prog.c:42
--Src File: prog.c
Fragment 0:
if ((__abst_hole(y, x, k, x->key, t, x->left, x->right, y->key, y->left, y->right, x->parent, y->parent)))
    return 1;
y = x;


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 1;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 9975
At location prog.c:42
--Src File: prog.c
Fragment 0:
if ((__abst_hole(y, x, k, x->key, t, x->left, x->right, y->key, y->left, y->right, x->parent, y->parent)))
    return 0;
y = x;


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 0;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 9968
At location prog.c:130
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size)))
    return 0;
t->root = n;


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 0;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 9968
At location prog.c:130
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size)))
    break;
t->root = n;


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    break;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 9968
At location prog.c:130
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size)))
    return 1;
t->root = n;


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 1;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 9968
At location prog.c:130
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size)))
    return 2;
t->root = n;


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 2;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with CondTester:
Priority 9968
At location prog.c:130
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, n, t->root, f, n->key, node, ins_loc, res, ins, argv, argc, n->parent, n->left, n->right, t->size)))
    return 20;
t->root = n;


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 20;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with CondTester:
Priority 9948
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, ins_loc, t, argv, argc, res, ins)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with CondTester:
Priority 9929
At location prog.c:143
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->right, i, node->left, t, res, ins, len, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 0;
node->right = n;


CondTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with CondTester:
Priority 9929
At location prog.c:143
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->right, i, node->left, t, res, ins, len, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 1;
node->right = n;


CondTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with CondTester:
Priority 9929
At location prog.c:143
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->right, i, node->left, t, res, ins, len, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 2;
node->right = n;


CondTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with CondTester:
Priority 9929
At location prog.c:143
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->right, i, node->left, t, res, ins, len, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 20;
node->right = n;


CondTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:74
Preprocess the following candidate with CondTester:
Priority 9929
At location prog.c:143
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, node, node->right, i, node->left, t, res, ins, len, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    break;
node->right = n;


CondTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:75
Preprocess the following candidate with CondTester:
Priority 9925
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    return 0;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:76
Preprocess the following candidate with CondTester:
Priority 9925
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    return 1;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:77
Preprocess the following candidate with CondTester:
Priority 9925
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    return 2;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:78
Preprocess the following candidate with CondTester:
Priority 9925
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    return 20;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:79
Preprocess the following candidate with CondTester:
Priority 9925
At location prog.c:136
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, node, len, node->right, node->left, t, n, f, res, ins, ins_loc, argv, argc, node->parent, node->key)))
    break;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;


CondTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:80
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*n)->key = (0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->key = (0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:81
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->root = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:32
--Src File: prog.c
Fragment 0:
(*t)->root = ((void *)0);
*t = malloc(sizeof(struct Tree));


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->root = ((void *)0);
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:83
Preprocess the following candidate with StringConstTester:
Priority 7472
At location prog.c:127
--Src File: prog.c
Fragment 0:
fscanf(f, (__abst_hole()), x);


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:84
Preprocess the following candidate with StringConstTester:
Priority 7466
At location prog.c:156
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), res);


StringConstTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    
//Patch 0:
printf(("%##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
i++;
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
i++;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
if (tmp->key == key)
    return "RO";
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if (tmp->key == key)
    return "RO";
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
tmp = tmp->right;
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = tmp->right;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
x[i] = (0);
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = (0);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
x[i] = (10);
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = (10);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
x[i] = 'L';
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = 'L';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 92
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((tmp->key == key) && !(__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
        return "RO";
    }
    else if (__get_mutant()==1) {
    if ((tmp->key == key) || (__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
        return "RO";
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
        return 0;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==3) {
    i++;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==4) {
    if (tmp->key < key) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==5) {
    if (tmp->key == key)
        return "RO";
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==6) {
    tmp = tmp->right;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==7) {
    x[i] = (0);
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==8) {
    x[i] = (10);
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==9) {
    x[i] = 'L';
    if (tmp->key == key)
        return "RO";
    }
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((tmp->key == key) && !(__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((tmp->key == key) || (__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if ((__is_neg(11, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(t->root), sizeof (t->root), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(t->size), sizeof (t->size), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
i++;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
if (tmp->key == key)
    return "RO";
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = tmp->right;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = (0);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = (10);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = 'L';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 93
Batcher Size:82
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
x[i] = 'R';
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = 'R';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:83
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
x[i] = '\x00';
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = '\x00';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:84
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
newNode(&(tmp));
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
newNode(&(tmp));
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
tmp = (tmp);
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
tmp = (tmp)->right;
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp)->right;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
tmp = tmp->left;
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = tmp->left;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
tmp = (tmp)->left;
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp)->left;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7464
At location prog.c:83
--Src File: prog.c
Fragment 0:
newTree(&(t));
if (tmp->key == key)
    return "RO";


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
newTree(&(t));
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*n)->right = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->right = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*n)->parent = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->parent = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*n)->left = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->left = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
printf("%d ", (*(n))->key);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printf("%d ", (*(n))->key);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
printTree(&((*(n))->right));
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printTree(&((*(n))->right));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
printTree(&((*(n))->left));
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printTree(&((*(n))->left));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:24
--Src File: prog.c
Fragment 0:
(*n)->key = 0;
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->key = 0;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 108
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(5, &(n), sizeof (n), &((*n)->parent), sizeof ((*n)->parent), &((*n)->left), sizeof ((*n)->left), &((*n)->right), sizeof ((*n)->right), &((*n)->key), sizeof ((*n)->key))))
        return;
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==1) {
    (*n)->key = (0);
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==2) {
    (*n)->right = ((void *)0);
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==3) {
    (*n)->parent = ((void *)0);
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==4) {
    (*n)->left = ((void *)0);
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==5) {
    printf("%d ", (*(n))->key);
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==6) {
    printTree(&((*(n))->right));
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==7) {
    printTree(&((*(n))->left));
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==8) {
    *n = malloc(sizeof(struct Node));
    *n = malloc(sizeof(struct Node));
    }
    else if (__get_mutant()==9) {
    (*n)->key = 0;
    *n = malloc(sizeof(struct Node));
    }
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
if ((__is_neg(5, &(n), sizeof (n), &((*n)->parent), sizeof ((*n)->parent), &((*n)->left), sizeof ((*n)->left), &((*n)->right), sizeof ((*n)->right), &((*n)->key), sizeof ((*n)->key))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->key = (0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->right = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->parent = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->left = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printf("%d ", (*(n))->key);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printTree(&((*(n))->right));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
printTree(&((*(n))->left));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    
//Patch 0:
(*n)->key = 0;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 109
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x = (y)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (y)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x = (x)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (x)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
newNode(&x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
newNode(&(x));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&(x));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 115
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(x->key), sizeof (x->key), &(k), sizeof (k), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
        return 0;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(k), sizeof (k), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
        return 1;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==2) {
    (*t)->root = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==3) {
    x = x->right;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==4) {
    x = (y)->right;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==5) {
    x = (x)->right;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==6) {
    x = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==7) {
    newNode(&x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==8) {
    x = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==9) {
    newNode(&(x));
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(x->key), sizeof (x->key), &(k), sizeof (k), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 0;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((__is_neg(12, &(x), sizeof (x), &(y), sizeof (y), &(t), sizeof (t), &(k), sizeof (k), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (y)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (x)->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&(x));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 116
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
newNode(&(y));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&(y));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
if (x->key == k) {
    return 1;
}
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if (x->key == k) {
    return 1;
}
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->size = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->size = (*t)->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (*t)->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->size = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->size = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->size = (*(t))->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (*(t))->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->root = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 125
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&(y));
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==1) {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==2) {
    if (x->key == k) {
        return 1;
    }
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==3) {
    (*t)->size = (k);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==4) {
    if ((x != ((void *)0) && k > x->key))
        x = x->right;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==5) {
    (*t)->size = (*t)->size + 1;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==6) {
    (*t)->size = (0);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==7) {
    (*t)->size = (1);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==8) {
    (*t)->size = (*(t))->size + 1;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==9) {
    (*t)->root = x;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
newNode(&(y));
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if (x->key == k) {
    return 1;
}
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (*t)->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->size = (*(t))->size + 1;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 126
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
(*t)->root = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->left = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->right = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->right = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->left = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y->left = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 133
Counter: 134
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->parent = y;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = y;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 135
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    //prophet generated patch
    if (__get_mutant()==0) {
    (*t)->root = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==1) {
    y->left = x;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==2) {
    y->right = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==3) {
    y->right = x;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==4) {
    y->right = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==5) {
    y->left = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==6) {
    y = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==7) {
    y->left = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==8) {
    y = x;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==9) {
    x->parent = y;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
(*t)->root = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->right = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y->left = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = x;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = y;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 136
Batcher Size:85
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
y = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->parent = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:87
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->parent = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->key = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->key = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->key = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 7453
At location prog.c:41
--Src File: prog.c
Fragment 0:
x->key = k;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }


BasicTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = k;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 142
Counter: 143
Batcher Size:92
Preprocess the following candidate with StringConstTester:
Priority 7444
At location prog.c:117
--Src File: prog.c
Fragment 0:
fscanf(f, (__abst_hole()), x);


StringConstTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 143
Counter: 144
Batcher Size:93
Preprocess the following candidate with StringConstTester:
Priority 7441
At location prog.c:114
--Src File: prog.c
Fragment 0:
fscanf(f, (__abst_hole()), x);


StringConstTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 144
Counter: 145
Batcher Size:94
Preprocess the following candidate with StringConstTester:
Priority 7440
At location prog.c:113
--Src File: prog.c
Fragment 0:
fscanf(f, (__abst_hole()), x);


StringConstTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 145
Counter: 146
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 7435
At location prog.c:32
--Src File: prog.c
Fragment 0:
*t = malloc(sizeof(struct Tree));
*t = malloc(sizeof(struct Tree));


BasicTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
*t = malloc(sizeof(struct Tree));
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 146
Counter: 147
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 7435
At location prog.c:32
--Src File: prog.c
Fragment 0:
(*t)->size = 0;
*t = malloc(sizeof(struct Tree));


BasicTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 147
Counter: 148
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 7435
At location prog.c:32
--Src File: prog.c
Fragment 0:
(*t)->size = (0);
*t = malloc(sizeof(struct Tree));


BasicTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 148
Counter: 149
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 7430
At location prog.c:103
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 149
Counter: 150
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:60
--Src File: prog.c
Fragment 0:
{
    memset(x, 0, sizeof (*(x)));
    y->left = x;
}


BasicTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    memset(x, 0, sizeof (*(x)));
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 150
Counter: 151
Batcher Size:100
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:60
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(y, x, y->left, k, y->key, y->right, t, x->parent, x->key, x->right, x->left, y->parent)))
        y->left = x;
}


CondTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if (!(__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 151
Counter: 152
Batcher Size:101
Preprocess the following candidate with BasicTester:
Priority 5000
At location prog.c:60
--Src File: prog.c
Fragment 0:
{
    memset(y, 0, sizeof (*(y)));
    y->left = x;
}


BasicTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    memset(y, 0, sizeof (*(y)));
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 152
Counter: 153
Batcher Size:102
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:60
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(y, x, y->left, k, y->key, y->right, t, x->parent, x->key, x->right, x->left, y->parent)))
        return 1;
    y->left = x;
}


CondTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        return 1;
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 153
Counter: 154
Batcher Size:103
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:60
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(y, x, y->left, k, y->key, y->right, t, x->parent, x->key, x->right, x->left, y->parent)))
        return 0;
    y->left = x;
}


CondTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        return 0;
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 154
Counter: 155
Batcher Size:104
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((__abst_hole(tmp, tmp->left, i, x, tmp->right, key, tmp->key, t, tmp->parent)))
    return 0;
tmp = tmp->left;


CondTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 155
Counter: 156
Batcher Size:105
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:95
--Src File: prog.c
Fragment 0:
if ((__abst_hole(tmp, tmp->left, i, x, tmp->right, key, tmp->key, t, tmp->parent)))
    break;
tmp = tmp->left;


CondTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    break;
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 156
Counter: 157
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:95
--Src File: prog.c
Fragment 0:
memset(tmp, 0, sizeof (*(tmp)));
tmp = tmp->left;


BasicTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
memset(tmp, 0, sizeof (*(tmp)));
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 157
Counter: 158
Batcher Size:107
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:95
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(tmp, tmp->left, i, x, tmp->right, key, tmp->key, t, tmp->parent)))
    tmp = tmp->left;


CondTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if (!(__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 158
Counter: 159
Batcher Size:108
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:94
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, tmp, tmp->left, tmp->right, key, tmp->key, t, tmp->parent)))
    break;
i++;


CondTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    break;
i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 159
Counter: 160
Batcher Size:109
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:94
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, x, tmp, tmp->left, tmp->right, key, tmp->key, t, tmp->parent)))
    return 0;
i++;


CondTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 160
Counter: 161
Batcher Size:110
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:94
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(i, x, tmp, tmp->left, tmp->right, key, tmp->key, t, tmp->parent)))
    i++;


CondTester, a patch instance with id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if (!(__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 161
Counter: 162
Batcher Size:111
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(i, x, tmp, key, t)))
    x[i] = 'L';


CondTester, a patch instance with id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (!(__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 162
Counter: 163
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
x[i] = (10);
x[i] = 'L';


BasicTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = (10);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 163
Counter: 164
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
i++;
x[i] = 'L';


BasicTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
i++;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 164
Counter: 165
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
x[i] = 'L';


BasicTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 165
Counter: 166
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
tmp = (tmp)->left;
x[i] = 'L';


BasicTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp)->left;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 166
Counter: 167
Batcher Size:116
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
x[i] = 'L';
x[i] = 'L';


BasicTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = 'L';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 167
Counter: 168
Batcher Size:117
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
x[i] = '\x00';
x[i] = 'L';


BasicTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = '\x00';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 168
Counter: 169
Batcher Size:118
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
x[i] = (0);
x[i] = 'L';


BasicTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = (0);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 169
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
                return 0;
            x[i] = 'L';
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
                break;
            x[i] = 'L';
            }
            else if (__get_mutant()==2) {
            if (!(__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
                x[i] = 'L';
            }
            else if (__get_mutant()==3) {
            x[i] = (10);
            x[i] = 'L';
            }
            else if (__get_mutant()==4) {
            i++;
            x[i] = 'L';
            }
            else if (__get_mutant()==5) {
            if (tmp->key < key) {
                x[i] = 'R';
                i++;
                tmp = tmp->right;
            } else {
                x[i] = 'L';
                i++;
                tmp = tmp->left;
            }
            x[i] = 'L';
            }
            else if (__get_mutant()==6) {
            tmp = (tmp)->left;
            x[i] = 'L';
            }
            else if (__get_mutant()==7) {
            x[i] = 'L';
            x[i] = 'L';
            }
            else if (__get_mutant()==8) {
            x[i] = '\x00';
            x[i] = 'L';
            }
            else if (__get_mutant()==9) {
            x[i] = (0);
            x[i] = 'L';
            }
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    return 0;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if ((__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    break;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (!(__is_neg(5, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(key), sizeof (key), &(t), sizeof (t))))
    x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = (10);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
i++;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp)->left;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = 'L';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = '\x00';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = (0);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 170
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
x[i] = 'R';
x[i] = 'L';


BasicTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = 'R';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 170
Counter: 171
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
tmp = (tmp)->right;
x[i] = 'L';


BasicTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp)->right;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 171
Counter: 172
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
tmp = tmp->left;
x[i] = 'L';


BasicTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = tmp->left;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 172
Counter: 173
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
tmp = tmp->right;
x[i] = 'L';


BasicTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = tmp->right;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 173
Counter: 174
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
if (tmp->key == key)
    return "RO";
x[i] = 'L';


BasicTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (tmp->key == key)
    return "RO";
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 174
Counter: 175
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
newNode(&(tmp));
x[i] = 'L';


BasicTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
newNode(&(tmp));
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 175
Counter: 176
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
newTree(&(t));
x[i] = 'L';


BasicTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
newTree(&(t));
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 176
Counter: 177
Batcher Size:116
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:93
--Src File: prog.c
Fragment 0:
tmp = (tmp);
x[i] = 'L';


BasicTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 177
Counter: 178
Batcher Size:117
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->right = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 178
Counter: 179
Batcher Size:118
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 179
Counter: 180
Batcher Size:119
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->left = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 180
Counter: 181
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->right = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 181
Counter: 182
Batcher Size:121
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 182
Counter: 183
Batcher Size:122
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->left = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 183
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((k < y->key) && !(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==1) {
        if ((k < y->key) || (__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
            return 0;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
            return 1;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==4) {
        y->right = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==5) {
        y->right = x;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==6) {
        y->left = x;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==7) {
        y->right = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==8) {
        y = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==9) {
        y->left = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((k < y->key) && !(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((k < y->key) || (__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    return 0;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    return 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->right = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 184
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y->left = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 184
Counter: 185
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 185
Counter: 186
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->parent = y;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = y;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 186
Counter: 187
Batcher Size:116
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
y = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 187
Counter: 188
Batcher Size:117
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->parent = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 188
Counter: 189
Batcher Size:118
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->parent = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 189
Counter: 190
Batcher Size:119
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->key = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 190
Counter: 191
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->key = k;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = k;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 191
Counter: 192
Batcher Size:121
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->key = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 192
Counter: 193
Batcher Size:122
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x->key = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 193
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        //prophet generated patch
        if (__get_mutant()==0) {
        y->left = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==1) {
        y = x;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==2) {
        x->parent = y;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==3) {
        y = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==4) {
        x->parent = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==5) {
        x->parent = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==6) {
        x->key = (k);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==7) {
        x->key = k;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==8) {
        x->key = (0);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==9) {
        x->key = (1);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y->left = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 89:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = y;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
y = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->parent = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = k;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x->key = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 194
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 194
Counter: 195
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x = (y)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (y)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 195
Counter: 196
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x = (x)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (x)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 196
Counter: 197
Batcher Size:116
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 197
Counter: 198
Batcher Size:117
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
newNode(&x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 198
Counter: 199
Batcher Size:118
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
x = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 199
Counter: 200
Batcher Size:119
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
newNode(&(x));
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&(x));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 200
Counter: 201
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
newNode(&(y));
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&(y));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 201
Counter: 202
Batcher Size:121
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 202
Counter: 203
Batcher Size:122
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (x->key == k) {
    return 1;
}
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (x->key == k) {
    return 1;
}
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 203
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        //prophet generated patch
        if (__get_mutant()==0) {
        x = x->right;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==1) {
        x = (y)->right;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==2) {
        x = (x)->right;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==3) {
        x = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==4) {
        newNode(&x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==5) {
        x = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==6) {
        newNode(&(x));
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==7) {
        newNode(&(y));
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==8) {
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==9) {
        if (x->key == k) {
            return 1;
        }
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (y)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (x)->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 103:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
x = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 104:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&(x));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 105:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
newNode(&(y));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 106:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (k < y->key)
    y->left = x;
else
    y->right = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 107:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (x->key == k) {
    return 1;
}
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 204
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->size = (*(t))->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (*(t))->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 204
Counter: 205
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->size = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 205
Counter: 206
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 206
Counter: 207
Batcher Size:116
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->size = (*t)->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (*t)->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 207
Counter: 208
Batcher Size:117
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->size = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 208
Counter: 209
Batcher Size:118
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->size = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 209
Counter: 210
Batcher Size:119
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
memset(x, 0, sizeof (*(x)));
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
memset(x, 0, sizeof (*(x)));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 210
Counter: 211
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->root = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 211
Counter: 212
Batcher Size:121
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->root = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 212
Counter: 213
Batcher Size:122
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
(*t)->root = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 213
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        //prophet generated patch
        if (__get_mutant()==0) {
        (*t)->size = (*(t))->size + 1;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==1) {
        (*t)->size = (k);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==2) {
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==3) {
        (*t)->size = (*t)->size + 1;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==4) {
        (*t)->size = (0);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==5) {
        (*t)->size = (1);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==6) {
        memset(x, 0, sizeof (*(x)));
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==7) {
        (*t)->root = (y);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==8) {
        (*t)->root = x;
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
        else if (__get_mutant()==9) {
        (*t)->root = (x);
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 108:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (*(t))->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 109:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (k);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 110:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if ((x != ((void *)0) && k > x->key))
    x = x->right;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 111:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (*t)->size + 1;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 112:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (0);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 113:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->size = (1);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 114:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
memset(x, 0, sizeof (*(x)));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 115:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = (y);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 116:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = x;
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 117:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
(*t)->root = (x);
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 214
Batcher Size:113
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(k, y, y->key, x, y->left, t, y->right, x->parent, x->key, x->right, x->left, y->parent)))
    if (k < y->key)
        y->left = x;
    else
        y->right = x;


CondTester, a patch instance with id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (!(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    if (k < y->key)
        y->left = x;
    else
        y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 214
Counter: 215
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:59
--Src File: prog.c
Fragment 0:
memset(y, 0, sizeof (*(y)));
if (k < y->key)
    y->left = x;
else
    y->right = x;


BasicTester, a patch instance with id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
memset(y, 0, sizeof (*(y)));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 215
Counter: 216
Batcher Size:115
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 0;
if (x[i] == 'L') {
    node->left = n;
}


CondTester, a patch instance with id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 216
Counter: 217
Batcher Size:116
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 1;
if (x[i] == 'L') {
    node->left = n;
}


CondTester, a patch instance with id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 217
Counter: 218
Batcher Size:117
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    break;
if (x[i] == 'L') {
    node->left = n;
}


CondTester, a patch instance with id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 218
Counter: 219
Batcher Size:118
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 2;
if (x[i] == 'L') {
    node->left = n;
}


CondTester, a patch instance with id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 219
Counter: 220
Batcher Size:119
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 20;
if (x[i] == 'L') {
    node->left = n;
}


CondTester, a patch instance with id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 220
Counter: 221
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'L') {
    node->left = n;
}


BasicTester, a patch instance with id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 221
Counter: 222
Batcher Size:121
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'L') {
    node->left = n;
}


BasicTester, a patch instance with id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 222
Counter: 223
Batcher Size:122
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:145
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(i, n, node, node->left, node->right, t, res, ins, f, ins_loc, len, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    if (x[i] == 'L') {
        node->left = n;
    }


CondTester, a patch instance with id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    if (x[i] == 'L') {
        node->left = n;
    }

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 223
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((x[i] == 'L') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
                node->left = n;
            }
            }
            else if (__get_mutant()==1) {
            if ((x[i] == 'L') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
                node->left = n;
            }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 0;
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 1;
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                break;
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==5) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 2;
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==6) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 20;
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==7) {
            memset(n, 0, sizeof (*(n)));
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==8) {
            memset(node, 0, sizeof (*(node)));
            if (x[i] == 'L') {
                node->left = n;
            }
            }
            else if (__get_mutant()==9) {
            if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                if (x[i] == 'L') {
                    node->left = n;
                }
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((x[i] == 'L') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((x[i] == 'L') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 91:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 92:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 93:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 94:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 95:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
BasicTester, Testing instance id 119:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 120:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'L') {
    node->left = n;
}

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 96:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            
//Patch 0:
if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    if (x[i] == 'L') {
        node->left = n;
    }

//CodeSeg 1:

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Counter: 224
Batcher Size:113
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 2;
if (x[i] == 'R') {
    node->right = n;
}


CondTester, a patch instance with id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 224
Counter: 225
Batcher Size:114
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 20;
if (x[i] == 'R') {
    node->right = n;
}


CondTester, a patch instance with id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 225
Counter: 226
Batcher Size:115
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    break;
if (x[i] == 'R') {
    node->right = n;
}


CondTester, a patch instance with id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 226
Counter: 227
Batcher Size:116
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 0;
if (x[i] == 'R') {
    node->right = n;
}


CondTester, a patch instance with id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 227
Counter: 228
Batcher Size:117
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if ((__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    return 1;
if (x[i] == 'R') {
    node->right = n;
}


CondTester, a patch instance with id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 228
Counter: 229
Batcher Size:118
Preprocess the following candidate with CondTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(i, n, node, node->right, node->left, len, t, res, ins, f, ins_loc, n->key, argv, argc, n->parent, n->left, n->right, node->parent, node->key)))
    if (x[i] == 'R') {
        node->right = n;
    }


CondTester, a patch instance with id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    if (x[i] == 'R') {
        node->right = n;
    }

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 229
Counter: 230
Batcher Size:119
Preprocess the following candidate with BasicTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'R') {
    node->right = n;
}


BasicTester, a patch instance with id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 230
Counter: 231
Batcher Size:120
Preprocess the following candidate with BasicTester:
Priority 4994
At location prog.c:142
--Src File: prog.c
Fragment 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'R') {
    node->right = n;
}


BasicTester, a patch instance with id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 231
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((x[i] == 'R') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
                node->right = n;
            }
            }
            else if (__get_mutant()==1) {
            if ((x[i] == 'R') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
                node->right = n;
            }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 2;
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 20;
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                break;
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==5) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 0;
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==6) {
            if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                return 1;
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==7) {
            if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                if (x[i] == 'R') {
                    node->right = n;
                }
            }
            else if (__get_mutant()==8) {
            memset(n, 0, sizeof (*(n)));
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            else if (__get_mutant()==9) {
            memset(node, 0, sizeof (*(node)));
            if (x[i] == 'R') {
                node->right = n;
            }
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((x[i] == 'R') && !(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((x[i] == 'R') || (__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key)))) {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 97:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 98:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 99:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 100:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 101:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if ((__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 102:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
if (!(__is_neg(19, &(i), sizeof (i), &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(len), sizeof (len), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    if (x[i] == 'R') {
        node->right = n;
    }

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
BasicTester, Testing instance id 121:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
memset(n, 0, sizeof (*(n)));
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 122:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            
//Patch 0:
memset(node, 0, sizeof (*(node)));
if (x[i] == 'R') {
    node->right = n;
}

//CodeSeg 1:
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 232
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
t->root = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 232
Counter: 233
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
t->root = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 233
Counter: 234
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
t->root = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 234
Counter: 235
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
strcpy((ins_loc), x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
strcpy((ins_loc), x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 235
Counter: 236
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
strcpy(ins_loc, x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 127:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
strcpy(ins_loc, x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 236
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
                return 0;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
                return 1;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
                return 2;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
                return 20;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
                break;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==5) {
            t->root = n;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==6) {
            t->root = (n);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==7) {
            t->root = (node);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==8) {
            strcpy((ins_loc), x);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==9) {
            strcpy(ins_loc, x);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if ((__is_neg(11, &(i), sizeof (i), &(len), sizeof (len), &(node), sizeof (node), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
BasicTester, Testing instance id 123:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 124:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 125:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
t->root = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 126:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
strcpy((ins_loc), x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 127:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
strcpy(ins_loc, x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 237
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 128:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 237
Counter: 238
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = insertNode(&(t), ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 129:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = insertNode(&(t), ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 238
Counter: 239
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = insertNode(&t, ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 130:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = insertNode(&t, ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 239
Counter: 240
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 131:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 240
Counter: 241
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
printf("%d", res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 132:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
printf("%d", res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 241
Counter: 242
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 133:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 242
Counter: 243
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 134:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 243
Counter: 244
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 135:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 244
Counter: 245
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 136:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 245
Counter: 246
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (0);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 137:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (0);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 246
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            //prophet generated patch
            if (__get_mutant()==0) {
            res = (len);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==1) {
            res = insertNode(&(t), ins);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==2) {
            res = insertNode(&t, ins);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==3) {
            res = (res);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==4) {
            printf("%d", res);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==5) {
            res = (20);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==6) {
            res = (i);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==7) {
            res = (ins);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==8) {
            res = (argc);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==9) {
            res = (0);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 128:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 129:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = insertNode(&(t), ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 130:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = insertNode(&t, ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 131:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 132:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
printf("%d", res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 133:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 134:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 135:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 136:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 137:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (0);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 247
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 138:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 247
Counter: 248
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
res = (2);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 139:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (2);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 248
Counter: 249
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->right = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 140:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 249
Counter: 250
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->right = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 141:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 250
Counter: 251
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->left = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 142:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 251
Counter: 252
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->right = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 143:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 252
Counter: 253
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = node->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 144:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = node->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 253
Counter: 254
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->left = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 145:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 254
Counter: 255
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node->left = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 146:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 255
Counter: 256
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = node->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 147:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = node->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 256
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            //prophet generated patch
            if (__get_mutant()==0) {
            res = (1);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==1) {
            res = (2);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==2) {
            node->right = (node);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==3) {
            node->right = n;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==4) {
            node->left = n;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==5) {
            node->right = (n);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==6) {
            node = node->left;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==7) {
            node->left = (n);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==8) {
            node->left = (node);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==9) {
            node = node->right;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 138:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 139:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
res = (2);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 140:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 141:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 142:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = n;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 143:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->right = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 144:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = node->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 145:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 146:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node->left = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 147:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = node->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 257
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (n)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 148:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 257
Counter: 258
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (node)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 149:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 258
Counter: 259
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (node)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 150:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 259
Counter: 260
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 151:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 260
Counter: 261
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
newTree(&(t));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 152:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newTree(&(t));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 261
Counter: 262
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 153:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 262
Counter: 263
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
node = (n)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 154:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 263
Counter: 264
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
newTree(&t);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 155:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newTree(&t);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 264
Counter: 265
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = atoi(x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 156:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = atoi(x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 265
Counter: 266
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
newNode(&(node));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 157:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&(node));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 266
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            //prophet generated patch
            if (__get_mutant()==0) {
            node = (n)->right;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==1) {
            node = (node)->left;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==2) {
            node = (node)->right;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==3) {
            node = (node);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==4) {
            newTree(&(t));
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==5) {
            node = (n);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==6) {
            node = (n)->left;
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==7) {
            newTree(&t);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==8) {
            n->key = atoi(x);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==9) {
            newNode(&(node));
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 148:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 149:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 150:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node)->right;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 151:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (node);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 152:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newTree(&(t));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 153:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 154:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
node = (n)->left;
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 155:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newTree(&t);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 156:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = atoi(x);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 157:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&(node));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Counter: 267
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
newNode(&n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 158:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 267
Counter: 268
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
newNode(&(n));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 159:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&(n));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 268
Counter: 269
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 160:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 269
Counter: 270
Batcher Size:109
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 161:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 270
Counter: 271
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 162:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 271
Counter: 272
Batcher Size:111
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 163:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 272
Counter: 273
Batcher Size:112
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
if (x[i] == 'R') {
    node->right = n;
}
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 164:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if (x[i] == 'R') {
    node->right = n;
}
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 273
Counter: 274
Batcher Size:113
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 165:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 274
Counter: 275
Batcher Size:114
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 166:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 275
Counter: 276
Batcher Size:115
Preprocess the following candidate with BasicTester:
Priority 4993
At location prog.c:135
--Src File: prog.c
Fragment 0:
n->key = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }


BasicTester, a patch instance with id 167:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Spawn 1 instances, now Total 276
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            //prophet generated patch
            if (__get_mutant()==0) {
            newNode(&n);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==1) {
            newNode(&(n));
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==2) {
            n->key = (i);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==3) {
            n->key = (len);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==4) {
            n->key = (res);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==5) {
            n->key = (ins);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==6) {
            if (x[i] == 'R') {
                node->right = n;
            }
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==7) {
            n->key = (1);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==8) {
            n->key = (20);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            else if (__get_mutant()==9) {
            n->key = (argc);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 158:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&n);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 159:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
newNode(&(n));
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 160:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (i);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 161:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (len);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 162:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (res);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 163:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (ins);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Passed Positive Cases
Passed!
BasicTester, Testing instance id 164:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
if (x[i] == 'R') {
    node->right = n;
}
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 165:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (1);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 166:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (20);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 167:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            
//Patch 0:
n->key = (argc);
while (i < (len - 1))
    {
        if (x[i] == 'R')
            node = node->right;
        else if (x[i] == 'L')
            node = node->left;
        i++;
    }

//CodeSeg 1:
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Update best score 4992837.000000
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(t), sizeof (t), &((*t)->root), sizeof ((*t)->root), &((*t)->size), sizeof ((*t)->size))))
        return;
    *t = malloc(sizeof(struct Tree));
    }
    else if (__get_mutant()==1) {
    (*t)->root = ((void *)0);
    *t = malloc(sizeof(struct Tree));
    }
    else if (__get_mutant()==2) {
    *t = malloc(sizeof(struct Tree));
    *t = malloc(sizeof(struct Tree));
    }
    else if (__get_mutant()==3) {
    (*t)->size = 0;
    *t = malloc(sizeof(struct Tree));
    }
    else if (__get_mutant()==4) {
    (*t)->size = (0);
    *t = malloc(sizeof(struct Tree));
    }
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->root), sizeof ((*t)->root), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->root = ((void *)0);
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
*t = malloc(sizeof(struct Tree));
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct Tree));

//CodeSeg 1:
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    //prophet generated patch
    if (__get_mutant()==0) {
    y = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==1) {
    x->parent = (x);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==2) {
    x->parent = (y);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==3) {
    x->key = (0);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==4) {
    x->key = (1);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==5) {
    x->key = (k);
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    else if (__get_mutant()==6) {
    x->key = k;
    while (x != ((void *)0))
        {
            y = x;
            if (x->key == k) {
                return 1;
            }
            while ((x != ((void *)0)) && k < x->key)
                x = x->left;
            if ((x != ((void *)0) && k > x->key))
                x = x->right;
        }
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
y = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = (x);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->parent = (y);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (0);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (1);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = (k);
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    
//Patch 0:
x->key = k;
while (x != ((void *)0))
    {
        y = x;
        if (x->key == k) {
            return 1;
        }
        while ((x != ((void *)0)) && k < x->key)
            x = x->left;
        if ((x != ((void *)0) && k > x->key))
            x = x->right;
    }

//CodeSeg 1:
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
            break;
        y = x;
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
            return 1;
        y = x;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
            return 0;
        y = x;
        }

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    break;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 1;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        
//Patch 0:
if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(k), sizeof (k), &(x->key), sizeof (x->key), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(y->parent), sizeof (y->parent))))
    return 0;
y = x;

//CodeSeg 1:

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x->key == k) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
            return 1;
        }
        }
        else if (__get_mutant()==1) {
        if ((x->key == k) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
            return 1;
        }
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        
//Patch 0:
if ((x->key == k) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
    return 1;
}

//CodeSeg 1:

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        
//Patch 0:
if ((x->key == k) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(y), sizeof (y), &(t), sizeof (t), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(x->parent), sizeof (x->parent)))) {
    return 1;
}

//CodeSeg 1:

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         //prophet generated patch
         if (__get_mutant()==0) {
         if (((x != ((void *)0) && k > x->key)) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
             x = x->right;
         }
         else if (__get_mutant()==1) {
         if (((x != ((void *)0) && k > x->key)) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
             x = x->right;
         }
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         
//Patch 0:
if (((x != ((void *)0) && k > x->key)) && !(__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
    x = x->right;

//CodeSeg 1:
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         
//Patch 0:
if (((x != ((void *)0) && k > x->key)) || (__is_neg(8, &(k), sizeof (k), &(x), sizeof (x), &(x->key), sizeof (x->key), &(x->left), sizeof (x->left), &(x->right), sizeof (x->right), &(y), sizeof (y), &(t), sizeof (t), &(x->parent), sizeof (x->parent))))
    x = x->right;

//CodeSeg 1:
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    //prophet generated patch
    if (__get_mutant()==0) {
    if ((y == ((void *)0)) && !(__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
        (*t)->root = x;
    else {
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
    }
    }
    else if (__get_mutant()==1) {
    if ((y == ((void *)0)) || (__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
        (*t)->root = x;
    else {
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
    }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    
//Patch 0:
if ((y == ((void *)0)) && !(__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}

//CodeSeg 1:
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    
//Patch 0:
if ((y == ((void *)0)) || (__is_neg(14, &(y), sizeof (y), &(t), sizeof (t), &(x), sizeof (x), &((*t)->root), sizeof ((*t)->root), &(k), sizeof (k), &(x->key), sizeof (x->key), &(y->key), sizeof (y->key), &(y->left), sizeof (y->left), &(x->right), sizeof (x->right), &(y->right), sizeof (y->right), &(x->left), sizeof (x->left), &(x->parent), sizeof (x->parent), &((*t)->size), sizeof ((*t)->size), &(y->parent), sizeof (y->parent))))
    (*t)->root = x;
else {
    if (k < y->key)
        y->left = x;
    else
        y->right = x;
}

//CodeSeg 1:
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        //prophet generated patch
        if (__get_mutant()==0) {
        if (!(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
            if (k < y->key)
                y->left = x;
            else
                y->right = x;
        }
        else if (__get_mutant()==1) {
        memset(y, 0, sizeof (*(y)));
        if (k < y->key)
            y->left = x;
        else
            y->right = x;
        }
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 90:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
if (!(__is_neg(12, &(k), sizeof (k), &(y), sizeof (y), &(y->key), sizeof (y->key), &(x), sizeof (x), &(y->left), sizeof (y->left), &(t), sizeof (t), &(y->right), sizeof (y->right), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
    if (k < y->key)
        y->left = x;
    else
        y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 118:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        
//Patch 0:
memset(y, 0, sizeof (*(y)));
if (k < y->key)
    y->left = x;
else
    y->right = x;

//CodeSeg 1:
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                memset(x, 0, sizeof (*(x)));
                y->left = x;
            }
            }
            else if (__get_mutant()==1) {
            {
                if (!(__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
                    y->left = x;
            }
            }
            else if (__get_mutant()==2) {
            {
                memset(y, 0, sizeof (*(y)));
                y->left = x;
            }
            }
            else if (__get_mutant()==3) {
            {
                if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
                    return 1;
                y->left = x;
            }
            }
            else if (__get_mutant()==4) {
            {
                if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
                    return 0;
                y->left = x;
            }
            }
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    memset(x, 0, sizeof (*(x)));
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if (!(__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    memset(y, 0, sizeof (*(y)));
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        return 1;
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            
//Patch 0:
{
    if ((__is_neg(12, &(y), sizeof (y), &(x), sizeof (x), &(y->left), sizeof (y->left), &(k), sizeof (k), &(y->key), sizeof (y->key), &(y->right), sizeof (y->right), &(t), sizeof (t), &(x->parent), sizeof (x->parent), &(x->key), sizeof (x->key), &(x->right), sizeof (x->right), &(x->left), sizeof (x->left), &(y->parent), sizeof (y->parent))))
        return 0;
    y->left = x;
}

//CodeSeg 1:
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    //prophet generated patch
    if (__get_mutant()==0) {
    x[i] = 'R';
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==1) {
    x[i] = '\x00';
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==2) {
    newNode(&(tmp));
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==3) {
    tmp = (tmp);
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==4) {
    tmp = (tmp)->right;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==5) {
    tmp = tmp->left;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==6) {
    tmp = (tmp)->left;
    if (tmp->key == key)
        return "RO";
    }
    else if (__get_mutant()==7) {
    newTree(&(t));
    if (tmp->key == key)
        return "RO";
    }
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = 'R';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
x[i] = '\x00';
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
newNode(&(tmp));
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp);
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp)->right;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = tmp->left;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
tmp = (tmp)->left;
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    
//Patch 0:
newTree(&(t));
if (tmp->key == key)
    return "RO";

//CodeSeg 1:
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((tmp->key == key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
            x[i] = '\x00';
            return x;
        } else if (tmp->key < key) {
            x[i] = 'R';
            i++;
            tmp = tmp->right;
        } else {
            x[i] = 'L';
            i++;
            tmp = tmp->left;
        }
        }
        else if (__get_mutant()==1) {
        if ((tmp->key == key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
            x[i] = '\x00';
            return x;
        } else if (tmp->key < key) {
            x[i] = 'R';
            i++;
            tmp = tmp->right;
        } else {
            x[i] = 'L';
            i++;
            tmp = tmp->left;
        }
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
            return 0;
        if (tmp->key == key) {
            x[i] = '\x00';
            return x;
        } else if (tmp->key < key) {
            x[i] = 'R';
            i++;
            tmp = tmp->right;
        } else {
            x[i] = 'L';
            i++;
            tmp = tmp->left;
        }
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
            break;
        if (tmp->key == key) {
            x[i] = '\x00';
            return x;
        } else if (tmp->key < key) {
            x[i] = 'R';
            i++;
            tmp = tmp->right;
        } else {
            x[i] = 'L';
            i++;
            tmp = tmp->left;
        }
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((tmp->key == key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((tmp->key == key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        
//Patch 0:
if ((__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    break;
if (tmp->key == key) {
    x[i] = '\x00';
    return x;
} else if (tmp->key < key) {
    x[i] = 'R';
    i++;
    tmp = tmp->right;
} else {
    x[i] = 'L';
    i++;
    tmp = tmp->left;
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
                return 0;
            x[i] = '\x00';
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
                break;
            x[i] = '\x00';
            }
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
x[i] = '\x00';

//CodeSeg 1:
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->right), sizeof (tmp->right), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent))))
    break;
x[i] = '\x00';

//CodeSeg 1:
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((tmp->key < key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}
}
else if (__get_mutant()==1) {
{
    if ((tmp->key < key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}
}
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else 
//Patch 0:
{
    if ((tmp->key < key) && !(__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else 
//Patch 0:
{
    if ((tmp->key < key) || (__is_neg(9, &(key), sizeof (key), &(tmp), sizeof (tmp), &(tmp->key), sizeof (tmp->key), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(t), sizeof (t), &(tmp->left), sizeof (tmp->left), &(tmp->parent), sizeof (tmp->parent)))) {
        x[i] = 'R';
        i++;
        tmp = tmp->right;
    } else {
        x[i] = 'L';
        i++;
        tmp = tmp->left;
    }
}

//CodeSeg 1:
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            //prophet generated patch
            if (__get_mutant()==0) {
            x[i] = 'R';
            x[i] = 'L';
            }
            else if (__get_mutant()==1) {
            tmp = (tmp)->right;
            x[i] = 'L';
            }
            else if (__get_mutant()==2) {
            tmp = tmp->left;
            x[i] = 'L';
            }
            else if (__get_mutant()==3) {
            tmp = tmp->right;
            x[i] = 'L';
            }
            else if (__get_mutant()==4) {
            if (tmp->key == key)
                return "RO";
            x[i] = 'L';
            }
            else if (__get_mutant()==5) {
            newNode(&(tmp));
            x[i] = 'L';
            }
            else if (__get_mutant()==6) {
            newTree(&(t));
            x[i] = 'L';
            }
            else if (__get_mutant()==7) {
            tmp = (tmp);
            x[i] = 'L';
            }
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
x[i] = 'R';
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp)->right;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = tmp->left;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = tmp->right;
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
if (tmp->key == key)
    return "RO";
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
newNode(&(tmp));
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
newTree(&(t));
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            
//Patch 0:
tmp = (tmp);
x[i] = 'L';

//CodeSeg 1:
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                break;
            i++;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                return 0;
            i++;
            }
            else if (__get_mutant()==2) {
            if (!(__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                i++;
            }
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    break;
i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if ((__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 88:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            
//Patch 0:
if (!(__is_neg(9, &(i), sizeof (i), &(x), sizeof (x), &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    i++;

//CodeSeg 1:
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                return 0;
            tmp = tmp->left;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                break;
            tmp = tmp->left;
            }
            else if (__get_mutant()==2) {
            memset(tmp, 0, sizeof (*(tmp)));
            tmp = tmp->left;
            }
            else if (__get_mutant()==3) {
            if (!(__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
                tmp = tmp->left;
            }
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    return 0;
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if ((__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    break;
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
memset(tmp, 0, sizeof (*(tmp)));
tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if (!(__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Postprocessing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            
//Patch 0:
if (!(__is_neg(9, &(tmp), sizeof (tmp), &(tmp->left), sizeof (tmp->left), &(i), sizeof (i), &(x), sizeof (x), &(tmp->right), sizeof (tmp->right), &(key), sizeof (key), &(tmp->key), sizeof (tmp->key), &(t), sizeof (t), &(tmp->parent), sizeof (tmp->parent))))
    tmp = tmp->left;

//CodeSeg 1:
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->right == 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->parent == 0
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->key == 3
Verifing Negative cases!
Not passed!
Trying a synthesis expr key == 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->key != 5
Verifing Negative cases!
Not passed!
Trying a synthesis expr i == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 1
Not passed!
Trying a synthesis expr tmp->key == 5
Verifing Negative cases!
Not passed!
Trying a synthesis expr i != 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 1
Not passed!
Trying a synthesis expr i != 3
Verifing Negative cases!
Not passed!
Trying a synthesis expr key != 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr key != 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr key != 4
Verifing Negative cases!
Not passed!
Trying a synthesis expr key != 9
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->key != 10
Verifing Negative cases!
Not passed!
Trying a synthesis expr tmp->key != 3
Verifing Negative cases!
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            //prophet generated patch
            if (!((0)))
                tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            //prophet generated patch
            if (!((1)))
                tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Trying Negative cases!
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    fscanf(f, ("%##uni*##"), x);
    }
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    //prophet generated patch
    if (__get_mutant()==0) {
    fscanf(f, ("%##uni*##"), x);
    }
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    //prophet generated patch
    if (__get_mutant()==0) {
    fscanf(f, ("%##uni*##"), x);
    }

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] == '"') && !(__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            continue;
        }
        else if (__get_mutant()==1) {
        if ((x[0] == '"') || (__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            continue;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            return 0;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            return 1;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            return 2;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            return 20;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
            break;
        if (x[0] == '"')
            continue;
        }
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 4
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Iteration 5
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Iteration 8
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 9
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 1
CondTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(7, &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(t), sizeof (t), &(argv), sizeof (argv), &(argc), sizeof (argc), &(res), sizeof (res), &(ins), sizeof (ins))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 3
Branch 0: 0
Branch 1: 1
Iteration 4
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        //prophet generated patch
        if (__get_mutant()==0) {
        fscanf(f, ("%##uni*##"), x);
        }
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        
//Patch 0:
fscanf(f, ("%##uni*##"), x);

//CodeSeg 1:
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "RO") == 0) && !(__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
            t->root = n;
        } else {
            int i = 0;
            int len = strlen(x);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            if (x[i] == 'R') {
                node->right = n;
            }
            if (x[i] == 'L') {
                node->left = n;
            }
        }
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "RO") == 0) || (__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
            t->root = n;
        } else {
            int i = 0;
            int len = strlen(x);
            while (i < (len - 1))
                {
                    if (x[i] == 'R')
                        node = node->right;
                    else if (x[i] == 'L')
                        node = node->left;
                    i++;
                }
            if (x[i] == 'R') {
                node->right = n;
            }
            if (x[i] == 'L') {
                node->left = n;
            }
        }
        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        
//Patch 0:
if ((strcmp(x, "RO") == 0) && !(__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}

//CodeSeg 1:
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        
//Patch 0:
if ((strcmp(x, "RO") == 0) || (__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size)))) {
    t->root = n;
} else {
    int i = 0;
    int len = strlen(x);
    while (i < (len - 1))
        {
            if (x[i] == 'R')
                node = node->right;
            else if (x[i] == 'L')
                node = node->left;
            i++;
        }
    if (x[i] == 'R') {
        node->right = n;
    }
    if (x[i] == 'L') {
        node->left = n;
    }
}

//CodeSeg 1:
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
                return 0;
            t->root = n;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
                break;
            t->root = n;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
                return 1;
            t->root = n;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
                return 2;
            t->root = n;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
                return 20;
            t->root = n;
            }
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 0;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    break;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 1;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 2;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            
//Patch 0:
if ((__is_neg(15, &(t), sizeof (t), &(n), sizeof (n), &(t->root), sizeof (t->root), &(f), sizeof (f), &(n->key), sizeof (n->key), &(node), sizeof (node), &(ins_loc), sizeof (ins_loc), &(res), sizeof (res), &(ins), sizeof (ins), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(t->size), sizeof (t->size))))
    return 20;
t->root = n;

//CodeSeg 1:
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                //prophet generated patch
                if (__get_mutant()==0) {
                if ((x[i] == 'R') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==1) {
                if ((x[i] == 'R') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==2) {
                if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 0;
                if (x[i] == 'R')
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==3) {
                if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 1;
                if (x[i] == 'R')
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==4) {
                if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 2;
                if (x[i] == 'R')
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==5) {
                if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 20;
                if (x[i] == 'R')
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                else if (__get_mutant()==6) {
                if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    break;
                if (x[i] == 'R')
                    node = node->right;
                else if (x[i] == 'L')
                    node = node->left;
                }
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((x[i] == 'R') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((x[i] == 'R') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                
//Patch 0:
if ((__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(len), sizeof (len), &(node->right), sizeof (node->right), &(node->left), sizeof (node->left), &(t), sizeof (t), &(n), sizeof (n), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
if (x[i] == 'R')
    node = node->right;
else if (x[i] == 'L')
    node = node->left;

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((x[i] == 'L') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}
}
else if (__get_mutant()==1) {
{
    if ((x[i] == 'L') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}
}
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else 
//Patch 0:
{
    if ((x[i] == 'L') && !(__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else 
//Patch 0:
{
    if ((x[i] == 'L') || (__is_neg(15, &(i), sizeof (i), &(node), sizeof (node), &(node->left), sizeof (node->left), &(node->right), sizeof (node->right), &(len), sizeof (len), &(n), sizeof (n), &(t), sizeof (t), &(f), sizeof (f), &(res), sizeof (res), &(ins), sizeof (ins), &(ins_loc), sizeof (ins_loc), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
        node = node->left;
}

//CodeSeg 1:
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                //prophet generated patch
                if (__get_mutant()==0) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 0;
                node->right = n;
                }
                else if (__get_mutant()==1) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 1;
                node->right = n;
                }
                else if (__get_mutant()==2) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 2;
                node->right = n;
                }
                else if (__get_mutant()==3) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 20;
                node->right = n;
                }
                else if (__get_mutant()==4) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    break;
                node->right = n;
                }
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->right), sizeof (node->right), &(i), sizeof (i), &(node->left), sizeof (node->left), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(len), sizeof (len), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
node->right = n;

//CodeSeg 1:
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                //prophet generated patch
                if (__get_mutant()==0) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 0;
                node->left = n;
                }
                else if (__get_mutant()==1) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 1;
                node->left = n;
                }
                else if (__get_mutant()==2) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 2;
                node->left = n;
                }
                else if (__get_mutant()==3) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    return 20;
                node->left = n;
                }
                else if (__get_mutant()==4) {
                if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
                    break;
                node->left = n;
                }
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 0;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 1;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 2;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    return 20;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                
//Patch 0:
if ((__is_neg(19, &(n), sizeof (n), &(node), sizeof (node), &(node->left), sizeof (node->left), &(i), sizeof (i), &(node->right), sizeof (node->right), &(t), sizeof (t), &(res), sizeof (res), &(ins), sizeof (ins), &(f), sizeof (f), &(ins_loc), sizeof (ins_loc), &(len), sizeof (len), &(n->key), sizeof (n->key), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n->parent), sizeof (n->parent), &(n->left), sizeof (n->left), &(n->right), sizeof (n->right), &(node->parent), sizeof (node->parent), &(node->key), sizeof (node->key))))
    break;
node->left = n;

//CodeSeg 1:
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    printf ("%d",res);

    return 0;
}

Testing negative cases!
Testing 4 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    //prophet generated patch
    if (__get_mutant()==0) {
    printf(("%##uni*##"), res);
    }

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct Node {
    struct Node* parent;
    struct Node* left;
    struct Node* right;
    int key;
};

struct Tree {
    struct Node* root;
    int size;
};

void newNode(struct Node** n);
void newTree(struct Tree** t);
void printTree(struct Node** r);
char*  findNode(struct Tree* t, int key) ;
int insertNode (struct Tree** t, int k);

void newNode(struct Node** n) {
    *n = malloc (sizeof (struct Node));
    (*n)->parent = NULL;
    (*n)->left = NULL;
    (*n)->right = NULL;
    (*n)->key = 0;
}

void newTree(struct Tree** t) {
    *t = malloc(sizeof (struct Tree));
    (*t)->root = NULL;
    (*t)->size = 0;
}

int insertNode (struct Tree** t,  int k) {
    struct Node* y= NULL;
    struct Node*  x = (*t)->root;

    while (x != NULL) {
        y=x;

        if (x->key==k) {
            return 1;
        }

        while ((x != NULL) && k<x->key)
            x = x->left;
         if ((x!=NULL && k>x->key))
            x = x->right;
    }
    newNode(&x);
    x->key = k;

    if (y==NULL)
        (*t)->root = x;
    else {
        if (k<y->key)
            y->left = x;
        else
            y->right = x;
    }
    x->parent = y;
    (*t)->size = (*t)->size +1;
    return 0;
}



void printTree(struct Node** r) {
    if ((*r)==NULL) return;
    printf("%d ",(*r)->key);
    printTree(&((*r)->left));
    printTree(&((*r)->right));
}

char*  findNode(struct Tree* t, int key) {
    int i=0;
    char* x = (char*) malloc(10 * sizeof(char));

    struct Node* tmp = t->root;
    if (tmp->key==key) return "RO";
    while (tmp!= NULL) {
        if (tmp->key == key) {
            x[i] = '\0';
            return x;
        } else if (tmp->key < key) {
            x[i]='R';
            i++;
            tmp = tmp->right;
        } else {
            x[i]='L';
            i++;
            tmp = tmp->left;
        }
    }
    return NULL;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    struct Tree* t;
    newTree(&t);

    char x[20];
    int res = 0;
    fscanf(f,"%s",x);
    fscanf(f,"%s",x);
    int ins = atoi(x);
    char *ins_loc;
    fscanf(f,"%s",x);

    ins_loc = (char*)  malloc((strlen(x)+1) * sizeof(char));
    strcpy(ins_loc, x);

    while (fscanf(f,"%s",x)==1) {
        if (x[0]== '"') continue;
        struct Node* n=NULL;
        newNode(&n);
        n->key = atoi(x);
        fscanf(f,"%s",x);
        struct Node* node = t->root;
        if (strcmp(x,"RO")==0) {
            t->root  = n;
        }
        else {
            int i=0;
            int len = strlen(x);
            while (i<(len-1)){
                if (x[i]=='R')
                    node= node->right;
                else if (x[i]=='L')
                    node = node->left;
                i++;
            }
            if (x[i]=='R') {
                node->right = n;
            }
            if (x[i]=='L') {
                node->left = n;
            }

        }
    }
    res = insertNode(&t, ins);
    fclose(f);

    char* loc = findNode(t,ins);
    res += strcmp(loc,ins_loc);
    
//Patch 0:
printf(("%##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Generate a candidate with schema id: 272
Total cnt of passed cond schemas: 1
Total cnt of cond schemas: 103
Counter: 277
Batcher Size:0
The found score 4992837.000000 is greater than current score 4993.000000!
Terminate current session!
Generate a candidate with schema id: 272
Total cnt of passed cond schemas: 1
Total cnt of cond schemas: 103
The first schema id that generates patch: 272
Found a fix! Store to: __fixed_prog.c
Repair process ends successfully!
Total 2602 different repair schemas!!!!
Total 5858 different repair candidate templates for scoring!!!
Total number of compiles: 64
Total number of test eval: 559
