Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 3189 different repair schemas!!!!
Total 6782 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xb5ed9c8
StringConstTester pointer: 0xb7fc028
CondTester pointer: 0xb75b9e0
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:48
--Src File: prog.c
Fragment 0:
if ((l == p) && !(__abst_hole(l, p, list, res, cnt2, (*list)->size, p->next, cnt1, l->next, (*list)->header, p->prev, p->name, l->prev, l->name))) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((l == p) && !(__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:48
--Src File: prog.c
Fragment 0:
if ((l == p) || (__abst_hole(l, p, list, res, cnt2, (*list)->size, p->next, cnt1, l->next, (*list)->header, p->prev, p->name, l->prev, l->name))) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((l == p) || (__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:115
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N2") == 0) && !(__abst_hole(n1, n2, tmp, status, n0, node, f, list, n2->name, n1->name, argv, argc, n1->next, n1->prev, n2->next, n2->prev)))
        tmp = n2;
}


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else 
//Patch 0:
{
    if ((strcmp(x, "N2") == 0) && !(__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:115
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N2") == 0) || (__abst_hole(n1, n2, tmp, status, n0, node, f, list, n2->name, n1->name, argv, argc, n1->next, n1->prev, n2->next, n2->prev)))
        tmp = n2;
}


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else 
//Patch 0:
{
    if ((strcmp(x, "N2") == 0) || (__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:113
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N1") == 0) && !(__abst_hole(n0, n1, tmp, n2, status, node, f, n1->name, list, n0->name, argv, argc, n0->next, n0->prev, n1->next, n1->prev)))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:111
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N0") == 0) || (__abst_hole(n0, tmp, n1, n2, f, status, node, n0->name, list, argv, argc, n0->next, n0->prev)))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:109
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "NULL") == 0) && !(__abst_hole(tmp, n0, f, n1, n2, status, node, list, argv, argc)))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:109
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "NULL") == 0) || (__abst_hole(tmp, n0, f, n1, n2, status, node, list, argv, argc)))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:113
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N1") == 0) || (__abst_hole(n0, n1, tmp, n2, status, node, f, n1->name, list, n0->name, argv, argc, n0->next, n0->prev, n1->next, n1->prev)))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:111
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N0") == 0) && !(__abst_hole(n0, tmp, n1, n2, f, status, node, n0->name, list, argv, argc, n0->next, n0->prev)))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:63
--Src File: prog.c
Fragment 0:
if ((res == 1) && !(__abst_hole(res, cnt1, list, l)))
    return res;


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:63
--Src File: prog.c
Fragment 0:
if ((res == 1) || (__abst_hole(res, cnt1, list, l)))
    return res;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:131
--Src File: prog.c
Fragment 0:
if ((list->header == ((void *)0)) && !(__abst_hole(list, list->header, node, list->size, status, tmp, node->next, f, node->prev, n2, n1, n0, argv, argc, node->name)))
    list->header = node;


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:131
--Src File: prog.c
Fragment 0:
if ((list->header == ((void *)0)) || (__abst_hole(list, list->header, node, list->size, status, tmp, node->next, f, node->prev, n2, n1, n0, argv, argc, node->name)))
    list->header = node;


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:127
--Src File: prog.c
Fragment 0:
{
    if ((status == 2) && !(__abst_hole(status, node, tmp, node->next, list, node->prev, f, n2, n1, n0, argv, argc, node->name))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:127
--Src File: prog.c
Fragment 0:
{
    if ((status == 2) || (__abst_hole(status, node, tmp, node->next, list, node->prev, f, n2, n1, n0, argv, argc, node->name))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:122
--Src File: prog.c
Fragment 0:
{
    if ((status == 1) && !(__abst_hole(status, node, tmp, node->prev, n2, node->next, list, n1, n0, f, argv, argc, node->name))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:122
--Src File: prog.c
Fragment 0:
{
    if ((status == 1) || (__abst_hole(status, node, tmp, node->prev, n2, node->next, list, n1, n0, f, argv, argc, node->name))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:118
--Src File: prog.c
Fragment 0:
if ((status == 0) && !(__abst_hole(status, node, tmp, n2, n1, node->prev, n0, node->next, list, f, argv, argc, node->name))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:118
--Src File: prog.c
Fragment 0:
if ((status == 0) || (__abst_hole(status, node, tmp, n2, n1, node->prev, n0, node->next, list, f, argv, argc, node->name))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((sz > (*list)->size) && !(__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((sz > (*list)->size) || (__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:84
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:84
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    continue;


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    continue;


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 12485
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt1, (*list)->size, l, l->next, (*list)->header, res, l->prev, l->name)))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 12485
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt1, (*list)->size, l, l->next, (*list)->header, res, l->prev, l->name)))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 12454
At location prog.c:22
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, (*n)->next, (*n)->prev, (*n)->name)))
    return;
*n = malloc(sizeof(struct Node));


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 12443
At location prog.c:29
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, (*t)->header, (*t)->size)))
    return;
*t = malloc(sizeof(struct List));


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 12436
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 12436
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 12436
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 12436
At location prog.c:82
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    return 0;
sz = sz + 1;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    return 1;
sz = sz + 1;


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 9995
At location prog.c:69
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    break;
sz = sz + 1;


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 9988
At location prog.c:47
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt2, (*list)->size, l, p, res, cnt1, p->next, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    return 0;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 9988
At location prog.c:47
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt2, (*list)->size, l, p, res, cnt1, p->next, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    return 1;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 9988
At location prog.c:47
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt2, (*list)->size, l, p, res, cnt1, p->next, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    break;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 9978
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 9978
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 9978
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 9978
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 9978
At location prog.c:106
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 9974
At location prog.c:128
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 0;
node->next = tmp;


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 9974
At location prog.c:128
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 1;
node->next = tmp;


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 9974
At location prog.c:128
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 2;
node->next = tmp;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 9974
At location prog.c:128
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 20;
node->next = tmp;


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 9974
At location prog.c:128
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    break;
node->next = tmp;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 9966
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 0;
node->prev = tmp;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 9966
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 1;
node->prev = tmp;


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 9966
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 2;
node->prev = tmp;


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 9966
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 20;
node->prev = tmp;


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 9966
At location prog.c:123
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    break;
node->prev = tmp;


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 9964
At location prog.c:119
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 0;
node = tmp;


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 9964
At location prog.c:119
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 1;
node = tmp;


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 9964
At location prog.c:119
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 2;
node = tmp;


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 9964
At location prog.c:119
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 20;
node = tmp;


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 9964
At location prog.c:119
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    break;
node = tmp;


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 9933
At location prog.c:48
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, p->next, cnt1, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    return 0;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with CondTester:
Priority 9933
At location prog.c:48
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, p->next, cnt1, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    return 1;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with CondTester:
Priority 9933
At location prog.c:48
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, p->next, cnt1, l->next, (*list)->header, p->prev, p->name, l->prev, l->name)))
    break;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with StringConstTester:
Priority 7498
At location prog.c:139
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), res);


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf(("%d##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 74
Counter: 75
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 76
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
        return 0;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
        return 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==2) {
    cnt1 = (0);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==3) {
    l = (l);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==4) {
    res = 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==5) {
    res = (cnt1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==6) {
    res = (res);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==7) {
    l = (l)->next;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==8) {
    res = (0);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==9) {
    res = (1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 4
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 4
CondTester, Postprocessing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr l->next != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr res == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr l->prev == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr (*list)->size == 3
Verifing Negative cases!
Not passed!
Trying a synthesis expr (*list)->size != 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr (*list)->size == 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr (*list)->size != 2
Verifing Negative cases!
Not passed!
Trying a synthesis expr (*list)->size == 1
Verifing Negative cases!
Not passed!
Trying a synthesis expr (*list)->size != 3
Verifing Negative cases!
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (((0)))
        return 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (((1)))
        return 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
Counter: 77
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority 7485
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:22
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority 7454
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority 7443
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority 7443
At location prog.c:29
--Src File: prog.c
Fragment 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:78
Preprocess the following candidate with BasicTester:
Priority 7443
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:79
Preprocess the following candidate with BasicTester:
Priority 7436
At location prog.c:82
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:72
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 0;
    return 0;
}


CondTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:81
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:72
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 1;
    return 0;
}


CondTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 1;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:82
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:72
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        break;
    return 0;
}


CondTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        break;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:83
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:72
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 0;
}


CondTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:84
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:141
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(res, list, f, node, status, n2, n1, n0, argv, argc)))
    return 0;


CondTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if (!(__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:85
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:141
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, status, n2, n1, n0, argv, argc)))
    return 0;
return 0;


CondTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
return 0;

//CodeSeg 1:
}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:86
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:141
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, status, n2, n1, n0, argv, argc)))
    return 1;
return 0;


CondTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
return 0;

//CodeSeg 1:
}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:87
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:141
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, status, n2, n1, n0, argv, argc)))
    return 2;
return 0;


CondTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
return 0;

//CodeSeg 1:
}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:88
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:141
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, status, n2, n1, n0, argv, argc)))
    return 20;
return 0;


CondTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
return 0;

//CodeSeg 1:
}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
strrchr("%d ", res);


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strrchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
strrchr("%d ", res);


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strrchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:91
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, list->header, list->size, status, n2, n1, n0, argv, argc)))
    return 0;
printf("%d ", res);


CondTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:92
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, list->header, list->size, status, n2, n1, n0, argv, argc)))
    return 1;
printf("%d ", res);


CondTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:93
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, list->header, list->size, status, n2, n1, n0, argv, argc)))
    return 2;
printf("%d ", res);


CondTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:94
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
if ((__abst_hole(res, list, f, node, list->header, list->size, status, n2, n1, n0, argv, argc)))
    return 20;
printf("%d ", res);


CondTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:95
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(res, list, f, node, list->header, list->size, status, n2, n1, n0, argv, argc)))
    printf("%d ", res);


CondTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if (!(__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
__overflow("%d ", res);


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
__overflow("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
printf("%d ", res);


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 108
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    //prophet generated patch
    if (__get_mutant()==0) {
    printf(("%d##uni*##"), res);
    }
    else if (__get_mutant()==1) {
    strrchr("%d ", res);
    }
    else if (__get_mutant()==2) {
    strrchr("%d ", res);
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    printf("%d ", res);
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    printf("%d ", res);
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    printf("%d ", res);
    }
    else if (__get_mutant()==6) {
    if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    printf("%d ", res);
    }
    else if (__get_mutant()==7) {
    if (!(__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        printf("%d ", res);
    }
    else if (__get_mutant()==8) {
    __overflow("%d ", res);
    }
    else if (__get_mutant()==9) {
    printf("%d ", res);
    }

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf(("%d##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strrchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strrchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if ((__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
if (!(__is_neg(12, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(list->header), sizeof (list->header), &(list->size), sizeof (list->size), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
__overflow("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Counter: 109
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
scanf("%d ", res);


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 109
Counter: 110
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
scanf("%d ", res);


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
scanf("%d ", res);


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
strchr("%d ", res);


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
strchr("%d ", res);


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:139
--Src File: prog.c
Fragment 0:
wctomb("%d ", res);


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
wctomb("%d ", res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:94
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:95
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 1;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:96
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:71
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    break;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:71
--Src File: prog.c
Fragment 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:98
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:71
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    if (sz > (*list)->size)
        return 0;


CondTester, a patch instance with id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    if (sz > (*list)->size)
        return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 119
Counter: 120
Batcher Size:99
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:70
--Src File: prog.c
Fragment 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:100
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:70
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    l1 = l1->next;


CondTester, a patch instance with id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:101
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:70
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1->next, l1, (*list)->size, list, sz, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    break;
l1 = l1->next;


CondTester, a patch instance with id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1->next), sizeof (l1->next), &(l1), sizeof (l1), &((*list)->size), sizeof ((*list)->size), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:102
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:70
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;
l1 = l1->next;


CondTester, a patch instance with id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:103
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:70
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 1;
l1 = l1->next;


CondTester, a patch instance with id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:104
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
sz = (cnt1);
sz = sz + 1;


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:105
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
sz = (1);
sz = sz + 1;


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:106
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
sz = sz + 1;
sz = sz + 1;


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = sz + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:107
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
sz = (res);
sz = sz + 1;


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:108
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
sz = (sz);
sz = sz + 1;


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 129
Counter: 130
Batcher Size:109
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    sz = sz + 1;


CondTester, a patch instance with id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:110
Preprocess the following candidate with BasicTester:
Priority 4995
At location prog.c:69
--Src File: prog.c
Fragment 0:
l = (l1)->next;
sz = sz + 1;


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 131
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        sz = sz + 1;
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        sz = sz + 1;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        sz = sz + 1;
        }
        else if (__get_mutant()==3) {
        sz = (cnt1);
        sz = sz + 1;
        }
        else if (__get_mutant()==4) {
        sz = (1);
        sz = sz + 1;
        }
        else if (__get_mutant()==5) {
        sz = sz + 1;
        sz = sz + 1;
        }
        else if (__get_mutant()==6) {
        sz = (res);
        sz = sz + 1;
        }
        else if (__get_mutant()==7) {
        sz = (sz);
        sz = sz + 1;
        }
        else if (__get_mutant()==8) {
        if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            sz = sz + 1;
        }
        else if (__get_mutant()==9) {
        l = (l1)->next;
        sz = sz + 1;
        }
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
BasicTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = sz + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 87:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 4
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 5
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 8
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 9
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Postprocessing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 4
Not passed!
Trying a synthesis expr l != 0
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 9994963.000000
CondTester, Postprocessing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     //prophet generated patch
     if (__get_mutant()==0) {
     if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
         return;
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==1) {
     (*n)->name = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==2) {
     *n = malloc(sizeof(struct Node));
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==3) {
     (*n)->prev = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==4) {
     (*n)->next = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
        return;
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*t)->header = ((void *)0);
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    (*t)->size = 0;
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    *t = malloc(sizeof(struct List));
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    (*t)->size = (0);
    *t = malloc(sizeof(struct List));
    }
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    newNode(&(l));
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==1) {
    l = l->next;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==2) {
    if (res == 1)
        return res;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==3) {
    cnt1 = cnt1 + 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==4) {
    cnt1 = (cnt1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==5) {
    cnt1 = (res);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==6) {
    cnt1 = (1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while (cnt2 < (*list)->size)
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = p->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 0;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 1;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            break;
        while (cnt2 < (*list)->size)
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = p->next;
            }
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Postprocessing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        
//Patch 0:
if ((__is_neg(14, &(list), sizeof (list), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(p), sizeof (p), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(p->next), sizeof (p->next), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt2 < (*list)->size)
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = p->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((l == p) && !(__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==1) {
            if ((l == p) || (__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                return 0;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                return 1;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                break;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((l == p) && !(__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((l == p) || (__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            
//Patch 0:
if ((__is_neg(14, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(p->next), sizeof (p->next), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(p->prev), sizeof (p->prev), &(p->name), sizeof (p->name), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
            return res;
        }
        else if (__get_mutant()==1) {
        if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
            return res;
        }

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        //prophet generated patch
        if (__get_mutant()==0) {
        memset(l1, 0, sizeof (*(l1)));
        l1 = l1->next;
        }
        else if (__get_mutant()==1) {
        if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            l1 = l1->next;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(l1->next), sizeof (l1->next), &(l1), sizeof (l1), &((*list)->size), sizeof ((*list)->size), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        l1 = l1->next;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        l1 = l1->next;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        l1 = l1->next;
        }
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 83:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1->next), sizeof (l1->next), &(l1), sizeof (l1), &((*list)->size), sizeof ((*list)->size), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 85:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 3 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 6 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Testing 7 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Testing 8 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Postprocessing instance id 84:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1->next), sizeof (l1->next), &(l1), sizeof (l1), &((*list)->size), sizeof ((*list)->size), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
CondTester, Postprocessing instance id 86:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        }
        else if (__get_mutant()==1) {
        if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==5) {
        memset((*list), 0, sizeof (*((*list))));
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==6) {
        if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            if (sz > (*list)->size)
                return 0;
        }
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 81:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
BasicTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 82:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    if (sz > (*list)->size)
        return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 0;
                return 0;
            }
            }
            else if (__get_mutant()==1) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 1;
                return 0;
            }
            }
            else if (__get_mutant()==2) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    break;
                return 0;
            }
            }
            else if (__get_mutant()==3) {
            {
                if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 0;
            }
            }
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 1;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Strange error or non-deterministic behavior!
CondTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        break;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
BasicTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==1) {
        if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 0;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 1;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 2;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 20;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            break;
        if (x[0] == '"')
            continue;
        }

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 1
Branch 11: 1
Branch 12: 1
Branch 13: 1
Branch 14: 1
Branch 15: 1
Branch 16: 1
Branch 17: 1
Branch 18: 1
Branch 19: 1
Branch 20: 1
Branch 21: 1
Branch 22: 1
Branch 23: 1
Branch 24: 1
Branch 25: 1
Branch 26: 1
Branch 27: 1
Branch 28: 1
Branch 29: 1
Branch 30: 1
Branch 31: 1
Branch 32: 1
Branch 33: 1
Branch 34: 1
Branch 35: 1
Branch 36: 1
Branch 37: 1
Branch 38: 1
Branch 39: 1
Branch 40: 1
Branch 41: 1
Branch 42: 1
Branch 43: 1
Branch 44: 1
Branch 45: 1
Branch 46: 1
Branch 47: 1
Branch 48: 1
Branch 49: 1
Branch 50: 1
Branch 51: 1
Branch 52: 1
Branch 53: 1
Branch 54: 1
Branch 55: 1
Branch 56: 1
Branch 57: 1
Branch 58: 1
Branch 59: 1
Branch 60: 1
Branch 61: 1
Branch 62: 1
Branch 63: 1
Branch 64: 1
Branch 65: 1
Branch 66: 1
Branch 67: 1
Branch 68: 1
Branch 69: 1
Branch 70: 1
Branch 71: 1
Branch 72: 1
Branch 73: 1
Branch 74: 1
Branch 75: 1
Branch 76: 1
Branch 77: 1
Branch 78: 1
Branch 79: 1
Branch 80: 1
Branch 81: 1
Branch 82: 1
Branch 83: 1
Branch 84: 1
Branch 85: 1
Branch 86: 1
Branch 87: 1
Branch 88: 1
Branch 89: 1
Branch 90: 1
Branch 91: 1
Branch 92: 1
Branch 93: 1
Branch 94: 1
Branch 95: 1
Branch 96: 1
Branch 97: 1
Branch 98: 1
Branch 99: 1
Branch 100: 1
Branch 101: 1
Branch 102: 1
Branch 103: 1
Branch 104: 1
Branch 105: 1
Branch 106: 1
Branch 107: 1
Branch 108: 1
Branch 109: 1
Branch 110: 1
Branch 111: 1
Branch 112: 1
Branch 113: 1
Branch 114: 1
Branch 115: 1
Branch 116: 1
Branch 117: 1
Branch 118: 1
Branch 119: 1
Branch 120: 1
Branch 121: 1
Branch 122: 1
Branch 123: 1
Branch 124: 1
Branch 125: 1
Branch 126: 1
Branch 127: 1
Branch 128: 1
Branch 129: 1
Branch 130: 1
Branch 131: 1
Branch 132: 1
Branch 133: 1
Branch 134: 1
Branch 135: 1
Branch 136: 1
Branch 137: 1
Branch 138: 1
Branch 139: 1
Branch 140: 1
Branch 141: 1
Branch 142: 1
Branch 143: 1
Branch 144: 1
Branch 145: 1
Branch 146: 1
Branch 147: 1
Branch 148: 1
Branch 149: 1
Branch 150: 1
Branch 151: 1
Branch 152: 1
Branch 153: 1
Branch 154: 1
Branch 155: 1
Branch 156: 1
Branch 157: 1
Branch 158: 1
Branch 159: 1
Branch 160: 1
Branch 161: 1
Branch 162: 1
Branch 163: 1
Branch 164: 1
Branch 165: 1
Branch 166: 1
Branch 167: 1
Branch 168: 1
Branch 169: 1
Branch 170: 1
Branch 171: 1
Branch 172: 1
Branch 173: 1
Branch 174: 1
Branch 175: 1
Branch 176: 1
Branch 177: 1
Branch 178: 1
Branch 179: 1
Branch 180: 1
Branch 181: 1
Branch 182: 1
Branch 183: 1
Branch 184: 1
Branch 185: 1
Branch 186: 1
Branch 187: 1
Branch 188: 1
Branch 189: 1
Branch 190: 1
Branch 191: 1
Branch 192: 1
Branch 193: 1
Branch 194: 1
Branch 195: 1
Branch 196: 1
Branch 197: 1
Branch 198: 1
Branch 199: 1
Branch 200: 1
Branch 201: 1
Branch 202: 1
Branch 203: 1
Branch 204: 1
Branch 205: 1
Branch 206: 1
Branch 207: 1
Branch 208: 1
Branch 209: 1
Branch 210: 1
Branch 211: 1
Branch 212: 1
Branch 213: 1
Branch 214: 1
Branch 215: 1
Branch 216: 1
Branch 217: 1
Branch 218: 1
Branch 219: 1
Branch 220: 1
Branch 221: 1
Branch 222: 1
Branch 223: 1
Branch 224: 1
Branch 225: 1
Branch 226: 1
Branch 227: 1
Branch 228: 1
Branch 229: 1
Branch 230: 1
Branch 231: 1
Branch 232: 1
Branch 233: 1
Branch 234: 1
Branch 235: 1
Branch 236: 1
Branch 237: 1
Branch 238: 1
Branch 239: 1
Branch 240: 1
Branch 241: 1
Branch 242: 1
Branch 243: 1
Branch 244: 1
Branch 245: 1
Branch 246: 1
Branch 247: 1
Branch 248: 1
Branch 249: 1
Branch 250: 1
Branch 251: 1
Branch 252: 1
Branch 253: 1
Branch 254: 1
Branch 255: 1
Branch 256: 1
Branch 257: 1
Branch 258: 1
Branch 259: 1
Branch 260: 1
Branch 261: 1
Branch 262: 1
Branch 263: 1
Branch 264: 1
Branch 265: 1
Branch 266: 1
Branch 267: 1
Branch 268: 1
Branch 269: 1
Branch 270: 1
Branch 271: 1
Branch 272: 1
Branch 273: 1
Branch 274: 1
Branch 275: 1
Branch 276: 1
Branch 277: 1
Branch 278: 1
Branch 279: 1
Branch 280: 1
Branch 281: 1
Branch 282: 1
Branch 283: 1
Branch 284: 1
Branch 285: 1
Branch 286: 1
Branch 287: 1
Branch 288: 1
Branch 289: 1
Branch 290: 1
Branch 291: 1
Branch 292: 1
Branch 293: 1
Branch 294: 1
Branch 295: 1
Branch 296: 1
Branch 297: 1
Branch 298: 1
Branch 299: 1
Branch 300: 1
Branch 301: 1
Branch 302: 1
Branch 303: 1
Branch 304: 1
Branch 305: 1
Branch 306: 1
Branch 307: 1
Branch 308: 1
Branch 309: 1
Branch 310: 1
Branch 311: 1
Branch 312: 1
Branch 313: 1
Branch 314: 1
Branch 315: 1
Branch 316: 1
Branch 317: 1
Branch 318: 1
Branch 319: 1
Branch 320: 1
Branch 321: 1
Branch 322: 1
Branch 323: 1
Branch 324: 1
Branch 325: 1
Branch 326: 1
Branch 327: 1
Branch 328: 1
Branch 329: 1
Branch 330: 1
Branch 331: 1
Branch 332: 1
Branch 333: 1
Branch 334: 1
Branch 335: 1
Branch 336: 1
Branch 337: 1
Branch 338: 1
Branch 339: 1
Branch 340: 1
Branch 341: 1
Branch 342: 1
Branch 343: 1
Branch 344: 1
Branch 345: 1
Branch 346: 1
Branch 347: 1
Branch 348: 1
Branch 349: 1
Branch 350: 1
Branch 351: 1
Branch 352: 1
Branch 353: 1
Branch 354: 1
Branch 355: 1
Branch 356: 1
Branch 357: 1
Branch 358: 1
Branch 359: 1
Branch 360: 1
Branch 361: 1
Branch 362: 1
Branch 363: 1
Branch 364: 1
Branch 365: 1
Branch 366: 1
Branch 367: 1
Branch 368: 1
Branch 369: 1
Branch 370: 1
Branch 371: 1
Branch 372: 1
Branch 373: 1
Branch 374: 1
Branch 375: 1
Branch 376: 1
Branch 377: 1
Branch 378: 1
Branch 379: 1
Branch 380: 1
Branch 381: 1
Branch 382: 1
Branch 383: 1
Branch 384: 1
Branch 385: 1
Branch 386: 1
Branch 387: 1
Branch 388: 1
Branch 389: 1
Branch 390: 1
Branch 391: 1
Branch 392: 1
Branch 393: 1
Branch 394: 1
Branch 395: 1
Branch 396: 1
Branch 397: 1
Branch 398: 1
Branch 399: 1
Branch 400: 1
Branch 401: 1
Branch 402: 1
Branch 403: 1
Branch 404: 1
Branch 405: 1
Branch 406: 1
Branch 407: 1
Branch 408: 1
Branch 409: 1
Branch 410: 1
Branch 411: 1
Branch 412: 1
Branch 413: 1
Branch 414: 1
Branch 415: 1
Branch 416: 1
Branch 417: 1
Branch 418: 1
Branch 419: 1
Branch 420: 1
Branch 421: 1
Branch 422: 1
Branch 423: 1
Branch 424: 1
Branch 425: 1
Branch 426: 1
Branch 427: 1
Branch 428: 1
Branch 429: 1
Branch 430: 1
Branch 431: 1
Branch 432: 1
Branch 433: 1
Branch 434: 1
Branch 435: 1
Branch 436: 1
Branch 437: 1
Branch 438: 1
Branch 439: 1
Branch 440: 1
Branch 441: 1
Branch 442: 1
Branch 443: 1
Branch 444: 1
Branch 445: 1
Branch 446: 1
Branch 447: 1
Branch 448: 1
Branch 449: 1
Branch 450: 1
Branch 451: 1
Branch 452: 1
Branch 453: 1
Branch 454: 1
Branch 455: 1
Branch 456: 1
Branch 457: 1
Branch 458: 1
Branch 459: 1
Branch 460: 1
Branch 461: 1
Branch 462: 1
Branch 463: 1
Branch 464: 1
Branch 465: 1
Branch 466: 1
Branch 467: 1
Branch 468: 1
Branch 469: 1
Branch 470: 1
Branch 471: 1
Branch 472: 1
Branch 473: 1
Branch 474: 1
Branch 475: 1
Branch 476: 1
Branch 477: 1
Branch 478: 1
Branch 479: 1
Branch 480: 1
Branch 481: 1
Branch 482: 1
Branch 483: 1
Branch 484: 1
Branch 485: 1
Branch 486: 1
Branch 487: 1
Branch 488: 1
Branch 489: 1
Branch 490: 1
Branch 491: 1
Branch 492: 1
Branch 493: 1
Branch 494: 1
Branch 495: 1
Branch 496: 1
Branch 497: 1
Branch 498: 1
Branch 499: 1
Branch 500: 1
Branch 501: 1
Branch 502: 1
Branch 503: 1
Branch 504: 1
Branch 505: 1
Branch 506: 1
Branch 507: 1
Branch 508: 1
Branch 509: 1
Branch 510: 1
Branch 511: 1
Branch 512: 1
Branch 513: 1
Branch 514: 1
Branch 515: 1
Branch 516: 1
Branch 517: 1
Branch 518: 1
Branch 519: 1
Branch 520: 1
Branch 521: 1
Branch 522: 1
Branch 523: 1
Branch 524: 1
Branch 525: 1
Branch 526: 1
Branch 527: 1
Branch 528: 1
Branch 529: 1
Branch 530: 1
Branch 531: 1
Branch 532: 1
Branch 533: 1
Branch 534: 1
Branch 535: 1
Branch 536: 1
Branch 537: 1
Branch 538: 1
Branch 539: 1
Branch 540: 1
Branch 541: 1
Branch 542: 1
Branch 543: 1
Branch 544: 1
Branch 545: 1
Branch 546: 1
Branch 547: 1
Branch 548: 1
Branch 549: 1
Branch 550: 1
Branch 551: 1
Branch 552: 1
Branch 553: 1
Branch 554: 1
Branch 555: 1
Branch 556: 1
Branch 557: 1
Branch 558: 1
Branch 559: 1
Branch 560: 1
Branch 561: 1
Branch 562: 1
Branch 563: 1
Branch 564: 1
Branch 565: 1
Branch 566: 1
Branch 567: 1
Branch 568: 1
Branch 569: 1
Branch 570: 1
Branch 571: 1
Branch 572: 1
Branch 573: 1
Branch 574: 1
Branch 575: 1
Branch 576: 1
Branch 577: 1
Branch 578: 1
Branch 579: 1
Branch 580: 1
Branch 581: 1
Branch 582: 1
Branch 583: 1
Branch 584: 1
Branch 585: 1
Branch 586: 1
Branch 587: 1
Branch 588: 1
Branch 589: 1
Branch 590: 1
Branch 591: 1
Branch 592: 1
Branch 593: 1
Branch 594: 1
Branch 595: 1
Branch 596: 1
Branch 597: 1
Branch 598: 1
Branch 599: 1
Branch 600: 1
Branch 601: 1
Branch 602: 1
Branch 603: 1
Branch 604: 1
Branch 605: 1
Branch 606: 1
Branch 607: 1
Branch 608: 1
Branch 609: 1
Branch 610: 1
Branch 611: 1
Branch 612: 1
Branch 613: 1
Branch 614: 1
Branch 615: 1
Branch 616: 1
Branch 617: 1
Branch 618: 1
Branch 619: 1
Branch 620: 1
Branch 621: 1
Branch 622: 1
Branch 623: 1
Branch 624: 1
Branch 625: 1
Branch 626: 1
Branch 627: 1
Branch 628: 1
Branch 629: 1
Branch 630: 1
Branch 631: 1
Branch 632: 1
Branch 633: 1
Branch 634: 1
Branch 635: 1
Branch 636: 1
Branch 637: 1
Branch 638: 1
Branch 639: 1
Branch 640: 1
Branch 641: 1
Branch 642: 1
Branch 643: 1
Branch 644: 1
Branch 645: 1
Branch 646: 1
Branch 647: 1
Branch 648: 1
Branch 649: 1
Branch 650: 1
Branch 651: 1
Branch 652: 1
Branch 653: 1
Branch 654: 1
Branch 655: 1
Branch 656: 1
Branch 657: 1
Branch 658: 1
Branch 659: 1
Branch 660: 1
Branch 661: 1
Branch 662: 1
Branch 663: 1
Branch 664: 1
Branch 665: 1
Branch 666: 1
Branch 667: 1
Branch 668: 1
Branch 669: 1
Branch 670: 1
Branch 671: 1
Branch 672: 1
Branch 673: 1
Branch 674: 1
Branch 675: 1
Branch 676: 1
Branch 677: 1
Branch 678: 1
Branch 679: 1
Branch 680: 1
Branch 681: 1
Branch 682: 1
Branch 683: 1
Branch 684: 1
Branch 685: 1
Branch 686: 1
Branch 687: 1
Branch 688: 1
Branch 689: 1
Branch 690: 1
Branch 691: 1
Branch 692: 1
Branch 693: 1
Branch 694: 1
Branch 695: 1
Branch 696: 1
Branch 697: 1
Branch 698: 1
Branch 699: 1
Branch 700: 1
Branch 701: 1
Branch 702: 1
Branch 703: 1
Branch 704: 1
Branch 705: 1
Branch 706: 1
Branch 707: 1
Branch 708: 1
Branch 709: 1
Branch 710: 1
Branch 711: 1
Branch 712: 1
Branch 713: 1
Branch 714: 1
Branch 715: 1
Branch 716: 1
Branch 717: 1
Branch 718: 1
Branch 719: 1
Branch 720: 1
Branch 721: 1
Branch 722: 1
Branch 723: 1
Branch 724: 1
Branch 725: 1
Branch 726: 1
Branch 727: 1
Branch 728: 1
Branch 729: 1
Branch 730: 1
Branch 731: 1
Branch 732: 1
Branch 733: 1
Branch 734: 1
Branch 735: 1
Branch 736: 1
Branch 737: 1
Branch 738: 1
Branch 739: 1
Branch 740: 1
Branch 741: 1
Branch 742: 1
Branch 743: 1
Branch 744: 1
Branch 745: 1
Branch 746: 1
Branch 747: 1
Branch 748: 1
Branch 749: 1
Branch 750: 1
Branch 751: 1
Branch 752: 1
Branch 753: 1
Branch 754: 1
Branch 755: 1
Branch 756: 1
Branch 757: 1
Branch 758: 1
Branch 759: 1
Branch 760: 1
Branch 761: 1
Branch 762: 1
Branch 763: 1
Branch 764: 1
Branch 765: 1
Branch 766: 1
Branch 767: 1
Branch 768: 1
Branch 769: 1
Branch 770: 1
Branch 771: 1
Branch 772: 1
Branch 773: 1
Branch 774: 1
Branch 775: 1
Branch 776: 1
Branch 777: 1
Branch 778: 1
Branch 779: 1
Branch 780: 1
Branch 781: 1
Branch 782: 1
Branch 783: 1
Branch 784: 1
Branch 785: 1
Branch 786: 1
Branch 787: 1
Branch 788: 1
Branch 789: 1
Branch 790: 1
Branch 791: 1
Branch 792: 1
Branch 793: 1
Branch 794: 1
Branch 795: 1
Branch 796: 1
Branch 797: 1
Branch 798: 1
Branch 799: 1
Branch 800: 1
Branch 801: 1
Branch 802: 1
Branch 803: 1
Branch 804: 1
Branch 805: 1
Branch 806: 1
Branch 807: 1
Branch 808: 1
Branch 809: 1
Branch 810: 1
Branch 811: 1
Branch 812: 1
Branch 813: 1
Branch 814: 1
Branch 815: 1
Branch 816: 1
Branch 817: 1
Branch 818: 1
Branch 819: 1
Branch 820: 1
Branch 821: 1
Branch 822: 1
Branch 823: 1
Branch 824: 1
Branch 825: 1
Branch 826: 1
Branch 827: 1
Branch 828: 1
Branch 829: 1
Branch 830: 1
Branch 831: 1
Branch 832: 1
Branch 833: 1
Branch 834: 1
Branch 835: 1
Branch 836: 1
Branch 837: 1
Branch 838: 1
Branch 839: 1
Branch 840: 1
Branch 841: 1
Branch 842: 1
Branch 843: 1
Branch 844: 1
Branch 845: 1
Branch 846: 1
Branch 847: 1
Branch 848: 1
Branch 849: 1
Branch 850: 1
Branch 851: 1
Branch 852: 1
Branch 853: 1
Branch 854: 1
Branch 855: 1
Branch 856: 1
Branch 857: 1
Branch 858: 1
Branch 859: 1
Branch 860: 1
Branch 861: 1
Branch 862: 1
Branch 863: 1
Branch 864: 1
Branch 865: 1
Branch 866: 1
Branch 867: 1
Branch 868: 1
Branch 869: 1
Branch 870: 1
Branch 871: 1
Branch 872: 1
Branch 873: 1
Branch 874: 1
Branch 875: 1
Branch 876: 1
Branch 877: 1
Branch 878: 1
Branch 879: 1
Branch 880: 1
Branch 881: 1
Branch 882: 1
Branch 883: 1
Branch 884: 1
Branch 885: 1
Branch 886: 1
Branch 887: 1
Branch 888: 1
Branch 889: 1
Branch 890: 1
Branch 891: 1
Branch 892: 1
Branch 893: 1
Branch 894: 1
Branch 895: 1
Branch 896: 1
Branch 897: 1
Branch 898: 1
Branch 899: 1
Branch 900: 1
Branch 901: 1
Branch 902: 1
Branch 903: 1
Branch 904: 1
Branch 905: 1
Branch 906: 1
Branch 907: 1
Branch 908: 1
Branch 909: 1
Branch 910: 1
Branch 911: 1
Branch 912: 1
Branch 913: 1
Branch 914: 1
Branch 915: 1
Branch 916: 1
Branch 917: 1
Branch 918: 1
Branch 919: 1
Branch 920: 1
Branch 921: 1
Branch 922: 1
Branch 923: 1
Branch 924: 1
Branch 925: 1
Branch 926: 1
Branch 927: 1
Branch 928: 1
Branch 929: 1
Branch 930: 1
Branch 931: 1
Branch 932: 1
Branch 933: 1
Branch 934: 1
Branch 935: 1
Branch 936: 1
Branch 937: 1
Branch 938: 1
Branch 939: 1
Branch 940: 1
Branch 941: 1
Branch 942: 1
Branch 943: 1
Branch 944: 1
Branch 945: 1
Branch 946: 1
Branch 947: 1
Branch 948: 1
Branch 949: 1
Branch 950: 1
Branch 951: 1
Branch 952: 1
Branch 953: 1
Branch 954: 1
Branch 955: 1
Branch 956: 1
Branch 957: 1
Branch 958: 1
Branch 959: 1
Branch 960: 1
Branch 961: 1
Branch 962: 1
Branch 963: 1
Branch 964: 1
Branch 965: 1
Branch 966: 1
Branch 967: 1
Branch 968: 1
Branch 969: 1
Branch 970: 1
Branch 971: 1
Branch 972: 1
Branch 973: 1
Branch 974: 1
Branch 975: 1
Branch 976: 1
Branch 977: 1
Branch 978: 1
Branch 979: 1
Branch 980: 1
Branch 981: 1
Branch 982: 1
Branch 983: 1
Branch 984: 1
Branch 985: 1
Branch 986: 1
Branch 987: 1
Branch 988: 1
Branch 989: 1
Branch 990: 1
Branch 991: 1
Branch 992: 1
Branch 993: 1
Branch 994: 1
Branch 995: 1
Branch 996: 1
Branch 997: 1
Branch 998: 1
Branch 999: 1
Branch 1000: 1
Branch 1001: 1
Branch 1002: 1
Branch 1003: 1
Branch 1004: 1
Branch 1005: 1
Branch 1006: 1
Branch 1007: 1
Branch 1008: 1
Branch 1009: 1
Branch 1010: 1
Branch 1011: 1
Branch 1012: 1
Branch 1013: 1
Branch 1014: 1
Branch 1015: 1
Branch 1016: 1
Branch 1017: 1
Branch 1018: 1
Branch 1019: 1
Branch 1020: 1
Branch 1021: 1
Branch 1022: 1
Branch 1023: 1
Branch 1024: 1
Branch 1025: 1
Branch 1026: 1
Branch 1027: 1
Branch 1028: 1
Branch 1029: 1
Branch 1030: 1
Branch 1031: 1
Branch 1032: 1
Branch 1033: 1
Branch 1034: 1
Branch 1035: 1
Branch 1036: 1
Branch 1037: 1
Branch 1038: 1
Branch 1039: 1
Branch 1040: 1
Branch 1041: 1
Branch 1042: 1
Branch 1043: 1
Branch 1044: 1
Branch 1045: 1
Branch 1046: 1
Branch 1047: 1
Branch 1048: 1
Branch 1049: 1
Branch 1050: 1
Branch 1051: 1
Branch 1052: 1
Branch 1053: 1
Branch 1054: 1
Branch 1055: 1
Branch 1056: 1
Branch 1057: 1
Branch 1058: 1
Branch 1059: 1
Branch 1060: 1
Branch 1061: 1
Branch 1062: 1
Branch 1063: 1
Branch 1064: 1
Branch 1065: 1
Branch 1066: 1
Branch 1067: 1
Branch 1068: 1
Branch 1069: 1
Branch 1070: 1
Branch 1071: 1
Branch 1072: 1
Branch 1073: 1
Branch 1074: 1
Branch 1075: 1
Branch 1076: 1
Branch 1077: 1
Branch 1078: 1
Branch 1079: 1
Branch 1080: 1
Branch 1081: 1
Branch 1082: 1
Branch 1083: 1
Branch 1084: 1
Branch 1085: 1
Branch 1086: 1
Branch 1087: 1
Branch 1088: 1
Branch 1089: 1
Branch 1090: 1
Branch 1091: 1
Branch 1092: 1
Branch 1093: 1
Branch 1094: 1
Branch 1095: 1
Branch 1096: 1
Branch 1097: 1
Branch 1098: 1
Branch 1099: 1
Branch 1100: 1
Branch 1101: 1
Branch 1102: 1
Branch 1103: 1
Branch 1104: 1
Branch 1105: 1
Branch 1106: 1
Branch 1107: 1
Branch 1108: 1
Branch 1109: 1
Branch 1110: 1
Branch 1111: 1
Branch 1112: 1
Branch 1113: 1
Branch 1114: 1
Branch 1115: 1
Branch 1116: 1
Branch 1117: 1
Branch 1118: 1
Branch 1119: 1
Branch 1120: 1
Branch 1121: 1
Branch 1122: 1
Branch 1123: 1
Branch 1124: 1
Branch 1125: 1
Branch 1126: 1
Branch 1127: 1
Branch 1128: 1
Branch 1129: 1
Branch 1130: 1
Branch 1131: 1
Branch 1132: 1
Branch 1133: 1
Branch 1134: 1
Branch 1135: 1
Branch 1136: 1
Branch 1137: 1
Branch 1138: 1
Branch 1139: 1
Branch 1140: 1
Branch 1141: 1
Branch 1142: 1
Branch 1143: 1
Branch 1144: 1
Branch 1145: 1
Branch 1146: 1
Branch 1147: 1
Branch 1148: 1
Branch 1149: 1
Branch 1150: 1
Branch 1151: 1
Branch 1152: 1
Branch 1153: 1
Branch 1154: 1
Branch 1155: 1
Branch 1156: 1
Branch 1157: 1
Branch 1158: 1
Branch 1159: 1
Branch 1160: 1
Branch 1161: 1
Branch 1162: 1
Branch 1163: 1
Branch 1164: 1
Branch 1165: 1
Branch 1166: 1
Branch 1167: 1
Branch 1168: 1
Branch 1169: 1
Branch 1170: 1
Branch 1171: 1
Branch 1172: 1
Branch 1173: 1
Branch 1174: 1
Branch 1175: 1
Branch 1176: 1
Branch 1177: 1
Branch 1178: 1
Branch 1179: 1
Branch 1180: 1
Branch 1181: 1
Branch 1182: 1
Branch 1183: 1
Branch 1184: 1
Branch 1185: 1
Branch 1186: 1
Branch 1187: 1
Branch 1188: 1
Branch 1189: 1
Branch 1190: 1
Branch 1191: 1
Branch 1192: 1
Branch 1193: 1
Branch 1194: 1
Branch 1195: 1
Branch 1196: 1
Branch 1197: 1
Branch 1198: 1
Branch 1199: 1
Branch 1200: 1
Branch 1201: 1
Branch 1202: 1
Branch 1203: 1
Branch 1204: 1
Branch 1205: 1
Branch 1206: 1
Branch 1207: 1
Branch 1208: 1
Branch 1209: 1
Branch 1210: 1
Branch 1211: 1
Branch 1212: 1
Branch 1213: 1
Branch 1214: 1
Branch 1215: 1
Branch 1216: 1
Branch 1217: 1
Branch 1218: 1
Branch 1219: 1
Branch 1220: 1
Branch 1221: 1
Branch 1222: 1
Branch 1223: 1
Branch 1224: 1
Branch 1225: 1
Branch 1226: 1
Branch 1227: 1
Branch 1228: 1
Branch 1229: 1
Branch 1230: 1
Branch 1231: 1
Branch 1232: 1
Branch 1233: 1
Branch 1234: 1
Branch 1235: 1
Branch 1236: 1
Branch 1237: 1
Branch 1238: 1
Branch 1239: 1
Branch 1240: 1
Branch 1241: 1
Branch 1242: 1
Branch 1243: 1
Branch 1244: 1
Branch 1245: 1
Branch 1246: 1
Branch 1247: 1
Branch 1248: 1
Branch 1249: 1
Branch 1250: 1
Branch 1251: 1
Branch 1252: 1
Branch 1253: 1
Branch 1254: 1
Branch 1255: 1
Branch 1256: 1
Branch 1257: 1
Branch 1258: 1
Branch 1259: 1
Branch 1260: 1
Branch 1261: 1
Branch 1262: 1
Branch 1263: 1
Branch 1264: 1
Branch 1265: 1
Branch 1266: 1
Branch 1267: 1
Branch 1268: 1
Branch 1269: 1
Branch 1270: 1
Branch 1271: 1
Branch 1272: 1
Branch 1273: 1
Branch 1274: 1
Branch 1275: 1
Branch 1276: 1
Branch 1277: 1
Branch 1278: 1
Branch 1279: 1
Branch 1280: 1
Branch 1281: 1
Branch 1282: 1
Branch 1283: 1
Branch 1284: 1
Branch 1285: 1
Branch 1286: 1
Branch 1287: 1
Branch 1288: 1
Branch 1289: 1
Branch 1290: 1
Branch 1291: 1
Branch 1292: 1
Branch 1293: 1
Branch 1294: 1
Branch 1295: 1
Branch 1296: 1
Branch 1297: 1
Branch 1298: 1
Branch 1299: 1
Branch 1300: 1
Branch 1301: 1
Branch 1302: 1
Branch 1303: 1
Branch 1304: 1
Branch 1305: 1
Branch 1306: 1
Branch 1307: 1
Branch 1308: 1
Branch 1309: 1
Branch 1310: 1
Branch 1311: 1
Branch 1312: 1
Branch 1313: 1
Branch 1314: 1
Branch 1315: 1
Branch 1316: 1
Branch 1317: 1
Branch 1318: 1
Branch 1319: 1
Branch 1320: 1
Branch 1321: 1
Branch 1322: 1
Branch 1323: 1
Branch 1324: 1
Branch 1325: 1
Branch 1326: 1
Branch 1327: 1
Branch 1328: 1
Branch 1329: 1
Branch 1330: 1
Branch 1331: 1
Branch 1332: 1
Branch 1333: 1
Branch 1334: 1
Branch 1335: 1
Branch 1336: 1
Branch 1337: 1
Branch 1338: 1
Branch 1339: 1
Branch 1340: 1
Branch 1341: 1
Branch 1342: 1
Branch 1343: 1
Branch 1344: 1
Branch 1345: 1
Branch 1346: 1
Branch 1347: 1
Branch 1348: 1
Branch 1349: 1
Branch 1350: 1
Branch 1351: 1
Branch 1352: 1
Branch 1353: 1
Branch 1354: 1
Branch 1355: 1
Branch 1356: 1
Branch 1357: 1
Branch 1358: 1
Branch 1359: 1
Branch 1360: 1
Branch 1361: 1
Branch 1362: 1
Branch 1363: 1
Branch 1364: 1
Branch 1365: 1
Branch 1366: 1
Branch 1367: 1
Branch 1368: 1
Branch 1369: 1
Branch 1370: 1
Branch 1371: 1
Branch 1372: 1
Branch 1373: 1
Branch 1374: 1
Branch 1375: 1
Branch 1376: 1
Branch 1377: 1
Branch 1378: 1
Branch 1379: 1
Branch 1380: 1
Branch 1381: 1
Branch 1382: 1
Branch 1383: 1
Branch 1384: 1
Branch 1385: 1
Branch 1386: 1
Branch 1387: 1
Branch 1388: 1
Branch 1389: 1
Branch 1390: 1
Branch 1391: 1
Branch 1392: 1
Branch 1393: 1
Branch 1394: 1
Branch 1395: 1
Branch 1396: 1
Branch 1397: 1
Branch 1398: 1
Branch 1399: 1
Branch 1400: 1
Branch 1401: 1
Branch 1402: 1
Branch 1403: 1
Branch 1404: 1
Branch 1405: 1
Branch 1406: 1
Branch 1407: 1
Branch 1408: 1
Branch 1409: 1
Branch 1410: 1
Branch 1411: 1
Branch 1412: 1
Branch 1413: 1
Branch 1414: 1
Branch 1415: 1
Branch 1416: 1
Branch 1417: 1
Branch 1418: 1
Branch 1419: 1
Branch 1420: 1
Branch 1421: 1
Branch 1422: 1
Branch 1423: 1
Branch 1424: 1
Branch 1425: 1
Branch 1426: 1
Branch 1427: 1
Branch 1428: 1
Branch 1429: 1
Branch 1430: 1
Branch 1431: 1
Branch 1432: 1
Branch 1433: 1
Branch 1434: 1
Branch 1435: 1
Branch 1436: 1
Branch 1437: 1
Branch 1438: 1
Branch 1439: 1
Branch 1440: 1
Branch 1441: 1
Branch 1442: 1
Branch 1443: 1
Branch 1444: 1
Branch 1445: 1
Branch 1446: 1
Branch 1447: 1
Branch 1448: 1
Branch 1449: 1
Branch 1450: 1
Branch 1451: 1
Branch 1452: 1
Branch 1453: 1
Branch 1454: 1
Branch 1455: 1
Branch 1456: 1
Branch 1457: 1
Branch 1458: 1
Branch 1459: 1
Branch 1460: 1
Branch 1461: 1
Branch 1462: 1
Branch 1463: 1
Branch 1464: 1
Branch 1465: 1
Branch 1466: 1
Branch 1467: 1
Branch 1468: 1
Branch 1469: 1
Branch 1470: 1
Branch 1471: 1
Branch 1472: 1
Branch 1473: 1
Branch 1474: 1
Branch 1475: 1
Branch 1476: 1
Branch 1477: 1
Branch 1478: 1
Branch 1479: 1
Branch 1480: 1
Branch 1481: 1
Branch 1482: 1
Branch 1483: 1
Branch 1484: 1
Branch 1485: 1
Branch 1486: 1
Branch 1487: 1
Branch 1488: 1
Branch 1489: 1
Branch 1490: 1
Branch 1491: 1
Branch 1492: 1
Branch 1493: 1
Branch 1494: 1
Branch 1495: 1
Branch 1496: 1
Branch 1497: 1
Branch 1498: 1
Branch 1499: 1
Branch 1500: 1
Branch 1501: 1
Branch 1502: 1
Branch 1503: 1
Branch 1504: 1
Branch 1505: 1
Branch 1506: 1
Branch 1507: 1
Branch 1508: 1
Branch 1509: 1
Branch 1510: 1
Branch 1511: 1
Branch 1512: 1
Branch 1513: 1
Branch 1514: 1
Branch 1515: 1
Branch 1516: 1
Branch 1517: 1
Branch 1518: 1
Branch 1519: 1
Branch 1520: 1
Branch 1521: 1
Branch 1522: 1
Branch 1523: 1
Branch 1524: 1
Branch 1525: 1
Branch 1526: 1
Branch 1527: 1
Branch 1528: 1
Branch 1529: 1
Branch 1530: 1
Branch 1531: 1
Branch 1532: 1
Branch 1533: 1
Branch 1534: 1
Branch 1535: 1
Branch 1536: 1
Branch 1537: 1
Branch 1538: 1
Branch 1539: 1
Branch 1540: 1
Branch 1541: 1
Branch 1542: 1
Branch 1543: 1
Branch 1544: 1
Branch 1545: 1
Branch 1546: 1
Branch 1547: 1
Branch 1548: 1
Branch 1549: 1
Branch 1550: 1
Branch 1551: 1
Branch 1552: 1
Branch 1553: 1
Branch 1554: 1
Branch 1555: 1
Branch 1556: 1
Branch 1557: 1
Branch 1558: 1
Branch 1559: 1
Branch 1560: 1
Branch 1561: 1
Branch 1562: 1
Branch 1563: 1
Branch 1564: 1
Branch 1565: 1
Branch 1566: 1
Branch 1567: 1
Branch 1568: 1
Branch 1569: 1
Branch 1570: 1
Branch 1571: 1
Branch 1572: 1
Branch 1573: 1
Branch 1574: 1
Branch 1575: 1
Branch 1576: 1
Branch 1577: 1
Branch 1578: 1
Branch 1579: 1
Branch 1580: 1
Branch 1581: 1
Branch 1582: 1
Branch 1583: 1
Branch 1584: 1
Branch 1585: 1
Branch 1586: 1
Branch 1587: 1
Branch 1588: 1
Branch 1589: 1
Branch 1590: 1
Branch 1591: 1
Branch 1592: 1
Branch 1593: 1
Branch 1594: 1
Branch 1595: 1
Branch 1596: 1
Branch 1597: 1
Branch 1598: 1
Branch 1599: 1
Branch 1600: 1
Branch 1601: 1
Branch 1602: 1
Branch 1603: 1
Branch 1604: 1
Branch 1605: 1
Branch 1606: 1
Branch 1607: 1
Branch 1608: 1
Branch 1609: 1
Branch 1610: 1
Branch 1611: 1
Branch 1612: 1
Branch 1613: 1
Branch 1614: 1
Branch 1615: 1
Branch 1616: 1
Branch 1617: 1
Branch 1618: 1
Branch 1619: 1
Branch 1620: 1
Branch 1621: 1
Branch 1622: 1
Branch 1623: 1
Branch 1624: 1
Branch 1625: 1
Branch 1626: 1
Branch 1627: 1
Branch 1628: 1
Branch 1629: 1
Branch 1630: 1
Branch 1631: 1
Branch 1632: 1
Branch 1633: 1
Branch 1634: 1
Branch 1635: 1
Branch 1636: 1
Branch 1637: 1
Branch 1638: 1
Branch 1639: 1
Branch 1640: 1
Branch 1641: 1
Branch 1642: 1
Branch 1643: 1
Branch 1644: 1
Branch 1645: 1
Branch 1646: 1
Branch 1647: 1
Branch 1648: 1
Branch 1649: 1
Branch 1650: 1
Branch 1651: 1
Branch 1652: 1
Branch 1653: 1
Branch 1654: 1
Branch 1655: 1
Branch 1656: 1
Branch 1657: 1
Branch 1658: 1
Branch 1659: 1
Branch 1660: 1
Branch 1661: 1
Branch 1662: 1
Branch 1663: 1
Branch 1664: 1
Branch 1665: 1
Branch 1666: 1
Branch 1667: 1
Branch 1668: 1
Branch 1669: 1
Branch 1670: 1
Branch 1671: 1
Branch 1672: 1
Branch 1673: 1
Branch 1674: 1
Branch 1675: 1
Branch 1676: 1
Branch 1677: 1
Branch 1678: 1
Branch 1679: 1
Branch 1680: 1
Branch 1681: 1
Branch 1682: 1
Branch 1683: 1
Branch 1684: 1
Branch 1685: 1
Branch 1686: 1
Branch 1687: 1
Branch 1688: 1
Branch 1689: 1
Branch 1690: 1
Branch 1691: 1
Branch 1692: 1
Branch 1693: 1
Branch 1694: 1
Branch 1695: 1
Branch 1696: 1
Branch 1697: 1
Branch 1698: 1
Branch 1699: 1
Branch 1700: 1
Branch 1701: 1
Branch 1702: 1
Branch 1703: 1
Branch 1704: 1
Branch 1705: 1
Branch 1706: 1
Branch 1707: 1
Branch 1708: 1
Branch 1709: 1
Branch 1710: 1
Branch 1711: 1
Branch 1712: 1
Branch 1713: 1
Branch 1714: 1
Branch 1715: 1
Branch 1716: 1
Branch 1717: 1
Branch 1718: 1
Branch 1719: 1
Branch 1720: 1
Branch 1721: 1
Branch 1722: 1
Branch 1723: 1
Branch 1724: 1
Branch 1725: 1
Branch 1726: 1
Branch 1727: 1
Branch 1728: 1
Branch 1729: 1
Branch 1730: 1
Branch 1731: 1
Branch 1732: 1
Branch 1733: 1
Branch 1734: 1
Branch 1735: 1
Branch 1736: 1
Branch 1737: 1
Branch 1738: 1
Branch 1739: 1
Branch 1740: 1
Branch 1741: 1
Branch 1742: 1
Branch 1743: 1
Branch 1744: 1
Branch 1745: 1
Branch 1746: 1
Branch 1747: 1
Branch 1748: 1
Branch 1749: 1
Branch 1750: 1
Branch 1751: 1
Branch 1752: 1
Branch 1753: 1
Branch 1754: 1
Branch 1755: 1
Branch 1756: 1
Branch 1757: 1
Branch 1758: 1
Branch 1759: 1
Branch 1760: 1
Branch 1761: 1
Branch 1762: 1
Branch 1763: 1
Branch 1764: 1
Branch 1765: 1
Branch 1766: 1
Branch 1767: 1
Branch 1768: 1
Branch 1769: 1
Branch 1770: 1
Branch 1771: 1
Branch 1772: 1
Branch 1773: 1
Branch 1774: 1
Branch 1775: 1
Branch 1776: 1
Branch 1777: 1
Branch 1778: 1
Branch 1779: 1
Branch 1780: 1
Branch 1781: 1
Branch 1782: 1
Branch 1783: 1
Branch 1784: 1
Branch 1785: 1
Branch 1786: 1
Branch 1787: 1
Branch 1788: 1
Branch 1789: 1
Branch 1790: 1
Branch 1791: 1
Branch 1792: 1
Branch 1793: 1
Branch 1794: 1
Branch 1795: 1
Branch 1796: 1
Branch 1797: 1
Branch 1798: 1
Branch 1799: 1
Branch 1800: 1
Branch 1801: 1
Branch 1802: 1
Branch 1803: 1
Branch 1804: 1
Branch 1805: 1
Branch 1806: 1
Branch 1807: 1
Branch 1808: 1
Branch 1809: 1
Branch 1810: 1
Branch 1811: 1
Branch 1812: 1
Branch 1813: 1
Branch 1814: 1
Branch 1815: 1
Branch 1816: 1
Branch 1817: 1
Branch 1818: 1
Branch 1819: 1
Branch 1820: 1
Branch 1821: 1
Branch 1822: 1
Branch 1823: 1
Branch 1824: 1
Branch 1825: 1
Branch 1826: 1
Branch 1827: 1
Branch 1828: 1
Branch 1829: 1
Branch 1830: 1
Branch 1831: 1
Branch 1832: 1
Branch 1833: 1
Branch 1834: 1
Branch 1835: 1
Branch 1836: 1
Branch 1837: 1
Branch 1838: 1
Branch 1839: 1
Branch 1840: 1
Branch 1841: 1
Branch 1842: 1
Branch 1843: 1
Branch 1844: 1
Branch 1845: 1
Branch 1846: 1
Branch 1847: 1
Branch 1848: 1
Branch 1849: 1
Branch 1850: 1
Branch 1851: 1
Branch 1852: 1
Branch 1853: 1
Branch 1854: 1
Branch 1855: 1
Branch 1856: 1
Branch 1857: 1
Branch 1858: 1
Branch 1859: 1
Branch 1860: 1
Branch 1861: 1
Branch 1862: 1
Branch 1863: 1
Branch 1864: 1
Branch 1865: 1
Branch 1866: 1
Branch 1867: 1
Branch 1868: 1
Branch 1869: 1
Branch 1870: 1
Branch 1871: 1
Branch 1872: 1
Branch 1873: 1
Branch 1874: 1
Branch 1875: 1
Branch 1876: 1
Branch 1877: 1
Branch 1878: 1
Branch 1879: 1
Branch 1880: 1
Branch 1881: 1
Branch 1882: 1
Branch 1883: 1
Branch 1884: 1
Branch 1885: 1
Branch 1886: 1
Branch 1887: 1
Branch 1888: 1
Branch 1889: 1
Branch 1890: 1
Branch 1891: 1
Branch 1892: 1
Branch 1893: 1
Branch 1894: 1
Branch 1895: 1
Branch 1896: 1
Branch 1897: 1
Branch 1898: 1
Branch 1899: 1
Branch 1900: 1
Branch 1901: 1
Branch 1902: 1
Branch 1903: 1
Branch 1904: 1
Branch 1905: 1
Branch 1906: 1
Branch 1907: 1
Branch 1908: 1
Branch 1909: 1
Branch 1910: 1
Branch 1911: 1
Branch 1912: 1
Branch 1913: 1
Branch 1914: 1
Branch 1915: 1
Branch 1916: 1
Branch 1917: 1
Branch 1918: 1
Branch 1919: 1
Branch 1920: 1
Branch 1921: 1
Branch 1922: 1
Branch 1923: 1
Branch 1924: 1
Branch 1925: 1
Branch 1926: 1
Branch 1927: 1
Branch 1928: 1
Branch 1929: 1
Branch 1930: 1
Branch 1931: 1
Branch 1932: 1
Branch 1933: 1
Branch 1934: 1
Branch 1935: 1
Branch 1936: 1
Branch 1937: 1
Branch 1938: 1
Branch 1939: 1
Branch 1940: 1
Branch 1941: 1
Branch 1942: 1
Branch 1943: 1
Branch 1944: 1
Branch 1945: 1
Branch 1946: 1
Branch 1947: 1
Branch 1948: 1
Branch 1949: 1
Branch 1950: 1
Branch 1951: 1
Branch 1952: 1
Branch 1953: 1
Branch 1954: 1
Branch 1955: 1
Branch 1956: 1
Branch 1957: 1
Branch 1958: 1
Branch 1959: 1
Branch 1960: 1
Branch 1961: 1
Branch 1962: 1
Branch 1963: 1
Branch 1964: 1
Branch 1965: 1
Branch 1966: 1
Branch 1967: 1
Branch 1968: 1
Branch 1969: 1
Branch 1970: 1
Branch 1971: 1
Branch 1972: 1
Branch 1973: 1
Branch 1974: 1
Branch 1975: 1
Branch 1976: 1
Branch 1977: 1
Branch 1978: 1
Branch 1979: 1
Branch 1980: 1
Branch 1981: 1
Branch 1982: 1
Branch 1983: 1
Branch 1984: 1
Branch 1985: 1
Branch 1986: 1
Branch 1987: 1
Branch 1988: 1
Branch 1989: 1
Branch 1990: 1
Branch 1991: 1
Branch 1992: 1
Branch 1993: 1
Branch 1994: 1
Branch 1995: 1
Branch 1996: 1
Branch 1997: 1
Branch 1998: 1
Branch 1999: 1
Branch 2000: 1
Branch 2001: 1
Branch 2002: 1
Branch 2003: 1
Branch 2004: 1
Branch 2005: 1
Branch 2006: 1
Branch 2007: 1
Branch 2008: 1
Branch 2009: 1
Branch 2010: 1
Branch 2011: 1
Branch 2012: 1
Branch 2013: 1
Branch 2014: 1
Branch 2015: 1
Branch 2016: 1
Branch 2017: 1
Branch 2018: 1
Branch 2019: 1
Branch 2020: 1
Branch 2021: 1
Branch 2022: 1
Branch 2023: 1
Branch 2024: 1
Branch 2025: 1
Branch 2026: 1
Branch 2027: 1
Branch 2028: 1
Branch 2029: 1
Branch 2030: 1
Branch 2031: 1
Branch 2032: 1
Branch 2033: 1
Branch 2034: 1
Branch 2035: 1
Branch 2036: 1
Branch 2037: 1
Branch 2038: 1
Branch 2039: 1
Branch 2040: 1
Branch 2041: 1
Branch 2042: 1
Branch 2043: 1
Branch 2044: 1
Branch 2045: 1
Branch 2046: 1
Branch 2047: 1
Branch 2048: 1
Branch 2049: 1
Branch 2050: 1
Branch 2051: 1
Branch 2052: 1
Branch 2053: 1
Branch 2054: 1
Branch 2055: 1
Branch 2056: 1
Branch 2057: 1
Branch 2058: 1
Branch 2059: 1
Branch 2060: 1
Branch 2061: 1
Branch 2062: 1
Branch 2063: 1
Branch 2064: 1
Branch 2065: 1
Branch 2066: 1
Branch 2067: 1
Branch 2068: 1
Branch 2069: 1
Branch 2070: 1
Branch 2071: 1
Branch 2072: 1
Branch 2073: 1
Branch 2074: 1
Branch 2075: 1
Branch 2076: 1
Branch 2077: 1
Branch 2078: 1
Branch 2079: 1
Branch 2080: 1
Branch 2081: 1
Branch 2082: 1
Branch 2083: 1
Branch 2084: 1
Branch 2085: 1
Branch 2086: 1
Branch 2087: 1
Branch 2088: 1
Branch 2089: 1
Branch 2090: 1
Branch 2091: 1
Branch 2092: 1
Branch 2093: 1
Branch 2094: 1
Branch 2095: 1
Branch 2096: 1
Branch 2097: 1
Branch 2098: 1
Branch 2099: 1
Branch 2100: 1
Branch 2101: 1
Branch 2102: 1
Branch 2103: 1
Branch 2104: 1
Branch 2105: 1
Branch 2106: 1
Branch 2107: 1
Branch 2108: 1
Branch 2109: 1
Branch 2110: 1
Branch 2111: 1
Branch 2112: 1
Branch 2113: 1
Branch 2114: 1
Branch 2115: 1
Branch 2116: 1
Branch 2117: 1
Branch 2118: 1
Branch 2119: 1
Branch 2120: 1
Branch 2121: 1
Branch 2122: 1
Branch 2123: 1
Branch 2124: 1
Branch 2125: 1
Branch 2126: 1
Branch 2127: 1
Branch 2128: 1
Branch 2129: 1
Branch 2130: 1
Branch 2131: 1
Branch 2132: 1
Branch 2133: 1
Branch 2134: 1
Branch 2135: 1
Branch 2136: 1
Branch 2137: 1
Branch 2138: 1
Branch 2139: 1
Branch 2140: 1
Branch 2141: 1
Branch 2142: 1
Branch 2143: 1
Branch 2144: 1
Branch 2145: 1
Branch 2146: 1
Branch 2147: 1
Branch 2148: 1
Branch 2149: 1
Branch 2150: 1
Branch 2151: 1
Branch 2152: 1
Branch 2153: 1
Branch 2154: 1
Branch 2155: 1
Branch 2156: 1
Branch 2157: 1
Branch 2158: 1
Branch 2159: 1
Branch 2160: 1
Branch 2161: 1
Branch 2162: 1
Branch 2163: 1
Branch 2164: 1
Branch 2165: 1
Branch 2166: 1
Branch 2167: 1
Branch 2168: 1
Branch 2169: 1
Branch 2170: 1
Branch 2171: 1
Branch 2172: 1
Branch 2173: 1
Branch 2174: 1
Branch 2175: 1
Branch 2176: 1
Branch 2177: 1
Branch 2178: 1
Branch 2179: 1
Branch 2180: 1
Branch 2181: 1
Branch 2182: 1
Branch 2183: 1
Branch 2184: 1
Branch 2185: 1
Branch 2186: 1
Branch 2187: 1
Branch 2188: 1
Branch 2189: 1
Branch 2190: 1
Branch 2191: 1
Branch 2192: 1
Branch 2193: 1
Branch 2194: 1
Branch 2195: 1
Branch 2196: 1
Branch 2197: 1
Branch 2198: 1
Branch 2199: 1
Branch 2200: 1
Branch 2201: 1
Branch 2202: 1
Branch 2203: 1
Branch 2204: 1
Branch 2205: 1
Branch 2206: 1
Branch 2207: 1
Branch 2208: 1
Branch 2209: 1
Branch 2210: 1
Branch 2211: 1
Branch 2212: 1
Branch 2213: 1
Branch 2214: 1
Branch 2215: 1
Branch 2216: 1
Branch 2217: 1
Branch 2218: 1
Branch 2219: 1
Branch 2220: 1
Branch 2221: 1
Branch 2222: 1
Branch 2223: 1
Branch 2224: 1
Branch 2225: 1
Branch 2226: 1
Branch 2227: 1
Branch 2228: 1
Branch 2229: 1
Branch 2230: 1
Branch 2231: 1
Branch 2232: 1
Branch 2233: 1
Branch 2234: 1
Branch 2235: 1
Branch 2236: 1
Branch 2237: 1
Branch 2238: 1
Branch 2239: 1
Branch 2240: 1
Branch 2241: 1
Branch 2242: 1
Branch 2243: 1
Branch 2244: 1
Branch 2245: 1
Branch 2246: 1
Branch 2247: 1
Branch 2248: 1
Branch 2249: 1
Branch 2250: 1
Branch 2251: 1
Branch 2252: 1
Branch 2253: 1
Branch 2254: 1
Branch 2255: 1
Branch 2256: 1
Branch 2257: 1
Branch 2258: 1
Branch 2259: 1
Branch 2260: 1
Branch 2261: 1
Branch 2262: 1
Branch 2263: 1
Branch 2264: 1
Branch 2265: 1
Branch 2266: 1
Branch 2267: 1
Branch 2268: 1
Branch 2269: 1
Branch 2270: 1
Branch 2271: 1
Branch 2272: 1
Branch 2273: 1
Branch 2274: 1
Branch 2275: 1
Branch 2276: 1
Branch 2277: 1
Branch 2278: 1
Branch 2279: 1
Branch 2280: 1
Branch 2281: 1
Branch 2282: 1
Branch 2283: 1
Branch 2284: 1
Branch 2285: 1
Branch 2286: 1
Branch 2287: 1
Branch 2288: 1
Branch 2289: 1
Branch 2290: 1
Branch 2291: 1
Branch 2292: 1
Branch 2293: 1
Branch 2294: 1
Branch 2295: 1
Branch 2296: 1
Branch 2297: 1
Branch 2298: 1
Branch 2299: 1
Branch 2300: 1
Branch 2301: 1
Branch 2302: 1
Branch 2303: 1
Branch 2304: 1
Branch 2305: 1
Branch 2306: 1
Branch 2307: 1
Branch 2308: 1
Branch 2309: 1
Branch 2310: 1
Branch 2311: 1
Branch 2312: 1
Branch 2313: 1
Branch 2314: 1
Branch 2315: 1
Branch 2316: 1
Branch 2317: 1
Branch 2318: 1
Branch 2319: 1
Branch 2320: 1
Branch 2321: 1
Branch 2322: 1
Branch 2323: 1
Branch 2324: 1
Branch 2325: 1
Branch 2326: 1
Branch 2327: 1
Branch 2328: 1
Branch 2329: 1
Branch 2330: 1
Branch 2331: 1
Branch 2332: 1
Branch 2333: 1
Branch 2334: 1
Branch 2335: 1
Branch 2336: 1
Branch 2337: 1
Branch 2338: 1
Branch 2339: 1
Branch 2340: 1
Branch 2341: 1
Branch 2342: 1
Branch 2343: 1
Branch 2344: 1
Branch 2345: 1
Branch 2346: 1
Branch 2347: 1
Branch 2348: 1
Branch 2349: 1
Branch 2350: 1
Branch 2351: 1
Branch 2352: 1
Branch 2353: 1
Branch 2354: 1
Branch 2355: 1
Branch 2356: 1
Branch 2357: 1
Branch 2358: 1
Branch 2359: 1
Branch 2360: 1
Branch 2361: 1
Branch 2362: 1
Branch 2363: 1
Branch 2364: 1
Branch 2365: 1
Branch 2366: 1
Branch 2367: 1
Branch 2368: 1
Branch 2369: 1
Branch 2370: 1
Branch 2371: 1
Branch 2372: 1
Branch 2373: 1
Branch 2374: 1
Branch 2375: 1
Branch 2376: 1
Branch 2377: 1
Branch 2378: 1
Branch 2379: 1
Branch 2380: 1
Branch 2381: 1
Branch 2382: 1
Branch 2383: 1
Branch 2384: 1
Branch 2385: 1
Branch 2386: 1
Branch 2387: 1
Branch 2388: 1
Branch 2389: 1
Branch 2390: 1
Branch 2391: 1
Branch 2392: 1
Branch 2393: 1
Branch 2394: 1
Branch 2395: 1
Branch 2396: 1
Branch 2397: 1
Branch 2398: 1
Branch 2399: 1
Branch 2400: 1
Branch 2401: 1
Branch 2402: 1
Branch 2403: 1
Branch 2404: 1
Branch 2405: 1
Branch 2406: 1
Branch 2407: 1
Branch 2408: 1
Branch 2409: 1
Branch 2410: 1
Branch 2411: 1
Branch 2412: 1
Branch 2413: 1
Branch 2414: 1
Branch 2415: 1
Branch 2416: 1
Branch 2417: 1
Branch 2418: 1
Branch 2419: 1
Branch 2420: 1
Branch 2421: 1
Branch 2422: 1
Branch 2423: 1
Branch 2424: 1
Branch 2425: 1
Branch 2426: 1
Branch 2427: 1
Branch 2428: 1
Branch 2429: 1
Branch 2430: 1
Branch 2431: 1
Branch 2432: 1
Branch 2433: 1
Branch 2434: 1
Branch 2435: 1
Branch 2436: 1
Branch 2437: 1
Branch 2438: 1
Branch 2439: 1
Branch 2440: 1
Branch 2441: 1
Branch 2442: 1
Branch 2443: 1
Branch 2444: 1
Branch 2445: 1
Branch 2446: 1
Branch 2447: 1
Branch 2448: 1
Branch 2449: 1
Branch 2450: 1
Branch 2451: 1
Branch 2452: 1
Branch 2453: 1
Branch 2454: 1
Branch 2455: 1
Branch 2456: 1
Branch 2457: 1
Branch 2458: 1
Branch 2459: 1
Branch 2460: 1
Branch 2461: 1
Branch 2462: 1
Branch 2463: 1
Branch 2464: 1
Branch 2465: 1
Branch 2466: 1
Branch 2467: 1
Branch 2468: 1
Branch 2469: 1
Branch 2470: 1
Branch 2471: 1
Branch 2472: 1
Branch 2473: 1
Branch 2474: 1
Branch 2475: 1
Branch 2476: 1
Branch 2477: 1
Branch 2478: 1
Branch 2479: 1
Branch 2480: 1
Branch 2481: 1
Branch 2482: 1
Branch 2483: 1
Branch 2484: 1
Branch 2485: 1
Branch 2486: 1
Branch 2487: 1
Branch 2488: 1
Branch 2489: 1
Branch 2490: 1
Branch 2491: 1
Branch 2492: 1
Branch 2493: 1
Branch 2494: 1
Branch 2495: 1
Branch 2496: 1
Branch 2497: 1
Branch 2498: 1
Branch 2499: 1
Branch 2500: 1
Branch 2501: 1
Branch 2502: 1
Branch 2503: 1
Branch 2504: 1
Branch 2505: 1
Branch 2506: 1
Branch 2507: 1
Branch 2508: 1
Branch 2509: 1
Branch 2510: 1
Branch 2511: 1
Branch 2512: 1
Branch 2513: 1
Branch 2514: 1
Branch 2515: 1
Branch 2516: 1
Branch 2517: 1
Branch 2518: 1
Branch 2519: 1
Branch 2520: 1
Branch 2521: 1
Branch 2522: 1
Branch 2523: 1
Branch 2524: 1
Branch 2525: 1
Branch 2526: 1
Branch 2527: 1
Branch 2528: 1
Branch 2529: 1
Branch 2530: 1
Branch 2531: 1
Branch 2532: 1
Branch 2533: 1
Branch 2534: 1
Branch 2535: 1
Branch 2536: 1
Branch 2537: 1
Branch 2538: 1
Branch 2539: 1
Branch 2540: 1
Branch 2541: 1
Branch 2542: 1
Branch 2543: 1
Branch 2544: 1
Branch 2545: 1
Branch 2546: 1
Branch 2547: 1
Branch 2548: 1
Branch 2549: 1
Branch 2550: 1
Branch 2551: 1
Branch 2552: 1
Branch 2553: 1
Branch 2554: 1
Branch 2555: 1
Branch 2556: 1
Branch 2557: 1
Branch 2558: 1
Branch 2559: 1
Branch 2560: 1
Branch 2561: 1
Branch 2562: 1
Branch 2563: 1
Branch 2564: 1
Branch 2565: 1
Branch 2566: 1
Branch 2567: 1
Branch 2568: 1
Branch 2569: 1
Branch 2570: 1
Branch 2571: 1
Branch 2572: 1
Branch 2573: 1
Branch 2574: 1
Branch 2575: 1
Branch 2576: 1
Branch 2577: 1
Branch 2578: 1
Branch 2579: 1
Branch 2580: 1
Branch 2581: 1
Branch 2582: 1
Branch 2583: 1
Branch 2584: 1
Branch 2585: 1
Branch 2586: 1
Branch 2587: 1
Branch 2588: 1
Branch 2589: 1
Branch 2590: 1
Branch 2591: 1
Branch 2592: 1
Branch 2593: 1
Branch 2594: 1
Branch 2595: 1
Branch 2596: 1
Branch 2597: 1
Branch 2598: 1
Branch 2599: 1
Branch 2600: 1
Branch 2601: 1
Branch 2602: 1
Branch 2603: 1
Branch 2604: 1
Branch 2605: 1
Branch 2606: 1
Branch 2607: 1
Branch 2608: 1
Branch 2609: 1
Branch 2610: 1
Branch 2611: 1
Branch 2612: 1
Branch 2613: 1
Branch 2614: 1
Branch 2615: 1
Branch 2616: 1
Branch 2617: 1
Branch 2618: 1
Branch 2619: 1
Branch 2620: 1
Branch 2621: 1
Branch 2622: 1
Branch 2623: 1
Branch 2624: 1
Branch 2625: 1
Branch 2626: 1
Branch 2627: 1
Branch 2628: 1
Branch 2629: 1
Branch 2630: 1
Branch 2631: 1
Branch 2632: 1
Branch 2633: 1
Branch 2634: 1
Branch 2635: 1
Branch 2636: 1
Branch 2637: 1
Branch 2638: 1
Branch 2639: 1
Branch 2640: 1
Branch 2641: 1
Branch 2642: 1
Branch 2643: 1
Branch 2644: 1
Branch 2645: 1
Branch 2646: 1
Branch 2647: 1
Branch 2648: 1
Branch 2649: 1
Branch 2650: 1
Branch 2651: 1
Branch 2652: 1
Branch 2653: 1
Branch 2654: 1
Branch 2655: 1
Branch 2656: 1
Branch 2657: 1
Branch 2658: 1
Branch 2659: 1
Branch 2660: 1
Branch 2661: 1
Branch 2662: 1
Branch 2663: 1
Branch 2664: 1
Branch 2665: 1
Branch 2666: 1
Branch 2667: 1
Branch 2668: 1
Branch 2669: 1
Branch 2670: 1
Branch 2671: 1
Branch 2672: 1
Branch 2673: 1
Branch 2674: 1
Branch 2675: 1
Branch 2676: 1
Branch 2677: 1
Branch 2678: 1
Branch 2679: 1
Branch 2680: 1
Branch 2681: 1
Branch 2682: 1
Branch 2683: 1
Branch 2684: 1
Branch 2685: 1
Branch 2686: 1
Branch 2687: 1
Branch 2688: 1
Branch 2689: 1
Branch 2690: 1
Branch 2691: 1
Branch 2692: 1
Branch 2693: 1
Branch 2694: 1
Branch 2695: 1
Branch 2696: 1
Branch 2697: 1
Branch 2698: 1
Branch 2699: 1
Branch 2700: 1
Branch 2701: 1
Branch 2702: 1
Branch 2703: 1
Branch 2704: 1
Branch 2705: 1
Branch 2706: 1
Branch 2707: 1
Branch 2708: 1
Branch 2709: 1
Branch 2710: 1
Branch 2711: 1
Branch 2712: 1
Branch 2713: 1
Branch 2714: 1
Branch 2715: 1
Branch 2716: 1
Branch 2717: 1
Branch 2718: 1
Branch 2719: 1
Branch 2720: 1
Branch 2721: 1
Branch 2722: 1
Branch 2723: 1
Branch 2724: 1
Branch 2725: 1
Branch 2726: 1
Branch 2727: 1
Branch 2728: 1
Branch 2729: 1
Branch 2730: 1
Branch 2731: 1
Branch 2732: 1
Branch 2733: 1
Branch 2734: 1
Branch 2735: 1
Branch 2736: 1
Branch 2737: 1
Branch 2738: 1
Branch 2739: 1
Branch 2740: 1
Branch 2741: 1
Branch 2742: 1
Branch 2743: 1
Branch 2744: 1
Branch 2745: 1
Branch 2746: 1
Branch 2747: 1
Branch 2748: 1
Branch 2749: 1
Branch 2750: 1
Branch 2751: 1
Branch 2752: 1
Branch 2753: 1
Branch 2754: 1
Branch 2755: 1
Branch 2756: 1
Branch 2757: 1
Branch 2758: 1
Branch 2759: 1
Branch 2760: 1
Branch 2761: 1
Branch 2762: 1
Branch 2763: 1
Branch 2764: 1
Branch 2765: 1
Branch 2766: 1
Branch 2767: 1
Branch 2768: 1
Branch 2769: 1
Branch 2770: 1
Branch 2771: 1
Branch 2772: 1
Branch 2773: 1
Branch 2774: 1
Branch 2775: 1
Branch 2776: 1
Branch 2777: 1
Branch 2778: 1
Branch 2779: 1
Branch 2780: 1
Branch 2781: 1
Branch 2782: 1
Branch 2783: 1
Branch 2784: 1
Branch 2785: 1
Branch 2786: 1
Branch 2787: 1
Branch 2788: 1
Branch 2789: 1
Branch 2790: 1
Branch 2791: 1
Branch 2792: 1
Branch 2793: 1
Branch 2794: 1
Branch 2795: 1
Branch 2796: 1
Branch 2797: 1
Branch 2798: 1
Branch 2799: 1
Branch 2800: 1
Branch 2801: 1
Branch 2802: 1
Branch 2803: 1
Branch 2804: 1
Branch 2805: 1
Branch 2806: 1
Branch 2807: 1
Branch 2808: 1
Branch 2809: 1
Branch 2810: 1
Branch 2811: 1
Branch 2812: 1
Branch 2813: 1
Branch 2814: 1
Branch 2815: 1
Branch 2816: 1
Branch 2817: 1
Branch 2818: 1
Branch 2819: 1
Branch 2820: 1
Branch 2821: 1
Branch 2822: 1
Branch 2823: 1
Branch 2824: 1
Branch 2825: 1
Branch 2826: 1
Branch 2827: 1
Branch 2828: 1
Branch 2829: 1
Branch 2830: 1
Branch 2831: 1
Branch 2832: 1
Branch 2833: 1
Branch 2834: 1
Branch 2835: 1
Branch 2836: 1
Branch 2837: 1
Branch 2838: 1
Branch 2839: 1
Branch 2840: 1
Branch 2841: 1
Branch 2842: 1
Branch 2843: 1
Branch 2844: 1
Branch 2845: 1
Branch 2846: 1
Branch 2847: 1
Branch 2848: 1
Branch 2849: 1
Branch 2850: 1
Branch 2851: 1
Branch 2852: 1
Branch 2853: 1
Branch 2854: 1
Branch 2855: 1
Branch 2856: 1
Branch 2857: 1
Branch 2858: 1
Branch 2859: 1
Branch 2860: 1
Branch 2861: 1
Branch 2862: 1
Branch 2863: 1
Branch 2864: 1
Branch 2865: 1
Branch 2866: 1
Branch 2867: 1
Branch 2868: 1
Branch 2869: 1
Branch 2870: 1
Branch 2871: 1
Branch 2872: 1
Branch 2873: 1
Branch 2874: 1
Branch 2875: 1
Branch 2876: 1
Branch 2877: 1
Branch 2878: 1
Branch 2879: 1
Branch 2880: 1
Branch 2881: 1
Branch 2882: 1
Branch 2883: 1
Branch 2884: 1
Branch 2885: 1
Branch 2886: 1
Branch 2887: 1
Branch 2888: 1
Branch 2889: 1
Branch 2890: 1
Branch 2891: 1
Branch 2892: 1
Branch 2893: 1
Branch 2894: 1
Branch 2895: 1
Branch 2896: 1
Branch 2897: 1
Branch 2898: 1
Branch 2899: 1
Branch 2900: 1
Branch 2901: 1
Branch 2902: 1
Branch 2903: 1
Branch 2904: 1
Branch 2905: 1
Branch 2906: 1
Branch 2907: 1
Branch 2908: 1
Branch 2909: 1
Branch 2910: 1
Branch 2911: 1
Branch 2912: 1
Branch 2913: 1
Branch 2914: 1
Branch 2915: 1
Branch 2916: 1
Branch 2917: 1
Branch 2918: 1
Branch 2919: 1
Branch 2920: 1
Branch 2921: 1
Branch 2922: 1
Branch 2923: 1
Branch 2924: 1
Branch 2925: 1
Branch 2926: 1
Branch 2927: 1
Branch 2928: 1
Branch 2929: 1
Branch 2930: 1
Branch 2931: 1
Branch 2932: 1
Branch 2933: 1
Branch 2934: 1
Branch 2935: 1
Branch 2936: 1
Branch 2937: 1
Branch 2938: 1
Branch 2939: 1
Branch 2940: 1
Branch 2941: 1
Branch 2942: 1
Branch 2943: 1
Branch 2944: 1
Branch 2945: 1
Branch 2946: 1
Branch 2947: 1
Branch 2948: 1
Branch 2949: 1
Branch 2950: 1
Branch 2951: 1
Branch 2952: 1
Branch 2953: 1
Branch 2954: 1
Branch 2955: 1
Branch 2956: 1
Branch 2957: 1
Branch 2958: 1
Branch 2959: 1
Branch 2960: 1
Branch 2961: 1
Branch 2962: 1
Branch 2963: 1
Branch 2964: 1
Branch 2965: 1
Branch 2966: 1
Branch 2967: 1
Branch 2968: 1
Branch 2969: 1
Branch 2970: 1
Branch 2971: 1
Branch 2972: 1
Branch 2973: 1
Branch 2974: 1
Branch 2975: 1
Branch 2976: 1
Branch 2977: 1
Branch 2978: 1
Branch 2979: 1
Branch 2980: 1
Branch 2981: 1
Branch 2982: 1
Branch 2983: 1
Branch 2984: 1
Branch 2985: 1
Branch 2986: 1
Branch 2987: 1
Branch 2988: 1
Branch 2989: 1
Branch 2990: 1
Branch 2991: 1
Branch 2992: 1
Branch 2993: 1
Branch 2994: 1
Branch 2995: 1
Branch 2996: 1
Branch 2997: 1
Branch 2998: 1
Branch 2999: 1
Branch 3000: 1
Branch 3001: 1
Branch 3002: 1
Branch 3003: 1
Branch 3004: 1
Branch 3005: 1
Branch 3006: 1
Branch 3007: 1
Branch 3008: 1
Branch 3009: 1
Branch 3010: 1
Branch 3011: 1
Branch 3012: 1
Branch 3013: 1
Branch 3014: 1
Branch 3015: 1
Branch 3016: 1
Branch 3017: 1
Branch 3018: 1
Branch 3019: 1
Branch 3020: 1
Branch 3021: 1
Branch 3022: 1
Branch 3023: 1
Branch 3024: 1
Branch 3025: 1
Branch 3026: 1
Branch 3027: 1
Branch 3028: 1
Branch 3029: 1
Branch 3030: 1
Branch 3031: 1
Branch 3032: 1
Branch 3033: 1
Branch 3034: 1
Branch 3035: 1
Branch 3036: 1
Branch 3037: 1
Branch 3038: 1
Branch 3039: 1
Branch 3040: 1
Branch 3041: 1
Branch 3042: 1
Branch 3043: 1
Branch 3044: 1
Branch 3045: 1
Branch 3046: 1
Branch 3047: 1
Branch 3048: 1
Branch 3049: 1
Branch 3050: 1
Branch 3051: 1
Branch 3052: 1
Branch 3053: 1
Branch 3054: 1
Branch 3055: 1
Branch 3056: 1
Branch 3057: 1
Branch 3058: 1
Branch 3059: 1
Branch 3060: 1
Branch 3061: 1
Branch 3062: 1
Branch 3063: 1
Branch 3064: 1
Branch 3065: 1
Branch 3066: 1
Branch 3067: 1
Branch 3068: 1
Branch 3069: 1
Branch 3070: 1
Branch 3071: 1
Branch 3072: 1
Branch 3073: 1
Branch 3074: 1
Branch 3075: 1
Branch 3076: 1
Branch 3077: 1
Branch 3078: 1
Branch 3079: 1
Branch 3080: 1
Branch 3081: 1
Branch 3082: 1
Branch 3083: 1
Branch 3084: 1
Branch 3085: 1
Branch 3086: 1
Branch 3087: 1
Branch 3088: 1
Branch 3089: 1
Branch 3090: 1
Branch 3091: 1
Branch 3092: 1
Branch 3093: 1
Branch 3094: 1
Branch 3095: 1
Branch 3096: 1
Branch 3097: 1
Branch 3098: 1
Branch 3099: 1
Branch 3100: 1
Branch 3101: 1
Branch 3102: 1
Branch 3103: 1
Branch 3104: 1
Branch 3105: 1
Branch 3106: 1
Branch 3107: 1
Branch 3108: 1
Branch 3109: 1
Branch 3110: 1
Branch 3111: 1
Branch 3112: 1
Branch 3113: 1
Branch 3114: 1
Branch 3115: 1
Branch 3116: 1
Branch 3117: 1
Branch 3118: 1
Branch 3119: 1
Branch 3120: 1
Branch 3121: 1
Branch 3122: 1
Branch 3123: 1
Branch 3124: 1
Branch 3125: 1
Branch 3126: 1
Branch 3127: 1
Branch 3128: 1
Branch 3129: 1
Branch 3130: 1
Branch 3131: 1
Branch 3132: 1
Branch 3133: 1
Branch 3134: 1
Branch 3135: 1
Branch 3136: 1
Branch 3137: 1
Branch 3138: 1
Branch 3139: 1
Branch 3140: 1
Branch 3141: 1
Branch 3142: 1
Branch 3143: 1
Branch 3144: 1
Branch 3145: 1
Branch 3146: 1
Branch 3147: 1
Branch 3148: 1
Branch 3149: 1
Branch 3150: 1
Branch 3151: 1
Branch 3152: 1
Branch 3153: 1
Branch 3154: 1
Branch 3155: 1
Branch 3156: 1
Branch 3157: 1
Branch 3158: 1
Branch 3159: 1
Branch 3160: 1
Branch 3161: 1
Branch 3162: 1
Branch 3163: 1
Branch 3164: 1
Branch 3165: 1
Branch 3166: 1
Branch 3167: 1
Branch 3168: 1
Branch 3169: 1
Branch 3170: 1
Branch 3171: 1
Branch 3172: 1
Branch 3173: 1
Branch 3174: 1
Branch 3175: 1
Branch 3176: 1
Branch 3177: 1
Branch 3178: 1
Branch 3179: 1
Branch 3180: 1
Branch 3181: 1
Branch 3182: 1
Branch 3183: 1
Branch 3184: 1
Branch 3185: 1
Branch 3186: 1
Branch 3187: 1
Branch 3188: 1
Branch 3189: 1
Branch 3190: 1
Branch 3191: 1
Branch 3192: 1
Branch 3193: 1
Branch 3194: 1
Branch 3195: 1
Branch 3196: 1
Branch 3197: 1
Branch 3198: 1
Branch 3199: 1
Branch 3200: 1
Branch 3201: 1
Branch 3202: 1
Branch 3203: 1
Branch 3204: 1
Branch 3205: 1
Branch 3206: 1
Branch 3207: 1
Branch 3208: 1
Branch 3209: 1
Branch 3210: 1
Branch 3211: 1
Branch 3212: 1
Branch 3213: 1
Branch 3214: 1
Branch 3215: 1
Branch 3216: 1
Branch 3217: 1
Branch 3218: 1
Branch 3219: 1
Branch 3220: 1
Branch 3221: 1
Branch 3222: 1
Branch 3223: 1
Branch 3224: 1
Branch 3225: 1
Branch 3226: 1
Branch 3227: 1
Branch 3228: 1
Branch 3229: 1
Branch 3230: 1
Branch 3231: 1
Branch 3232: 1
Branch 3233: 1
Branch 3234: 1
Branch 3235: 1
Branch 3236: 1
Branch 3237: 1
Branch 3238: 1
Branch 3239: 1
Branch 3240: 1
Branch 3241: 1
Branch 3242: 1
Branch 3243: 1
Branch 3244: 1
Branch 3245: 1
Branch 3246: 1
Branch 3247: 1
Branch 3248: 1
Branch 3249: 1
Branch 3250: 1
Branch 3251: 1
Branch 3252: 1
Branch 3253: 1
Branch 3254: 1
Branch 3255: 1
Branch 3256: 1
Branch 3257: 1
Branch 3258: 1
Branch 3259: 1
Branch 3260: 1
Branch 3261: 1
Branch 3262: 1
Branch 3263: 1
Branch 3264: 1
Branch 3265: 1
Branch 3266: 1
Branch 3267: 1
Branch 3268: 1
Branch 3269: 1
Branch 3270: 1
Branch 3271: 1
Branch 3272: 1
Branch 3273: 1
Branch 3274: 1
Branch 3275: 1
Branch 3276: 1
Branch 3277: 1
Branch 3278: 1
Branch 3279: 1
Branch 3280: 1
Branch 3281: 1
Branch 3282: 1
Branch 3283: 1
Branch 3284: 1
Branch 3285: 1
Branch 3286: 1
Branch 3287: 1
Branch 3288: 1
Branch 3289: 1
Branch 3290: 1
Branch 3291: 1
Branch 3292: 1
Branch 3293: 1
Branch 3294: 1
Branch 3295: 1
Branch 3296: 1
Branch 3297: 1
Branch 3298: 1
Branch 3299: 1
Branch 3300: 1
Branch 3301: 1
Branch 3302: 1
Branch 3303: 1
Branch 3304: 1
Branch 3305: 1
Branch 3306: 1
Branch 3307: 1
Branch 3308: 1
Branch 3309: 1
Branch 3310: 1
Branch 3311: 1
Branch 3312: 1
Branch 3313: 1
Branch 3314: 1
Branch 3315: 1
Branch 3316: 1
Branch 3317: 1
Branch 3318: 1
Branch 3319: 1
Branch 3320: 1
Branch 3321: 1
Branch 3322: 1
Branch 3323: 1
Branch 3324: 1
Branch 3325: 1
Branch 3326: 1
Branch 3327: 1
Branch 3328: 1
Branch 3329: 1
Branch 3330: 1
Branch 3331: 1
Branch 3332: 1
Branch 3333: 1
Branch 3334: 1
Branch 3335: 1
Branch 3336: 1
Branch 3337: 1
Branch 3338: 1
Branch 3339: 1
Branch 3340: 1
Branch 3341: 1
Branch 3342: 1
Branch 3343: 1
Branch 3344: 1
Branch 3345: 1
Branch 3346: 1
Branch 3347: 1
Branch 3348: 1
Branch 3349: 1
Branch 3350: 1
Branch 3351: 1
Branch 3352: 1
Branch 3353: 1
Branch 3354: 1
Branch 3355: 1
Branch 3356: 1
Branch 3357: 1
Branch 3358: 1
Branch 3359: 1
Branch 3360: 1
Branch 3361: 1
Branch 3362: 1
Branch 3363: 1
Branch 3364: 1
Branch 3365: 1
Branch 3366: 1
Branch 3367: 1
Branch 3368: 1
Branch 3369: 1
Branch 3370: 1
Branch 3371: 1
Branch 3372: 1
Branch 3373: 1
Branch 3374: 1
Branch 3375: 1
Branch 3376: 1
Branch 3377: 1
Branch 3378: 1
Branch 3379: 1
Branch 3380: 1
Branch 3381: 1
Branch 3382: 1
Branch 3383: 1
Branch 3384: 1
Branch 3385: 1
Branch 3386: 1
Branch 3387: 1
Branch 3388: 1
Branch 3389: 1
Branch 3390: 1
Branch 3391: 1
Branch 3392: 1
Branch 3393: 1
Branch 3394: 1
Branch 3395: 1
Branch 3396: 1
Branch 3397: 1
Branch 3398: 1
Branch 3399: 1
Branch 3400: 1
Branch 3401: 1
Branch 3402: 1
Branch 3403: 1
Branch 3404: 1
Branch 3405: 1
Branch 3406: 1
Branch 3407: 1
Branch 3408: 1
Branch 3409: 1
Branch 3410: 1
Branch 3411: 1
Branch 3412: 1
Branch 3413: 1
Branch 3414: 1
Branch 3415: 1
Branch 3416: 1
Branch 3417: 1
Branch 3418: 1
Branch 3419: 1
Branch 3420: 1
Branch 3421: 1
Branch 3422: 1
Branch 3423: 1
Branch 3424: 1
Branch 3425: 1
Branch 3426: 1
Branch 3427: 1
Branch 3428: 1
Branch 3429: 1
Branch 3430: 1
Branch 3431: 1
Branch 3432: 1
Branch 3433: 1
Branch 3434: 1
Branch 3435: 1
Branch 3436: 1
Branch 3437: 1
Branch 3438: 1
Branch 3439: 1
Branch 3440: 1
Branch 3441: 1
Branch 3442: 1
Branch 3443: 1
Branch 3444: 1
Branch 3445: 1
Branch 3446: 1
Branch 3447: 1
Branch 3448: 1
Branch 3449: 1
Branch 3450: 1
Branch 3451: 1
Branch 3452: 1
Branch 3453: 1
Branch 3454: 1
Branch 3455: 1
Branch 3456: 1
Branch 3457: 1
Branch 3458: 1
Branch 3459: 1
Branch 3460: 1
Branch 3461: 1
Branch 3462: 1
Branch 3463: 1
Branch 3464: 1
Branch 3465: 1
Branch 3466: 1
Branch 3467: 1
Branch 3468: 1
Branch 3469: 1
Branch 3470: 1
Branch 3471: 1
Branch 3472: 1
Branch 3473: 1
Branch 3474: 1
Branch 3475: 1
Branch 3476: 1
Branch 3477: 1
Branch 3478: 1
Branch 3479: 1
Branch 3480: 1
Branch 3481: 1
Branch 3482: 1
Branch 3483: 1
Branch 3484: 1
Branch 3485: 1
Branch 3486: 1
Branch 3487: 1
Branch 3488: 1
Branch 3489: 1
Branch 3490: 1
Branch 3491: 1
Branch 3492: 1
Branch 3493: 1
Branch 3494: 1
Branch 3495: 1
Branch 3496: 1
Branch 3497: 1
Branch 3498: 1
Branch 3499: 1
Branch 3500: 1
Branch 3501: 1
Branch 3502: 1
Branch 3503: 1
Branch 3504: 1
Branch 3505: 1
Branch 3506: 1
Branch 3507: 1
Branch 3508: 1
Branch 3509: 1
Branch 3510: 1
Branch 3511: 1
Branch 3512: 1
Branch 3513: 1
Branch 3514: 1
Branch 3515: 1
Branch 3516: 1
Branch 3517: 1
Branch 3518: 1
Branch 3519: 1
Branch 3520: 1
Branch 3521: 1
Branch 3522: 1
Branch 3523: 1
Branch 3524: 1
Branch 3525: 1
Branch 3526: 1
Branch 3527: 1
Branch 3528: 1
Branch 3529: 1
Branch 3530: 1
Branch 3531: 1
Branch 3532: 1
Branch 3533: 1
Branch 3534: 1
Branch 3535: 1
Branch 3536: 1
Branch 3537: 1
Branch 3538: 1
Branch 3539: 1
Branch 3540: 1
Branch 3541: 1
Branch 3542: 1
Branch 3543: 1
Branch 3544: 1
Branch 3545: 1
Branch 3546: 1
Branch 3547: 1
Branch 3548: 1
Branch 3549: 1
Branch 3550: 1
Branch 3551: 1
Branch 3552: 1
Branch 3553: 1
Branch 3554: 1
Branch 3555: 1
Branch 3556: 1
Branch 3557: 1
Branch 3558: 1
Branch 3559: 1
Branch 3560: 1
Branch 3561: 1
Branch 3562: 1
Branch 3563: 1
Branch 3564: 1
Branch 3565: 1
Branch 3566: 1
Branch 3567: 1
Branch 3568: 1
Branch 3569: 1
Branch 3570: 1
Branch 3571: 1
Branch 3572: 1
Branch 3573: 1
Branch 3574: 1
Branch 3575: 1
Branch 3576: 1
Branch 3577: 1
Branch 3578: 1
Branch 3579: 1
Branch 3580: 1
Branch 3581: 1
Branch 3582: 1
Branch 3583: 1
Branch 3584: 1
Branch 3585: 1
Branch 3586: 1
Branch 3587: 1
Branch 3588: 1
Branch 3589: 1
Branch 3590: 1
Branch 3591: 1
Branch 3592: 1
Branch 3593: 1
Branch 3594: 1
Branch 3595: 1
Branch 3596: 1
Branch 3597: 1
Branch 3598: 1
Branch 3599: 1
Branch 3600: 1
Branch 3601: 1
Branch 3602: 1
Branch 3603: 1
Branch 3604: 1
Branch 3605: 1
Branch 3606: 1
Branch 3607: 1
Branch 3608: 1
Branch 3609: 1
Branch 3610: 1
Branch 3611: 1
Branch 3612: 1
Branch 3613: 1
Branch 3614: 1
Branch 3615: 1
Branch 3616: 1
Branch 3617: 1
Branch 3618: 1
Branch 3619: 1
Branch 3620: 1
Branch 3621: 1
Branch 3622: 1
Branch 3623: 1
Branch 3624: 1
Branch 3625: 1
Branch 3626: 1
Branch 3627: 1
Branch 3628: 1
Branch 3629: 1
Branch 3630: 1
Branch 3631: 1
Branch 3632: 1
Branch 3633: 1
Branch 3634: 1
Branch 3635: 1
Branch 3636: 1
Branch 3637: 1
Branch 3638: 1
Branch 3639: 1
Branch 3640: 1
Branch 3641: 1
Branch 3642: 1
Branch 3643: 1
Branch 3644: 1
Branch 3645: 1
Branch 3646: 1
Branch 3647: 1
Branch 3648: 1
Branch 3649: 1
Branch 3650: 1
Branch 3651: 1
Branch 3652: 1
Branch 3653: 1
Branch 3654: 1
Branch 3655: 1
Branch 3656: 1
Branch 3657: 1
Branch 3658: 1
Branch 3659: 1
Branch 3660: 1
Branch 3661: 1
Branch 3662: 1
Branch 3663: 1
Branch 3664: 1
Branch 3665: 1
Branch 3666: 1
Branch 3667: 1
Branch 3668: 1
Branch 3669: 1
Branch 3670: 1
Branch 3671: 1
Branch 3672: 1
Branch 3673: 1
Branch 3674: 1
Branch 3675: 1
Branch 3676: 1
Branch 3677: 1
Branch 3678: 1
Branch 3679: 1
Branch 3680: 1
Branch 3681: 1
Branch 3682: 1
Branch 3683: 1
Branch 3684: 1
Branch 3685: 1
Branch 3686: 1
Branch 3687: 1
Branch 3688: 1
Branch 3689: 1
Branch 3690: 1
Branch 3691: 1
Branch 3692: 1
Branch 3693: 1
Branch 3694: 1
Branch 3695: 1
Branch 3696: 1
Branch 3697: 1
Branch 3698: 1
Branch 3699: 1
Branch 3700: 1
Branch 3701: 1
Branch 3702: 1
Branch 3703: 1
Branch 3704: 1
Branch 3705: 1
Branch 3706: 1
Branch 3707: 1
Branch 3708: 1
Branch 3709: 1
Branch 3710: 1
Branch 3711: 1
Branch 3712: 1
Branch 3713: 1
Branch 3714: 1
Branch 3715: 1
Branch 3716: 1
Branch 3717: 1
Branch 3718: 1
Branch 3719: 1
Branch 3720: 1
Branch 3721: 1
Branch 3722: 1
Branch 3723: 1
Branch 3724: 1
Branch 3725: 1
Branch 3726: 1
Branch 3727: 1
Branch 3728: 1
Branch 3729: 1
Branch 3730: 1
Branch 3731: 1
Branch 3732: 1
Branch 3733: 1
Branch 3734: 1
Branch 3735: 1
Branch 3736: 1
Branch 3737: 1
Branch 3738: 1
Branch 3739: 1
Branch 3740: 1
Branch 3741: 1
Branch 3742: 1
Branch 3743: 1
Branch 3744: 1
Branch 3745: 1
Branch 3746: 1
Branch 3747: 1
Branch 3748: 1
Branch 3749: 1
Branch 3750: 1
Branch 3751: 1
Branch 3752: 1
Branch 3753: 1
Branch 3754: 1
Branch 3755: 1
Branch 3756: 1
Branch 3757: 1
Branch 3758: 1
Branch 3759: 1
Branch 3760: 1
Branch 3761: 1
Branch 3762: 1
Branch 3763: 1
Branch 3764: 1
Branch 3765: 1
Branch 3766: 1
Branch 3767: 1
Branch 3768: 1
Branch 3769: 1
Branch 3770: 1
Branch 3771: 1
Branch 3772: 1
Branch 3773: 1
Branch 3774: 1
Branch 3775: 1
Branch 3776: 1
Branch 3777: 1
Branch 3778: 1
Branch 3779: 1
Branch 3780: 1
Branch 3781: 1
Branch 3782: 1
Branch 3783: 1
Branch 3784: 1
Branch 3785: 1
Branch 3786: 1
Branch 3787: 1
Branch 3788: 1
Branch 3789: 1
Branch 3790: 1
Branch 3791: 1
Branch 3792: 1
Branch 3793: 1
Branch 3794: 1
Branch 3795: 1
Branch 3796: 1
Branch 3797: 1
Branch 3798: 1
Branch 3799: 1
Branch 3800: 1
Branch 3801: 1
Branch 3802: 1
Branch 3803: 1
Branch 3804: 1
Branch 3805: 1
Branch 3806: 1
Branch 3807: 1
Branch 3808: 1
Branch 3809: 1
Branch 3810: 1
Branch 3811: 1
Branch 3812: 1
Branch 3813: 1
Branch 3814: 1
Branch 3815: 1
Branch 3816: 1
Branch 3817: 1
Branch 3818: 1
Branch 3819: 1
Branch 3820: 1
Branch 3821: 1
Branch 3822: 1
Branch 3823: 1
Branch 3824: 1
Branch 3825: 1
Branch 3826: 1
Branch 3827: 1
Branch 3828: 1
Branch 3829: 1
Branch 3830: 1
Branch 3831: 1
Branch 3832: 1
Branch 3833: 1
Branch 3834: 1
Branch 3835: 1
Branch 3836: 1
Branch 3837: 1
Branch 3838: 1
Branch 3839: 1
Branch 3840: 1
Branch 3841: 1
Branch 3842: 1
Branch 3843: 1
Branch 3844: 1
Branch 3845: 1
Branch 3846: 1
Branch 3847: 1
Branch 3848: 1
Branch 3849: 1
Branch 3850: 1
Branch 3851: 1
Branch 3852: 1
Branch 3853: 1
Branch 3854: 1
Branch 3855: 1
Branch 3856: 1
Branch 3857: 1
Branch 3858: 1
Branch 3859: 1
Branch 3860: 1
Branch 3861: 1
Branch 3862: 1
Branch 3863: 1
Branch 3864: 1
Branch 3865: 1
Branch 3866: 1
Branch 3867: 1
Branch 3868: 1
Branch 3869: 1
Branch 3870: 1
Branch 3871: 1
Branch 3872: 1
Branch 3873: 1
Branch 3874: 1
Branch 3875: 1
Branch 3876: 1
Branch 3877: 1
Branch 3878: 1
Branch 3879: 1
Branch 3880: 1
Branch 3881: 1
Branch 3882: 1
Branch 3883: 1
Branch 3884: 1
Branch 3885: 1
Branch 3886: 1
Branch 3887: 1
Branch 3888: 1
Branch 3889: 1
Branch 3890: 1
Branch 3891: 1
Branch 3892: 1
Branch 3893: 1
Branch 3894: 1
Branch 3895: 1
Branch 3896: 1
Branch 3897: 1
Branch 3898: 1
Branch 3899: 1
Branch 3900: 1
Branch 3901: 1
Branch 3902: 1
Branch 3903: 1
Branch 3904: 1
Branch 3905: 1
Branch 3906: 1
Branch 3907: 1
Branch 3908: 1
Branch 3909: 1
Branch 3910: 1
Branch 3911: 1
Branch 3912: 1
Branch 3913: 1
Branch 3914: 1
Branch 3915: 1
Branch 3916: 1
Branch 3917: 1
Branch 3918: 1
Branch 3919: 1
Branch 3920: 1
Branch 3921: 1
Branch 3922: 1
Branch 3923: 1
Branch 3924: 1
Branch 3925: 1
Branch 3926: 1
Branch 3927: 1
Branch 3928: 1
Branch 3929: 1
Branch 3930: 1
Branch 3931: 1
Branch 3932: 1
Branch 3933: 1
Branch 3934: 1
Branch 3935: 1
Branch 3936: 1
Branch 3937: 1
Branch 3938: 1
Branch 3939: 1
Branch 3940: 1
Branch 3941: 1
Branch 3942: 1
Branch 3943: 1
Branch 3944: 1
Branch 3945: 1
Branch 3946: 1
Branch 3947: 1
Branch 3948: 1
Branch 3949: 1
Branch 3950: 1
Branch 3951: 1
Branch 3952: 1
Branch 3953: 1
Branch 3954: 1
Branch 3955: 1
Branch 3956: 1
Branch 3957: 1
Branch 3958: 1
Branch 3959: 1
Branch 3960: 1
Branch 3961: 1
Branch 3962: 1
Branch 3963: 1
Branch 3964: 1
Branch 3965: 1
Branch 3966: 1
Branch 3967: 1
Branch 3968: 1
Branch 3969: 1
Branch 3970: 1
Branch 3971: 1
Branch 3972: 1
Branch 3973: 1
Branch 3974: 1
Branch 3975: 1
Branch 3976: 1
Branch 3977: 1
Branch 3978: 1
Branch 3979: 1
Branch 3980: 1
Branch 3981: 1
Branch 3982: 1
Branch 3983: 1
Branch 3984: 1
Branch 3985: 1
Branch 3986: 1
Branch 3987: 1
Branch 3988: 1
Branch 3989: 1
Branch 3990: 1
Branch 3991: 1
Branch 3992: 1
Branch 3993: 1
Branch 3994: 1
Branch 3995: 1
Branch 3996: 1
Branch 3997: 1
Branch 3998: 1
Branch 3999: 1
Branch 4000: 1
Branch 4001: 1
Branch 4002: 1
Branch 4003: 1
Branch 4004: 1
Branch 4005: 1
Branch 4006: 1
Branch 4007: 1
Branch 4008: 1
Branch 4009: 1
Branch 4010: 1
Branch 4011: 1
Branch 4012: 1
Branch 4013: 1
Branch 4014: 1
Branch 4015: 1
Branch 4016: 1
Branch 4017: 1
Branch 4018: 1
Branch 4019: 1
Branch 4020: 1
Branch 4021: 1
Branch 4022: 1
Branch 4023: 1
Branch 4024: 1
Branch 4025: 1
Branch 4026: 1
Branch 4027: 1
Branch 4028: 1
Branch 4029: 1
Branch 4030: 1
Branch 4031: 1
Branch 4032: 1
Branch 4033: 1
Branch 4034: 1
Branch 4035: 1
Branch 4036: 1
Branch 4037: 1
Branch 4038: 1
Branch 4039: 1
Branch 4040: 1
Branch 4041: 1
Branch 4042: 1
Branch 4043: 1
Branch 4044: 1
Branch 4045: 1
Branch 4046: 1
Branch 4047: 1
Branch 4048: 1
Branch 4049: 1
Branch 4050: 1
Branch 4051: 1
Branch 4052: 1
Branch 4053: 1
Branch 4054: 1
Branch 4055: 1
Branch 4056: 1
Branch 4057: 1
Branch 4058: 1
Branch 4059: 1
Branch 4060: 1
Branch 4061: 1
Branch 4062: 1
Branch 4063: 1
Branch 4064: 1
Branch 4065: 1
Branch 4066: 1
Branch 4067: 1
Branch 4068: 1
Branch 4069: 1
Branch 4070: 1
Branch 4071: 1
Branch 4072: 1
Branch 4073: 1
Branch 4074: 1
Branch 4075: 1
Branch 4076: 1
Branch 4077: 1
Branch 4078: 1
Branch 4079: 1
Branch 4080: 1
Branch 4081: 1
Branch 4082: 1
Branch 4083: 1
Branch 4084: 1
Branch 4085: 1
Branch 4086: 1
Branch 4087: 1
Branch 4088: 1
Branch 4089: 1
Branch 4090: 1
Branch 4091: 1
Branch 4092: 1
Branch 4093: 1
Branch 4094: 1
Branch 4095: 1
Branch 4096: 1
Branch 4097: 1
Branch 4098: 1
Branch 4099: 1
Branch 4100: 1
Branch 4101: 1
Branch 4102: 1
Branch 4103: 1
Branch 4104: 1
Branch 4105: 1
Branch 4106: 1
Branch 4107: 1
Branch 4108: 1
Branch 4109: 1
Branch 4110: 1
Branch 4111: 1
Branch 4112: 1
Branch 4113: 1
Branch 4114: 1
Branch 4115: 1
Branch 4116: 1
Branch 4117: 1
Branch 4118: 1
Branch 4119: 1
Branch 4120: 1
Branch 4121: 1
Branch 4122: 1
Branch 4123: 1
Branch 4124: 1
Branch 4125: 1
Branch 4126: 1
Branch 4127: 1
Branch 4128: 1
Branch 4129: 1
Branch 4130: 1
Branch 4131: 1
Branch 4132: 1
Branch 4133: 1
Branch 4134: 1
Branch 4135: 1
Branch 4136: 1
Branch 4137: 1
Branch 4138: 1
Branch 4139: 1
Branch 4140: 1
Branch 4141: 1
Branch 4142: 1
Branch 4143: 1
Branch 4144: 1
Branch 4145: 1
Branch 4146: 1
Branch 4147: 1
Branch 4148: 1
Branch 4149: 1
Branch 4150: 1
Branch 4151: 1
Branch 4152: 1
Branch 4153: 1
Branch 4154: 1
Branch 4155: 1
Branch 4156: 1
Branch 4157: 1
Branch 4158: 1
Branch 4159: 1
Branch 4160: 1
Branch 4161: 1
Branch 4162: 1
Branch 4163: 1
Branch 4164: 1
Branch 4165: 1
Branch 4166: 1
Branch 4167: 1
Branch 4168: 1
Branch 4169: 1
Branch 4170: 1
Branch 4171: 1
Branch 4172: 1
Branch 4173: 1
Branch 4174: 1
Branch 4175: 1
Branch 4176: 1
Branch 4177: 1
Branch 4178: 1
Branch 4179: 1
Branch 4180: 1
Branch 4181: 1
Branch 4182: 1
Branch 4183: 1
Branch 4184: 1
Branch 4185: 1
Branch 4186: 1
Branch 4187: 1
Branch 4188: 1
Branch 4189: 1
Branch 4190: 1
Branch 4191: 1
Branch 4192: 1
Branch 4193: 1
Branch 4194: 1
Branch 4195: 1
Branch 4196: 1
Branch 4197: 1
Branch 4198: 1
Branch 4199: 1
Branch 4200: 1
Branch 4201: 1
Branch 4202: 1
Branch 4203: 1
Branch 4204: 1
Branch 4205: 1
Branch 4206: 1
Branch 4207: 1
Branch 4208: 1
Branch 4209: 1
Branch 4210: 1
Branch 4211: 1
Branch 4212: 1
Branch 4213: 1
Branch 4214: 1
Branch 4215: 1
Branch 4216: 1
Branch 4217: 1
Branch 4218: 1
Branch 4219: 1
Branch 4220: 1
Branch 4221: 1
Branch 4222: 1
Branch 4223: 1
Branch 4224: 1
Branch 4225: 1
Branch 4226: 1
Branch 4227: 1
Branch 4228: 1
Branch 4229: 1
Branch 4230: 1
Branch 4231: 1
Branch 4232: 1
Branch 4233: 1
Branch 4234: 1
Branch 4235: 1
Branch 4236: 1
Branch 4237: 1
Branch 4238: 1
Branch 4239: 1
Branch 4240: 1
Branch 4241: 1
Branch 4242: 1
Branch 4243: 1
Branch 4244: 1
Branch 4245: 1
Branch 4246: 1
Branch 4247: 1
Branch 4248: 1
Branch 4249: 1
Branch 4250: 1
Branch 4251: 1
Branch 4252: 1
Branch 4253: 1
Branch 4254: 1
Branch 4255: 1
Branch 4256: 1
Branch 4257: 1
Branch 4258: 1
Branch 4259: 1
Branch 4260: 1
Branch 4261: 1
Branch 4262: 1
Branch 4263: 1
Branch 4264: 1
Branch 4265: 1
Branch 4266: 1
Branch 4267: 1
Branch 4268: 1
Branch 4269: 1
Branch 4270: 1
Branch 4271: 1
Branch 4272: 1
Branch 4273: 1
Branch 4274: 1
Branch 4275: 1
Branch 4276: 1
Branch 4277: 1
Branch 4278: 1
Branch 4279: 1
Branch 4280: 1
Branch 4281: 1
Branch 4282: 1
Branch 4283: 1
Branch 4284: 1
Branch 4285: 1
Branch 4286: 1
Branch 4287: 1
Branch 4288: 1
Branch 4289: 1
Branch 4290: 1
Branch 4291: 1
Branch 4292: 1
Branch 4293: 1
Branch 4294: 1
Branch 4295: 1
Branch 4296: 1
Branch 4297: 1
Branch 4298: 1
Branch 4299: 1
Branch 4300: 1
Branch 4301: 1
Branch 4302: 1
Branch 4303: 1
Branch 4304: 1
Branch 4305: 1
Branch 4306: 1
Branch 4307: 1
Branch 4308: 1
Branch 4309: 1
Branch 4310: 1
Branch 4311: 1
Branch 4312: 1
Branch 4313: 1
Branch 4314: 1
Branch 4315: 1
Branch 4316: 1
Branch 4317: 1
Branch 4318: 1
Branch 4319: 1
Branch 4320: 1
Branch 4321: 1
Branch 4322: 1
Branch 4323: 1
Branch 4324: 1
Branch 4325: 1
Branch 4326: 1
Branch 4327: 1
Branch 4328: 1
Branch 4329: 1
Branch 4330: 1
Branch 4331: 1
Branch 4332: 1
Branch 4333: 1
Branch 4334: 1
Branch 4335: 1
Branch 4336: 1
Branch 4337: 1
Branch 4338: 1
Branch 4339: 1
Branch 4340: 1
Branch 4341: 1
Branch 4342: 1
Branch 4343: 1
Branch 4344: 1
Branch 4345: 1
Branch 4346: 1
Branch 4347: 1
Branch 4348: 1
Branch 4349: 1
Branch 4350: 1
Branch 4351: 1
Branch 4352: 1
Branch 4353: 1
Branch 4354: 1
Branch 4355: 1
Branch 4356: 1
Branch 4357: 1
Branch 4358: 1
Branch 4359: 1
Branch 4360: 1
Branch 4361: 1
Branch 4362: 1
Branch 4363: 1
Branch 4364: 1
Branch 4365: 1
Branch 4366: 1
Branch 4367: 1
Branch 4368: 1
Branch 4369: 1
Branch 4370: 1
Branch 4371: 1
Branch 4372: 1
Branch 4373: 1
Branch 4374: 1
Branch 4375: 1
Branch 4376: 1
Branch 4377: 1
Branch 4378: 1
Branch 4379: 1
Branch 4380: 1
Branch 4381: 1
Branch 4382: 1
Branch 4383: 1
Branch 4384: 1
Branch 4385: 1
Branch 4386: 1
Branch 4387: 1
Branch 4388: 1
Branch 4389: 1
Branch 4390: 1
Branch 4391: 1
Branch 4392: 1
Branch 4393: 1
Branch 4394: 1
Branch 4395: 1
Branch 4396: 1
Branch 4397: 1
Branch 4398: 1
Branch 4399: 1
Branch 4400: 1
Branch 4401: 1
Branch 4402: 1
Branch 4403: 1
Branch 4404: 1
Branch 4405: 1
Branch 4406: 1
Branch 4407: 1
Branch 4408: 1
Branch 4409: 1
Branch 4410: 1
Branch 4411: 1
Branch 4412: 1
Branch 4413: 1
Branch 4414: 1
Branch 4415: 1
Branch 4416: 1
Branch 4417: 1
Branch 4418: 1
Branch 4419: 1
Branch 4420: 1
Branch 4421: 1
Branch 4422: 1
Branch 4423: 1
Branch 4424: 1
Branch 4425: 1
Branch 4426: 1
Branch 4427: 1
Branch 4428: 1
Branch 4429: 1
Branch 4430: 1
Branch 4431: 1
Branch 4432: 1
Branch 4433: 1
Branch 4434: 1
Branch 4435: 1
Branch 4436: 1
Branch 4437: 1
Branch 4438: 1
Branch 4439: 1
Branch 4440: 1
Branch 4441: 1
Branch 4442: 1
Branch 4443: 1
Branch 4444: 1
Branch 4445: 1
Branch 4446: 1
Branch 4447: 1
Branch 4448: 1
Branch 4449: 1
Branch 4450: 1
Branch 4451: 1
Branch 4452: 1
Branch 4453: 1
Branch 4454: 1
Branch 4455: 1
Branch 4456: 1
Branch 4457: 1
Branch 4458: 1
Branch 4459: 1
Branch 4460: 1
Branch 4461: 1
Branch 4462: 1
Branch 4463: 1
Branch 4464: 1
Branch 4465: 1
Branch 4466: 1
Branch 4467: 1
Branch 4468: 1
Branch 4469: 1
Branch 4470: 1
Branch 4471: 1
Branch 4472: 1
Branch 4473: 1
Branch 4474: 1
Branch 4475: 1
Branch 4476: 1
Branch 4477: 1
Branch 4478: 1
Branch 4479: 1
Branch 4480: 1
Branch 4481: 1
Branch 4482: 1
Branch 4483: 1
Branch 4484: 1
Branch 4485: 1
Branch 4486: 1
Branch 4487: 1
Branch 4488: 1
Branch 4489: 1
Branch 4490: 1
Branch 4491: 1
Branch 4492: 1
Branch 4493: 1
Branch 4494: 1
Branch 4495: 1
Branch 4496: 1
Branch 4497: 1
Branch 4498: 1
Branch 4499: 1
Branch 4500: 1
Branch 4501: 1
Branch 4502: 1
Branch 4503: 1
Branch 4504: 1
Branch 4505: 1
Branch 4506: 1
Branch 4507: 1
Branch 4508: 1
Branch 4509: 1
Branch 4510: 1
Branch 4511: 1
Branch 4512: 1
Branch 4513: 1
Branch 4514: 1
Branch 4515: 1
Branch 4516: 1
Branch 4517: 1
Branch 4518: 1
Branch 4519: 1
Branch 4520: 1
Branch 4521: 1
Branch 4522: 1
Branch 4523: 1
Branch 4524: 1
Branch 4525: 1
Branch 4526: 1
Branch 4527: 1
Branch 4528: 1
Branch 4529: 1
Branch 4530: 1
Branch 4531: 1
Branch 4532: 1
Branch 4533: 1
Branch 4534: 1
Branch 4535: 1
Branch 4536: 1
Branch 4537: 1
Branch 4538: 1
Branch 4539: 1
Branch 4540: 1
Branch 4541: 1
Branch 4542: 1
Branch 4543: 1
Branch 4544: 1
Branch 4545: 1
Branch 4546: 1
Branch 4547: 1
Branch 4548: 1
Branch 4549: 1
Branch 4550: 1
Branch 4551: 1
Branch 4552: 1
Branch 4553: 1
Branch 4554: 1
Branch 4555: 1
Branch 4556: 1
Branch 4557: 1
Branch 4558: 1
Branch 4559: 1
Branch 4560: 1
Branch 4561: 1
Branch 4562: 1
Branch 4563: 1
Branch 4564: 1
Branch 4565: 1
Branch 4566: 1
Branch 4567: 1
Branch 4568: 1
Branch 4569: 1
Branch 4570: 1
Branch 4571: 1
Branch 4572: 1
Branch 4573: 1
Branch 4574: 1
Branch 4575: 1
Branch 4576: 1
Branch 4577: 1
Branch 4578: 1
Branch 4579: 1
Branch 4580: 1
Branch 4581: 1
Branch 4582: 1
Branch 4583: 1
Branch 4584: 1
Branch 4585: 1
Branch 4586: 1
Branch 4587: 1
Branch 4588: 1
Branch 4589: 1
Branch 4590: 1
Branch 4591: 1
Branch 4592: 1
Branch 4593: 1
Branch 4594: 1
Branch 4595: 1
Branch 4596: 1
Branch 4597: 1
Branch 4598: 1
Branch 4599: 1
Branch 4600: 1
Branch 4601: 1
Branch 4602: 1
Branch 4603: 1
Branch 4604: 1
Branch 4605: 1
Branch 4606: 1
Branch 4607: 1
Branch 4608: 1
Branch 4609: 1
Branch 4610: 1
Branch 4611: 1
Branch 4612: 1
Branch 4613: 1
Branch 4614: 1
Branch 4615: 1
Branch 4616: 1
Branch 4617: 1
Branch 4618: 1
Branch 4619: 1
Branch 4620: 1
Branch 4621: 1
Branch 4622: 1
Branch 4623: 1
Branch 4624: 1
Branch 4625: 1
Branch 4626: 1
Branch 4627: 1
Branch 4628: 1
Branch 4629: 1
Branch 4630: 1
Branch 4631: 1
Branch 4632: 1
Branch 4633: 1
Branch 4634: 1
Branch 4635: 1
Branch 4636: 1
Branch 4637: 1
Branch 4638: 1
Branch 4639: 1
Branch 4640: 1
Branch 4641: 1
Branch 4642: 1
Branch 4643: 1
Branch 4644: 1
Branch 4645: 1
Branch 4646: 1
Branch 4647: 1
Branch 4648: 1
Branch 4649: 1
Branch 4650: 1
Branch 4651: 1
Branch 4652: 1
Branch 4653: 1
Branch 4654: 1
Branch 4655: 1
Branch 4656: 1
Branch 4657: 1
Branch 4658: 1
Branch 4659: 1
Branch 4660: 1
Branch 4661: 1
Branch 4662: 1
Branch 4663: 1
Branch 4664: 1
Branch 4665: 1
Branch 4666: 1
Branch 4667: 1
Branch 4668: 1
Branch 4669: 1
Branch 4670: 1
Branch 4671: 1
Branch 4672: 1
Branch 4673: 1
Branch 4674: 1
Branch 4675: 1
Branch 4676: 1
Branch 4677: 1
Branch 4678: 1
Branch 4679: 1
Branch 4680: 1
Branch 4681: 1
Branch 4682: 1
Branch 4683: 1
Branch 4684: 1
Branch 4685: 1
Branch 4686: 1
Branch 4687: 1
Branch 4688: 1
Branch 4689: 1
Branch 4690: 1
Branch 4691: 1
Branch 4692: 1
Branch 4693: 1
Branch 4694: 1
Branch 4695: 1
Branch 4696: 1
Branch 4697: 1
Branch 4698: 1
Branch 4699: 1
Branch 4700: 1
Branch 4701: 1
Branch 4702: 1
Branch 4703: 1
Branch 4704: 1
Branch 4705: 1
Branch 4706: 1
Branch 4707: 1
Branch 4708: 1
Branch 4709: 1
Branch 4710: 1
Branch 4711: 1
Branch 4712: 1
Branch 4713: 1
Branch 4714: 1
Branch 4715: 1
Branch 4716: 1
Branch 4717: 1
Branch 4718: 1
Branch 4719: 1
Branch 4720: 1
Branch 4721: 1
Branch 4722: 1
Branch 4723: 1
Branch 4724: 1
Branch 4725: 1
Branch 4726: 1
Branch 4727: 1
Branch 4728: 1
Branch 4729: 1
Branch 4730: 1
Branch 4731: 1
Branch 4732: 1
Branch 4733: 1
Branch 4734: 1
Branch 4735: 1
Branch 4736: 1
Branch 4737: 1
Branch 4738: 1
Branch 4739: 1
Branch 4740: 1
Branch 4741: 1
Branch 4742: 1
Branch 4743: 1
Branch 4744: 1
Branch 4745: 1
Branch 4746: 1
Branch 4747: 1
Branch 4748: 1
Branch 4749: 1
Branch 4750: 1
Branch 4751: 1
Branch 4752: 1
Branch 4753: 1
Branch 4754: 1
Branch 4755: 1
Branch 4756: 1
Branch 4757: 1
Branch 4758: 1
Branch 4759: 1
Branch 4760: 1
Branch 4761: 1
Branch 4762: 1
Branch 4763: 1
Branch 4764: 1
Branch 4765: 1
Branch 4766: 1
Branch 4767: 1
Branch 4768: 1
Branch 4769: 1
Branch 4770: 1
Branch 4771: 1
Branch 4772: 1
Branch 4773: 1
Branch 4774: 1
Branch 4775: 1
Branch 4776: 1
Branch 4777: 1
Branch 4778: 1
Branch 4779: 1
Branch 4780: 1
Branch 4781: 1
Branch 4782: 1
Branch 4783: 1
Branch 4784: 1
Branch 4785: 1
Branch 4786: 1
Branch 4787: 1
Branch 4788: 1
Branch 4789: 1
Branch 4790: 1
Branch 4791: 1
Branch 4792: 1
Branch 4793: 1
Branch 4794: 1
Branch 4795: 1
Branch 4796: 1
Branch 4797: 1
Branch 4798: 1
Branch 4799: 1
Branch 4800: 1
Branch 4801: 1
Branch 4802: 1
Branch 4803: 1
Branch 4804: 1
Branch 4805: 1
Branch 4806: 1
Branch 4807: 1
Branch 4808: 1
Branch 4809: 1
Branch 4810: 1
Branch 4811: 1
Branch 4812: 1
Branch 4813: 1
Branch 4814: 1
Branch 4815: 1
Branch 4816: 1
Branch 4817: 1
Branch 4818: 1
Branch 4819: 1
Branch 4820: 1
Branch 4821: 1
Branch 4822: 1
Branch 4823: 1
Branch 4824: 1
Branch 4825: 1
Branch 4826: 1
Branch 4827: 1
Branch 4828: 1
Branch 4829: 1
Branch 4830: 1
Branch 4831: 1
Branch 4832: 1
Branch 4833: 1
Branch 4834: 1
Branch 4835: 1
Branch 4836: 1
Branch 4837: 1
Branch 4838: 1
Branch 4839: 1
Branch 4840: 1
Branch 4841: 1
Branch 4842: 1
Branch 4843: 1
Branch 4844: 1
Branch 4845: 1
Branch 4846: 1
Branch 4847: 1
Branch 4848: 1
Branch 4849: 1
Branch 4850: 1
Branch 4851: 1
Branch 4852: 1
Branch 4853: 1
Branch 4854: 1
Branch 4855: 1
Branch 4856: 1
Branch 4857: 1
Branch 4858: 1
Branch 4859: 1
Branch 4860: 1
Branch 4861: 1
Branch 4862: 1
Branch 4863: 1
Branch 4864: 1
Branch 4865: 1
Branch 4866: 1
Branch 4867: 1
Branch 4868: 1
Branch 4869: 1
Branch 4870: 1
Branch 4871: 1
Branch 4872: 1
Branch 4873: 1
Branch 4874: 1
Branch 4875: 1
Branch 4876: 1
Branch 4877: 1
Branch 4878: 1
Branch 4879: 1
Branch 4880: 1
Branch 4881: 1
Branch 4882: 1
Branch 4883: 1
Branch 4884: 1
Branch 4885: 1
Branch 4886: 1
Branch 4887: 1
Branch 4888: 1
Branch 4889: 1
Branch 4890: 1
Branch 4891: 1
Branch 4892: 1
Branch 4893: 1
Branch 4894: 1
Branch 4895: 1
Branch 4896: 1
Branch 4897: 1
Branch 4898: 1
Branch 4899: 1
Branch 4900: 1
Branch 4901: 1
Branch 4902: 1
Branch 4903: 1
Branch 4904: 1
Branch 4905: 1
Branch 4906: 1
Branch 4907: 1
Branch 4908: 1
Branch 4909: 1
Branch 4910: 1
Branch 4911: 1
Branch 4912: 1
Branch 4913: 1
Branch 4914: 1
Branch 4915: 1
Branch 4916: 1
Branch 4917: 1
Branch 4918: 1
Branch 4919: 1
Branch 4920: 1
Branch 4921: 1
Branch 4922: 1
Branch 4923: 1
Branch 4924: 1
Branch 4925: 1
Branch 4926: 1
Branch 4927: 1
Branch 4928: 1
Branch 4929: 1
Branch 4930: 1
Branch 4931: 1
Branch 4932: 1
Branch 4933: 1
Branch 4934: 1
Branch 4935: 1
Branch 4936: 1
Branch 4937: 1
Branch 4938: 1
Branch 4939: 1
Branch 4940: 1
Branch 4941: 1
Branch 4942: 1
Branch 4943: 1
Branch 4944: 1
Branch 4945: 1
Branch 4946: 1
Branch 4947: 1
Branch 4948: 1
Branch 4949: 1
Branch 4950: 1
Branch 4951: 1
Branch 4952: 1
Branch 4953: 1
Branch 4954: 1
Branch 4955: 1
Branch 4956: 1
Branch 4957: 1
Branch 4958: 1
Branch 4959: 1
Branch 4960: 1
Branch 4961: 1
Branch 4962: 1
Branch 4963: 1
Branch 4964: 1
Branch 4965: 1
Branch 4966: 1
Branch 4967: 1
Branch 4968: 1
Branch 4969: 1
Branch 4970: 1
Branch 4971: 1
Branch 4972: 1
Branch 4973: 1
Branch 4974: 1
Branch 4975: 1
Branch 4976: 1
Branch 4977: 1
Branch 4978: 1
Branch 4979: 1
Branch 4980: 1
Branch 4981: 1
Branch 4982: 1
Branch 4983: 1
Branch 4984: 1
Branch 4985: 1
Branch 4986: 1
Branch 4987: 1
Branch 4988: 1
Branch 4989: 1
Branch 4990: 1
Branch 4991: 1
Branch 4992: 1
Branch 4993: 1
Branch 4994: 1
Branch 4995: 1
Branch 4996: 1
Branch 4997: 1
Branch 4998: 1
Branch 4999: 1
Branch 5000: 1
Branch 5001: 1
Branch 5002: 1
Branch 5003: 1
Branch 5004: 1
Branch 5005: 1
Branch 5006: 1
Branch 5007: 1
Branch 5008: 1
Branch 5009: 1
Branch 5010: 1
Branch 5011: 1
Branch 5012: 1
Branch 5013: 1
Branch 5014: 1
Branch 5015: 1
Branch 5016: 1
Branch 5017: 1
Branch 5018: 1
Branch 5019: 1
Branch 5020: 1
Branch 5021: 1
Branch 5022: 1
Branch 5023: 1
Branch 5024: 1
Branch 5025: 1
Branch 5026: 1
Branch 5027: 1
Branch 5028: 1
Branch 5029: 1
Branch 5030: 1
Branch 5031: 1
Branch 5032: 1
Branch 5033: 1
Branch 5034: 1
Branch 5035: 1
Branch 5036: 1
Branch 5037: 1
Branch 5038: 1
Branch 5039: 1
Branch 5040: 1
Branch 5041: 1
Branch 5042: 1
Branch 5043: 1
Branch 5044: 1
Branch 5045: 1
Branch 5046: 1
Branch 5047: 1
Branch 5048: 1
Branch 5049: 1
Branch 5050: 1
Branch 5051: 1
Branch 5052: 1
Branch 5053: 1
Branch 5054: 1
Branch 5055: 1
Branch 5056: 1
Branch 5057: 1
Branch 5058: 1
Branch 5059: 1
Branch 5060: 1
Branch 5061: 1
Branch 5062: 1
Branch 5063: 1
Branch 5064: 1
Branch 5065: 1
Branch 5066: 1
Branch 5067: 1
Branch 5068: 1
Branch 5069: 1
Branch 5070: 1
Branch 5071: 1
Branch 5072: 1
Branch 5073: 1
Branch 5074: 1
Branch 5075: 1
Branch 5076: 1
Branch 5077: 1
Branch 5078: 1
Branch 5079: 1
Branch 5080: 1
Branch 5081: 1
Branch 5082: 1
Branch 5083: 1
Branch 5084: 1
Branch 5085: 1
Branch 5086: 1
Branch 5087: 1
Branch 5088: 1
Branch 5089: 1
Branch 5090: 1
Branch 5091: 1
Branch 5092: 1
Branch 5093: 1
Branch 5094: 1
Branch 5095: 1
Branch 5096: 1
Branch 5097: 1
Branch 5098: 1
Branch 5099: 1
Branch 5100: 1
Branch 5101: 1
Branch 5102: 1
Branch 5103: 1
Branch 5104: 1
Branch 5105: 1
Branch 5106: 1
Branch 5107: 1
Branch 5108: 1
Branch 5109: 1
Branch 5110: 1
Branch 5111: 1
Branch 5112: 1
Branch 5113: 1
Branch 5114: 1
Branch 5115: 1
Branch 5116: 1
Branch 5117: 1
Branch 5118: 1
Branch 5119: 1
Branch 5120: 1
Branch 5121: 1
Branch 5122: 1
Branch 5123: 1
Branch 5124: 1
Branch 5125: 1
Branch 5126: 1
Branch 5127: 1
Branch 5128: 1
Branch 5129: 1
Branch 5130: 1
Branch 5131: 1
Branch 5132: 1
Branch 5133: 1
Branch 5134: 1
Branch 5135: 1
Branch 5136: 1
Branch 5137: 1
Branch 5138: 1
Branch 5139: 1
Branch 5140: 1
Branch 5141: 1
Branch 5142: 1
Branch 5143: 1
Branch 5144: 1
Branch 5145: 1
Branch 5146: 1
Branch 5147: 1
Branch 5148: 1
Branch 5149: 1
Branch 5150: 1
Branch 5151: 1
Branch 5152: 1
Branch 5153: 1
Branch 5154: 1
Branch 5155: 1
Branch 5156: 1
Branch 5157: 1
Branch 5158: 1
Branch 5159: 1
Branch 5160: 1
Branch 5161: 1
Branch 5162: 1
Branch 5163: 1
Branch 5164: 1
Branch 5165: 1
Branch 5166: 1
Branch 5167: 1
Branch 5168: 1
Branch 5169: 1
Branch 5170: 1
Branch 5171: 1
Branch 5172: 1
Branch 5173: 1
Branch 5174: 1
Branch 5175: 1
Branch 5176: 1
Branch 5177: 1
Branch 5178: 1
Branch 5179: 1
Branch 5180: 1
Branch 5181: 1
Branch 5182: 1
Branch 5183: 1
Branch 5184: 1
Branch 5185: 1
Branch 5186: 1
Branch 5187: 1
Branch 5188: 1
Branch 5189: 1
Branch 5190: 1
Branch 5191: 1
Branch 5192: 1
Branch 5193: 1
Branch 5194: 1
Branch 5195: 1
Branch 5196: 1
Branch 5197: 1
Branch 5198: 1
Branch 5199: 1
Branch 5200: 1
Branch 5201: 1
Branch 5202: 1
Branch 5203: 1
Branch 5204: 1
Branch 5205: 1
Branch 5206: 1
Branch 5207: 1
Branch 5208: 1
Branch 5209: 1
Branch 5210: 1
Branch 5211: 1
Branch 5212: 1
Branch 5213: 1
Branch 5214: 1
Branch 5215: 1
Branch 5216: 1
Branch 5217: 1
Branch 5218: 1
Branch 5219: 1
Branch 5220: 1
Branch 5221: 1
Branch 5222: 1
Branch 5223: 1
Branch 5224: 1
Branch 5225: 1
Branch 5226: 1
Branch 5227: 1
Branch 5228: 1
Branch 5229: 1
Branch 5230: 1
Branch 5231: 1
Branch 5232: 1
Branch 5233: 1
Branch 5234: 1
Branch 5235: 1
Branch 5236: 1
Branch 5237: 1
Branch 5238: 1
Branch 5239: 1
Branch 5240: 1
Branch 5241: 1
Branch 5242: 1
Branch 5243: 1
Branch 5244: 1
Branch 5245: 1
Branch 5246: 1
Branch 5247: 1
Branch 5248: 1
Branch 5249: 1
Branch 5250: 1
Branch 5251: 1
Branch 5252: 1
Branch 5253: 1
Branch 5254: 1
Branch 5255: 1
Branch 5256: 1
Branch 5257: 1
Branch 5258: 1
Branch 5259: 1
Branch 5260: 1
Branch 5261: 1
Branch 5262: 1
Branch 5263: 1
Branch 5264: 1
Branch 5265: 1
Branch 5266: 1
Branch 5267: 1
Branch 5268: 1
Branch 5269: 1
Branch 5270: 1
Branch 5271: 1
Branch 5272: 1
Branch 5273: 1
Branch 5274: 1
Branch 5275: 1
Branch 5276: 1
Branch 5277: 1
Branch 5278: 1
Branch 5279: 1
Branch 5280: 1
Branch 5281: 1
Branch 5282: 1
Branch 5283: 1
Branch 5284: 1
Branch 5285: 1
Branch 5286: 1
Branch 5287: 1
Branch 5288: 1
Branch 5289: 1
Branch 5290: 1
Branch 5291: 1
Branch 5292: 1
Branch 5293: 1
Branch 5294: 1
Branch 5295: 1
Branch 5296: 1
Branch 5297: 1
Branch 5298: 1
Branch 5299: 1
Branch 5300: 1
Branch 5301: 1
Branch 5302: 1
Branch 5303: 1
Branch 5304: 1
Branch 5305: 1
Branch 5306: 1
Branch 5307: 1
Branch 5308: 1
Branch 5309: 1
Branch 5310: 1
Branch 5311: 1
Branch 5312: 1
Branch 5313: 1
Branch 5314: 1
Branch 5315: 1
Branch 5316: 1
Branch 5317: 1
Branch 5318: 1
Branch 5319: 1
Branch 5320: 1
Branch 5321: 1
Branch 5322: 1
Branch 5323: 1
Branch 5324: 1
Branch 5325: 1
Branch 5326: 1
Branch 5327: 1
Branch 5328: 1
Branch 5329: 1
Branch 5330: 1
Branch 5331: 1
Branch 5332: 1
Branch 5333: 1
Branch 5334: 1
Branch 5335: 1
Branch 5336: 1
Branch 5337: 1
Branch 5338: 1
Branch 5339: 1
Branch 5340: 1
Branch 5341: 1
Branch 5342: 1
Branch 5343: 1
Branch 5344: 1
Branch 5345: 1
Branch 5346: 1
Branch 5347: 1
Branch 5348: 1
Branch 5349: 1
Branch 5350: 1
Branch 5351: 1
Branch 5352: 1
Branch 5353: 1
Branch 5354: 1
Branch 5355: 1
Branch 5356: 1
Branch 5357: 1
Branch 5358: 1
Branch 5359: 1
Branch 5360: 1
Branch 5361: 1
Branch 5362: 1
Branch 5363: 1
Branch 5364: 1
Branch 5365: 1
Branch 5366: 1
Branch 5367: 1
Branch 5368: 1
Branch 5369: 1
Branch 5370: 1
Branch 5371: 1
Branch 5372: 1
Branch 5373: 1
Branch 5374: 1
Branch 5375: 1
Branch 5376: 1
Branch 5377: 1
Branch 5378: 1
Branch 5379: 1
Branch 5380: 1
Branch 5381: 1
Branch 5382: 1
Branch 5383: 1
Branch 5384: 1
Branch 5385: 1
Branch 5386: 1
Branch 5387: 1
Branch 5388: 1
Branch 5389: 1
Branch 5390: 1
Branch 5391: 1
Branch 5392: 1
Branch 5393: 1
Branch 5394: 1
Branch 5395: 1
Branch 5396: 1
Branch 5397: 1
Branch 5398: 1
Branch 5399: 1
Branch 5400: 1
Branch 5401: 1
Branch 5402: 1
Branch 5403: 1
Branch 5404: 1
Branch 5405: 1
Branch 5406: 1
Branch 5407: 1
Branch 5408: 1
Branch 5409: 1
Branch 5410: 1
Branch 5411: 1
Branch 5412: 1
Branch 5413: 1
Branch 5414: 1
Branch 5415: 1
Branch 5416: 1
Branch 5417: 1
Branch 5418: 1
Branch 5419: 1
Branch 5420: 1
Branch 5421: 1
Branch 5422: 1
Branch 5423: 1
Branch 5424: 1
Branch 5425: 1
Branch 5426: 1
Branch 5427: 1
Branch 5428: 1
Branch 5429: 1
Branch 5430: 1
Branch 5431: 1
Branch 5432: 1
Branch 5433: 1
Branch 5434: 1
Branch 5435: 1
Branch 5436: 1
Branch 5437: 1
Branch 5438: 1
Branch 5439: 1
Branch 5440: 1
Branch 5441: 1
Branch 5442: 1
Branch 5443: 1
Branch 5444: 1
Branch 5445: 1
Branch 5446: 1
Branch 5447: 1
Branch 5448: 1
Branch 5449: 1
Branch 5450: 1
Branch 5451: 1
Branch 5452: 1
Branch 5453: 1
Branch 5454: 1
Branch 5455: 1
Branch 5456: 1
Branch 5457: 1
Branch 5458: 1
Branch 5459: 1
Branch 5460: 1
Branch 5461: 1
Branch 5462: 1
Branch 5463: 1
Branch 5464: 1
Branch 5465: 1
Branch 5466: 1
Branch 5467: 1
Branch 5468: 1
Branch 5469: 1
Branch 5470: 1
Branch 5471: 1
Branch 5472: 1
Branch 5473: 1
Branch 5474: 1
Branch 5475: 1
Branch 5476: 1
Branch 5477: 1
Branch 5478: 1
Branch 5479: 1
Branch 5480: 1
Branch 5481: 1
Branch 5482: 1
Branch 5483: 1
Branch 5484: 1
Branch 5485: 1
Branch 5486: 1
Branch 5487: 1
Branch 5488: 1
Branch 5489: 1
Branch 5490: 1
Branch 5491: 1
Branch 5492: 1
Branch 5493: 1
Branch 5494: 1
Branch 5495: 1
Branch 5496: 1
Branch 5497: 1
Branch 5498: 1
Branch 5499: 1
Branch 5500: 1
Branch 5501: 1
Branch 5502: 1
Branch 5503: 1
Branch 5504: 1
Branch 5505: 1
Branch 5506: 1
Branch 5507: 1
Branch 5508: 1
Branch 5509: 1
Branch 5510: 1
Branch 5511: 1
Branch 5512: 1
Branch 5513: 1
Branch 5514: 1
Branch 5515: 1
Branch 5516: 1
Branch 5517: 1
Branch 5518: 1
Branch 5519: 1
Branch 5520: 1
Branch 5521: 1
Branch 5522: 1
Branch 5523: 1
Branch 5524: 1
Branch 5525: 1
Branch 5526: 1
Branch 5527: 1
Branch 5528: 1
Branch 5529: 1
Branch 5530: 1
Branch 5531: 1
Branch 5532: 1
Branch 5533: 1
Branch 5534: 1
Branch 5535: 1
Branch 5536: 1
Branch 5537: 1
Branch 5538: 1
Branch 5539: 1
Branch 5540: 1
Branch 5541: 1
Branch 5542: 1
Branch 5543: 1
Branch 5544: 1
Branch 5545: 1
Branch 5546: 1
Branch 5547: 1
Branch 5548: 1
Branch 5549: 1
Branch 5550: 1
Branch 5551: 1
Branch 5552: 1
Branch 5553: 1
Branch 5554: 1
Branch 5555: 1
Branch 5556: 1
Branch 5557: 1
Branch 5558: 1
Branch 5559: 1
Branch 5560: 1
Branch 5561: 1
Branch 5562: 1
Branch 5563: 1
Branch 5564: 1
Branch 5565: 1
Branch 5566: 1
Branch 5567: 1
Branch 5568: 1
Branch 5569: 1
Branch 5570: 1
Branch 5571: 1
Branch 5572: 1
Branch 5573: 1
Branch 5574: 1
Branch 5575: 1
Branch 5576: 1
Branch 5577: 1
Branch 5578: 1
Branch 5579: 1
Branch 5580: 1
Branch 5581: 1
Branch 5582: 1
Branch 5583: 1
Branch 5584: 1
Branch 5585: 1
Branch 5586: 1
Branch 5587: 1
Branch 5588: 1
Branch 5589: 1
Branch 5590: 1
Branch 5591: 1
Branch 5592: 1
Branch 5593: 1
Branch 5594: 1
Branch 5595: 1
Branch 5596: 1
Branch 5597: 1
Branch 5598: 1
Branch 5599: 1
Branch 5600: 1
Branch 5601: 1
Branch 5602: 1
Branch 5603: 1
Branch 5604: 1
Branch 5605: 1
Branch 5606: 1
Branch 5607: 1
Branch 5608: 1
Branch 5609: 1
Branch 5610: 1
Branch 5611: 1
Branch 5612: 1
Branch 5613: 1
Branch 5614: 1
Branch 5615: 1
Branch 5616: 1
Branch 5617: 1
Branch 5618: 1
Branch 5619: 1
Branch 5620: 1
Branch 5621: 1
Branch 5622: 1
Branch 5623: 1
Branch 5624: 1
Branch 5625: 1
Branch 5626: 1
Branch 5627: 1
Branch 5628: 1
Branch 5629: 1
Branch 5630: 1
Branch 5631: 1
Branch 5632: 1
Branch 5633: 1
Branch 5634: 1
Branch 5635: 1
Branch 5636: 1
Branch 5637: 1
Branch 5638: 1
Branch 5639: 1
Branch 5640: 1
Branch 5641: 1
Branch 5642: 1
Branch 5643: 1
Branch 5644: 1
Branch 5645: 1
Branch 5646: 1
Branch 5647: 1
Branch 5648: 1
Branch 5649: 1
Branch 5650: 1
Branch 5651: 1
Branch 5652: 1
Branch 5653: 1
Branch 5654: 1
Branch 5655: 1
Branch 5656: 1
Branch 5657: 1
Branch 5658: 1
Branch 5659: 1
Branch 5660: 1
Branch 5661: 1
Branch 5662: 1
Branch 5663: 1
Branch 5664: 1
Branch 5665: 1
Branch 5666: 1
Branch 5667: 1
Branch 5668: 1
Branch 5669: 1
Branch 5670: 1
Branch 5671: 1
Branch 5672: 1
Branch 5673: 1
Branch 5674: 1
Branch 5675: 1
Branch 5676: 1
Branch 5677: 1
Branch 5678: 1
Branch 5679: 1
Branch 5680: 1
Branch 5681: 1
Branch 5682: 1
Branch 5683: 1
Branch 5684: 1
Branch 5685: 1
Branch 5686: 1
Branch 5687: 1
Branch 5688: 1
Branch 5689: 1
Branch 5690: 1
Branch 5691: 1
Branch 5692: 1
Branch 5693: 1
Branch 5694: 1
Branch 5695: 1
Branch 5696: 1
Branch 5697: 1
Branch 5698: 1
Branch 5699: 1
Branch 5700: 1
Branch 5701: 1
Branch 5702: 1
Branch 5703: 1
Branch 5704: 1
Branch 5705: 1
Branch 5706: 1
Branch 5707: 1
Branch 5708: 1
Branch 5709: 1
Branch 5710: 1
Branch 5711: 1
Branch 5712: 1
Branch 5713: 1
Branch 5714: 1
Branch 5715: 1
Branch 5716: 1
Branch 5717: 1
Branch 5718: 1
Branch 5719: 1
Branch 5720: 1
Branch 5721: 1
Branch 5722: 1
Branch 5723: 1
Branch 5724: 1
Branch 5725: 1
Branch 5726: 1
Branch 5727: 1
Branch 5728: 1
Branch 5729: 1
Branch 5730: 1
Branch 5731: 1
Branch 5732: 1
Branch 5733: 1
Branch 5734: 1
Branch 5735: 1
Branch 5736: 1
Branch 5737: 1
Branch 5738: 1
Branch 5739: 1
Branch 5740: 1
Branch 5741: 1
Branch 5742: 1
Branch 5743: 1
Branch 5744: 1
Branch 5745: 1
Branch 5746: 1
Branch 5747: 1
Branch 5748: 1
Branch 5749: 1
Branch 5750: 1
Branch 5751: 1
Branch 5752: 1
Branch 5753: 1
Branch 5754: 1
Branch 5755: 1
Branch 5756: 1
Branch 5757: 1
Branch 5758: 1
Branch 5759: 1
Branch 5760: 1
Branch 5761: 1
Branch 5762: 1
Branch 5763: 1
Branch 5764: 1
Branch 5765: 1
Branch 5766: 1
Branch 5767: 1
Branch 5768: 1
Branch 5769: 1
Branch 5770: 1
Branch 5771: 1
Branch 5772: 1
Branch 5773: 1
Branch 5774: 1
Branch 5775: 1
Branch 5776: 1
Branch 5777: 1
Branch 5778: 1
Branch 5779: 1
Branch 5780: 1
Branch 5781: 1
Branch 5782: 1
Branch 5783: 1
Branch 5784: 1
Branch 5785: 1
Branch 5786: 1
Branch 5787: 1
Branch 5788: 1
Branch 5789: 1
Branch 5790: 1
Branch 5791: 1
Branch 5792: 1
Branch 5793: 1
Branch 5794: 1
Branch 5795: 1
Branch 5796: 1
Branch 5797: 1
Branch 5798: 1
Branch 5799: 1
Branch 5800: 1
Branch 5801: 1
Branch 5802: 1
Branch 5803: 1
Branch 5804: 1
Branch 5805: 1
Branch 5806: 1
Branch 5807: 1
Branch 5808: 1
Branch 5809: 1
Branch 5810: 1
Branch 5811: 1
Branch 5812: 1
Branch 5813: 1
Branch 5814: 1
Branch 5815: 1
Branch 5816: 1
Branch 5817: 1
Branch 5818: 1
Branch 5819: 1
Branch 5820: 1
Branch 5821: 1
Branch 5822: 1
Branch 5823: 1
Branch 5824: 1
Branch 5825: 1
Branch 5826: 1
Branch 5827: 1
Branch 5828: 1
Branch 5829: 1
Branch 5830: 1
Branch 5831: 1
Branch 5832: 1
Branch 5833: 1
Branch 5834: 1
Branch 5835: 1
Branch 5836: 1
Branch 5837: 1
Branch 5838: 1
Branch 5839: 1
Branch 5840: 1
Branch 5841: 1
Branch 5842: 1
Branch 5843: 1
Branch 5844: 1
Branch 5845: 1
Branch 5846: 1
Branch 5847: 1
Branch 5848: 1
Branch 5849: 1
Branch 5850: 1
Branch 5851: 1
Branch 5852: 1
Branch 5853: 1
Branch 5854: 1
Branch 5855: 1
Branch 5856: 1
Branch 5857: 1
Branch 5858: 1
Branch 5859: 1
Branch 5860: 1
Branch 5861: 1
Branch 5862: 1
Branch 5863: 1
Branch 5864: 1
Branch 5865: 1
Branch 5866: 1
Branch 5867: 1
Branch 5868: 1
Branch 5869: 1
Branch 5870: 1
Branch 5871: 1
Branch 5872: 1
Branch 5873: 1
Branch 5874: 1
Branch 5875: 1
Branch 5876: 1
Branch 5877: 1
Branch 5878: 1
Branch 5879: 1
Branch 5880: 1
Branch 5881: 1
Branch 5882: 1
Branch 5883: 1
Branch 5884: 1
Branch 5885: 1
Branch 5886: 1
Branch 5887: 1
Branch 5888: 1
Branch 5889: 1
Branch 5890: 1
Branch 5891: 1
Branch 5892: 1
Branch 5893: 1
Branch 5894: 1
Branch 5895: 1
Branch 5896: 1
Branch 5897: 1
Branch 5898: 1
Branch 5899: 1
Branch 5900: 1
Branch 5901: 1
Branch 5902: 1
Branch 5903: 1
Branch 5904: 1
Branch 5905: 1
Branch 5906: 1
Branch 5907: 1
Branch 5908: 1
Branch 5909: 1
Branch 5910: 1
Branch 5911: 1
Branch 5912: 1
Branch 5913: 1
Branch 5914: 1
Branch 5915: 1
Branch 5916: 1
Branch 5917: 1
Branch 5918: 1
Branch 5919: 1
Branch 5920: 1
Branch 5921: 1
Branch 5922: 1
Branch 5923: 1
Branch 5924: 1
Branch 5925: 1
Branch 5926: 1
Branch 5927: 1
Branch 5928: 1
Branch 5929: 1
Branch 5930: 1
Branch 5931: 1
Branch 5932: 1
Branch 5933: 1
Branch 5934: 1
Branch 5935: 1
Branch 5936: 1
Branch 5937: 1
Branch 5938: 1
Branch 5939: 1
Branch 5940: 1
Branch 5941: 1
Branch 5942: 1
Branch 5943: 1
Branch 5944: 1
Branch 5945: 1
Branch 5946: 1
Branch 5947: 1
Branch 5948: 1
Branch 5949: 1
Branch 5950: 1
Branch 5951: 1
Branch 5952: 1
Branch 5953: 1
Branch 5954: 1
Branch 5955: 1
Branch 5956: 1
Branch 5957: 1
Branch 5958: 1
Branch 5959: 1
Branch 5960: 1
Branch 5961: 1
Branch 5962: 1
Branch 5963: 1
Branch 5964: 1
Branch 5965: 1
Branch 5966: 1
Branch 5967: 1
Branch 5968: 1
Branch 5969: 1
Branch 5970: 1
Branch 5971: 1
Branch 5972: 1
Branch 5973: 1
Branch 5974: 1
Branch 5975: 1
Branch 5976: 1
Branch 5977: 1
Branch 5978: 1
Branch 5979: 1
Branch 5980: 1
Branch 5981: 1
Branch 5982: 1
Branch 5983: 1
Branch 5984: 1
Branch 5985: 1
Branch 5986: 1
Branch 5987: 1
Branch 5988: 1
Branch 5989: 1
Branch 5990: 1
Branch 5991: 1
Branch 5992: 1
Branch 5993: 1
Branch 5994: 1
Branch 5995: 1
Branch 5996: 1
Branch 5997: 1
Branch 5998: 1
Branch 5999: 1
Branch 6000: 1
Branch 6001: 1
Branch 6002: 1
Branch 6003: 1
Branch 6004: 1
Branch 6005: 1
Branch 6006: 1
Branch 6007: 1
Branch 6008: 1
Branch 6009: 1
Branch 6010: 1
Branch 6011: 1
Branch 6012: 1
Branch 6013: 1
Branch 6014: 1
Branch 6015: 1
Branch 6016: 1
Branch 6017: 1
Branch 6018: 1
Branch 6019: 1
Branch 6020: 1
Branch 6021: 1
Branch 6022: 1
Branch 6023: 1
Branch 6024: 1
Branch 6025: 1
Branch 6026: 1
Branch 6027: 1
Branch 6028: 1
Branch 6029: 1
Branch 6030: 1
Branch 6031: 1
Branch 6032: 1
Branch 6033: 1
Branch 6034: 1
Branch 6035: 1
Branch 6036: 1
Branch 6037: 1
Branch 6038: 1
Branch 6039: 1
Branch 6040: 1
Branch 6041: 1
Branch 6042: 1
Branch 6043: 1
Branch 6044: 1
Branch 6045: 1
Branch 6046: 1
Branch 6047: 1
Branch 6048: 1
Branch 6049: 1
Branch 6050: 1
Branch 6051: 1
Branch 6052: 1
Branch 6053: 1
Branch 6054: 1
Branch 6055: 1
Branch 6056: 1
Branch 6057: 1
Branch 6058: 1
Branch 6059: 1
Branch 6060: 1
Branch 6061: 1
Branch 6062: 1
Branch 6063: 1
Branch 6064: 1
Branch 6065: 1
Branch 6066: 1
Branch 6067: 1
Branch 6068: 1
Branch 6069: 1
Branch 6070: 1
Branch 6071: 1
Branch 6072: 1
Branch 6073: 1
Branch 6074: 1
Branch 6075: 1
Branch 6076: 1
Branch 6077: 1
Branch 6078: 1
Branch 6079: 1
Branch 6080: 1
Branch 6081: 1
Branch 6082: 1
Branch 6083: 1
Branch 6084: 1
Branch 6085: 1
Branch 6086: 1
Branch 6087: 1
Branch 6088: 1
Branch 6089: 1
Branch 6090: 1
Branch 6091: 1
Branch 6092: 1
Branch 6093: 1
Branch 6094: 1
Branch 6095: 1
Branch 6096: 1
Branch 6097: 1
Branch 6098: 1
Branch 6099: 1
Branch 6100: 1
Branch 6101: 1
Branch 6102: 1
Branch 6103: 1
Branch 6104: 1
Branch 6105: 1
Branch 6106: 1
Branch 6107: 1
Branch 6108: 1
Branch 6109: 1
Branch 6110: 1
Branch 6111: 1
Branch 6112: 1
Branch 6113: 1
Branch 6114: 1
Branch 6115: 1
Branch 6116: 1
Branch 6117: 1
Branch 6118: 1
Branch 6119: 1
Branch 6120: 1
Branch 6121: 1
Branch 6122: 1
Branch 6123: 1
Branch 6124: 1
Branch 6125: 1
Branch 6126: 1
Branch 6127: 1
Branch 6128: 1
Branch 6129: 1
Branch 6130: 1
Branch 6131: 1
Branch 6132: 1
Branch 6133: 1
Branch 6134: 1
Branch 6135: 1
Branch 6136: 1
Branch 6137: 1
Branch 6138: 1
Branch 6139: 1
Branch 6140: 1
Branch 6141: 1
Branch 6142: 1
Branch 6143: 1
Branch 6144: 1
Branch 6145: 1
Branch 6146: 1
Branch 6147: 1
Branch 6148: 1
Branch 6149: 1
Branch 6150: 1
Branch 6151: 1
Branch 6152: 1
Branch 6153: 1
Branch 6154: 1
Branch 6155: 1
Branch 6156: 1
Branch 6157: 1
Branch 6158: 1
Branch 6159: 1
Branch 6160: 1
Branch 6161: 1
Branch 6162: 1
Branch 6163: 1
Branch 6164: 1
Branch 6165: 1
Branch 6166: 1
Branch 6167: 1
Branch 6168: 1
Branch 6169: 1
Branch 6170: 1
Branch 6171: 1
Branch 6172: 1
Branch 6173: 1
Branch 6174: 1
Branch 6175: 1
Branch 6176: 1
Branch 6177: 1
Branch 6178: 1
Branch 6179: 1
Branch 6180: 1
Branch 6181: 1
Branch 6182: 1
Branch 6183: 1
Branch 6184: 1
Branch 6185: 1
Branch 6186: 1
Branch 6187: 1
Branch 6188: 1
Branch 6189: 1
Branch 6190: 1
Branch 6191: 1
Branch 6192: 1
Branch 6193: 1
Branch 6194: 1
Branch 6195: 1
Branch 6196: 1
Branch 6197: 1
Branch 6198: 1
Branch 6199: 1
Branch 6200: 1
Branch 6201: 1
Branch 6202: 1
Branch 6203: 1
Branch 6204: 1
Branch 6205: 1
Branch 6206: 1
Branch 6207: 1
Branch 6208: 1
Branch 6209: 1
Branch 6210: 1
Branch 6211: 1
Branch 6212: 1
Branch 6213: 1
Branch 6214: 1
Branch 6215: 1
Branch 6216: 1
Branch 6217: 1
Branch 6218: 1
Branch 6219: 1
Branch 6220: 1
Branch 6221: 1
Branch 6222: 1
Branch 6223: 1
Branch 6224: 1
Branch 6225: 1
Branch 6226: 1
Branch 6227: 1
Branch 6228: 1
Branch 6229: 1
Branch 6230: 1
Branch 6231: 1
Branch 6232: 1
Branch 6233: 1
Branch 6234: 1
Branch 6235: 1
Branch 6236: 1
Branch 6237: 1
Branch 6238: 1
Branch 6239: 1
Branch 6240: 1
Branch 6241: 1
Branch 6242: 1
Branch 6243: 1
Branch 6244: 1
Branch 6245: 1
Branch 6246: 1
Branch 6247: 1
Branch 6248: 1
Branch 6249: 1
Branch 6250: 1
Branch 6251: 1
Branch 6252: 1
Branch 6253: 1
Branch 6254: 1
Branch 6255: 1
Branch 6256: 1
Branch 6257: 1
Branch 6258: 1
Branch 6259: 1
Branch 6260: 1
Branch 6261: 1
Branch 6262: 1
Branch 6263: 1
Branch 6264: 1
Branch 6265: 1
Branch 6266: 1
Branch 6267: 1
Branch 6268: 1
Branch 6269: 1
Branch 6270: 1
Branch 6271: 1
Branch 6272: 1
Branch 6273: 1
Branch 6274: 1
Branch 6275: 1
Branch 6276: 1
Branch 6277: 1
Branch 6278: 1
Branch 6279: 1
Branch 6280: 1
Branch 6281: 1
Branch 6282: 1
Branch 6283: 1
Branch 6284: 1
Branch 6285: 1
Branch 6286: 1
Branch 6287: 1
Branch 6288: 1
Branch 6289: 1
Branch 6290: 1
Branch 6291: 1
Branch 6292: 1
Branch 6293: 1
Branch 6294: 1
Branch 6295: 1
Branch 6296: 1
Branch 6297: 1
Branch 6298: 1
Branch 6299: 1
Branch 6300: 1
Branch 6301: 1
Branch 6302: 1
Branch 6303: 1
Branch 6304: 1
Branch 6305: 1
Branch 6306: 1
Branch 6307: 1
Branch 6308: 1
Branch 6309: 1
Branch 6310: 1
Branch 6311: 1
Branch 6312: 1
Branch 6313: 1
Branch 6314: 1
Branch 6315: 1
Branch 6316: 1
Branch 6317: 1
Branch 6318: 1
Branch 6319: 1
Branch 6320: 1
Branch 6321: 1
Branch 6322: 1
Branch 6323: 1
Branch 6324: 1
Branch 6325: 1
Branch 6326: 1
Branch 6327: 1
Branch 6328: 1
Branch 6329: 1
Branch 6330: 1
Branch 6331: 1
Branch 6332: 1
Branch 6333: 1
Branch 6334: 1
Branch 6335: 1
Branch 6336: 1
Branch 6337: 1
Branch 6338: 1
Branch 6339: 1
Branch 6340: 1
Branch 6341: 1
Branch 6342: 1
Branch 6343: 1
Branch 6344: 1
Branch 6345: 1
Branch 6346: 1
Branch 6347: 1
Branch 6348: 1
Branch 6349: 1
Branch 6350: 1
Branch 6351: 1
Branch 6352: 1
Branch 6353: 1
Branch 6354: 1
Branch 6355: 1
Branch 6356: 1
Branch 6357: 1
Branch 6358: 1
Branch 6359: 1
Branch 6360: 1
Branch 6361: 1
Branch 6362: 1
Branch 6363: 1
Branch 6364: 1
Branch 6365: 1
Branch 6366: 1
Branch 6367: 1
Branch 6368: 1
Branch 6369: 1
Branch 6370: 1
Branch 6371: 1
Branch 6372: 1
Branch 6373: 1
Branch 6374: 1
Branch 6375: 1
Branch 6376: 1
Branch 6377: 1
Branch 6378: 1
Branch 6379: 1
Branch 6380: 1
Branch 6381: 1
Branch 6382: 1
Branch 6383: 1
Branch 6384: 1
Branch 6385: 1
Branch 6386: 1
Branch 6387: 1
Branch 6388: 1
Branch 6389: 1
Branch 6390: 1
Branch 6391: 1
Branch 6392: 1
Branch 6393: 1
Branch 6394: 1
Branch 6395: 1
Branch 6396: 1
Branch 6397: 1
Branch 6398: 1
Branch 6399: 1
Branch 6400: 1
Branch 6401: 1
Branch 6402: 1
Branch 6403: 1
Branch 6404: 1
Branch 6405: 1
Branch 6406: 1
Branch 6407: 1
Branch 6408: 1
Branch 6409: 1
Branch 6410: 1
Branch 6411: 1
Branch 6412: 1
Branch 6413: 1
Branch 6414: 1
Branch 6415: 1
Branch 6416: 1
Branch 6417: 1
Branch 6418: 1
Branch 6419: 1
Branch 6420: 1
Branch 6421: 1
Branch 6422: 1
Branch 6423: 1
Branch 6424: 1
Branch 6425: 1
Branch 6426: 1
Branch 6427: 1
Branch 6428: 1
Branch 6429: 1
Branch 6430: 1
Branch 6431: 1
Branch 6432: 1
Branch 6433: 1
Branch 6434: 1
Branch 6435: 1
Branch 6436: 1
Branch 6437: 1
Branch 6438: 1
Branch 6439: 1
Branch 6440: 1
Branch 6441: 1
Branch 6442: 1
Branch 6443: 1
Branch 6444: 1
Branch 6445: 1
Branch 6446: 1
Branch 6447: 1
Branch 6448: 1
Branch 6449: 1
Branch 6450: 1
Branch 6451: 1
Branch 6452: 1
Branch 6453: 1
Branch 6454: 1
Branch 6455: 1
Branch 6456: 1
Branch 6457: 1
Branch 6458: 1
Branch 6459: 1
Branch 6460: 1
Branch 6461: 1
Branch 6462: 1
Branch 6463: 1
Branch 6464: 1
Branch 6465: 1
Branch 6466: 1
Branch 6467: 1
Branch 6468: 1
Branch 6469: 1
Branch 6470: 1
Branch 6471: 1
Branch 6472: 1
Branch 6473: 1
Branch 6474: 1
Branch 6475: 1
Branch 6476: 1
Branch 6477: 1
Branch 6478: 1
Branch 6479: 1
Branch 6480: 1
Branch 6481: 1
Branch 6482: 1
Branch 6483: 1
Branch 6484: 1
Branch 6485: 1
Branch 6486: 1
Branch 6487: 1
Branch 6488: 1
Branch 6489: 1
Branch 6490: 1
Branch 6491: 1
Branch 6492: 1
Branch 6493: 1
Branch 6494: 1
Branch 6495: 1
Branch 6496: 1
Branch 6497: 1
Branch 6498: 1
Branch 6499: 1
Branch 6500: 1
Branch 6501: 1
Branch 6502: 1
Branch 6503: 1
Branch 6504: 1
Branch 6505: 1
Branch 6506: 1
Branch 6507: 1
Branch 6508: 1
Branch 6509: 1
Branch 6510: 1
Branch 6511: 1
Branch 6512: 1
Branch 6513: 1
Branch 6514: 1
Branch 6515: 1
Branch 6516: 1
Branch 6517: 1
Branch 6518: 1
Branch 6519: 1
Branch 6520: 1
Branch 6521: 1
Branch 6522: 1
Branch 6523: 1
Branch 6524: 1
Branch 6525: 1
Branch 6526: 1
Branch 6527: 1
Branch 6528: 1
Branch 6529: 1
Branch 6530: 1
Branch 6531: 1
Branch 6532: 1
Branch 6533: 1
Branch 6534: 1
Branch 6535: 1
Branch 6536: 1
Branch 6537: 1
Branch 6538: 1
Branch 6539: 1
Branch 6540: 1
Branch 6541: 1
Branch 6542: 1
Branch 6543: 1
Branch 6544: 1
Branch 6545: 1
Branch 6546: 1
Branch 6547: 1
Branch 6548: 1
Branch 6549: 1
Branch 6550: 1
Branch 6551: 1
Branch 6552: 1
Branch 6553: 1
Branch 6554: 1
Branch 6555: 1
Branch 6556: 1
Branch 6557: 1
Branch 6558: 1
Branch 6559: 1
Branch 6560: 1
Branch 6561: 1
Branch 6562: 1
Branch 6563: 1
Branch 6564: 1
Branch 6565: 1
Branch 6566: 1
Branch 6567: 1
Branch 6568: 1
Branch 6569: 1
Branch 6570: 1
Branch 6571: 1
Branch 6572: 1
Branch 6573: 1
Branch 6574: 1
Branch 6575: 1
Branch 6576: 1
Branch 6577: 1
Branch 6578: 1
Branch 6579: 1
Branch 6580: 1
Branch 6581: 1
Branch 6582: 1
Branch 6583: 1
Branch 6584: 1
Branch 6585: 1
Branch 6586: 1
Branch 6587: 1
Branch 6588: 1
Branch 6589: 1
Branch 6590: 1
Branch 6591: 1
Branch 6592: 1
Branch 6593: 1
Branch 6594: 1
Branch 6595: 1
Branch 6596: 1
Branch 6597: 1
Branch 6598: 1
Branch 6599: 1
Branch 6600: 1
Branch 6601: 1
Branch 6602: 1
Branch 6603: 1
Branch 6604: 1
Branch 6605: 1
Branch 6606: 1
Branch 6607: 1
Branch 6608: 1
Branch 6609: 1
Branch 6610: 1
Branch 6611: 1
Branch 6612: 1
Branch 6613: 1
Branch 6614: 1
Branch 6615: 1
Branch 6616: 1
Branch 6617: 1
Branch 6618: 1
Branch 6619: 1
Branch 6620: 1
Branch 6621: 1
Branch 6622: 1
Branch 6623: 1
Branch 6624: 1
Branch 6625: 1
Branch 6626: 1
Branch 6627: 1
Branch 6628: 1
Branch 6629: 1
Branch 6630: 1
Branch 6631: 1
Branch 6632: 1
Branch 6633: 1
Branch 6634: 1
Branch 6635: 1
Branch 6636: 1
Branch 6637: 1
Branch 6638: 1
Branch 6639: 1
Branch 6640: 1
Branch 6641: 1
Branch 6642: 1
Branch 6643: 1
Branch 6644: 1
Branch 6645: 1
Branch 6646: 1
Branch 6647: 1
Branch 6648: 1
Branch 6649: 1
Branch 6650: 1
Branch 6651: 1
Branch 6652: 1
Branch 6653: 1
Branch 6654: 1
Branch 6655: 1
Branch 6656: 1
Branch 6657: 1
Branch 6658: 1
Branch 6659: 1
Branch 6660: 1
Branch 6661: 1
Branch 6662: 1
Branch 6663: 1
Branch 6664: 1
Branch 6665: 1
Branch 6666: 1
Branch 6667: 1
Branch 6668: 1
Branch 6669: 1
Branch 6670: 1
Branch 6671: 1
Branch 6672: 1
Branch 6673: 1
Branch 6674: 1
Branch 6675: 1
Branch 6676: 1
Branch 6677: 1
Branch 6678: 1
Branch 6679: 1
Branch 6680: 1
Branch 6681: 1
Branch 6682: 1
Branch 6683: 1
Branch 6684: 1
Branch 6685: 1
Branch 6686: 1
Branch 6687: 1
Branch 6688: 1
Branch 6689: 1
Branch 6690: 1
Branch 6691: 1
Branch 6692: 1
Branch 6693: 1
Branch 6694: 1
Branch 6695: 1
Branch 6696: 1
Branch 6697: 1
Branch 6698: 1
Branch 6699: 1
Branch 6700: 1
Branch 6701: 1
Branch 6702: 1
Branch 6703: 1
Branch 6704: 1
Branch 6705: 1
Branch 6706: 1
Branch 6707: 1
Branch 6708: 1
Branch 6709: 1
Branch 6710: 1
Branch 6711: 1
Branch 6712: 1
Branch 6713: 1
Branch 6714: 1
Branch 6715: 1
Branch 6716: 1
Branch 6717: 1
Branch 6718: 1
Branch 6719: 1
Branch 6720: 1
Branch 6721: 1
Branch 6722: 1
Branch 6723: 1
Branch 6724: 1
Branch 6725: 1
Branch 6726: 1
Branch 6727: 1
Branch 6728: 1
Branch 6729: 1
Branch 6730: 1
Branch 6731: 1
Branch 6732: 1
Branch 6733: 1
Branch 6734: 1
Branch 6735: 1
Branch 6736: 1
Branch 6737: 1
Branch 6738: 1
Branch 6739: 1
Branch 6740: 1
Branch 6741: 1
Branch 6742: 1
Branch 6743: 1
Branch 6744: 1
Branch 6745: 1
Branch 6746: 1
Branch 6747: 1
Branch 6748: 1
Branch 6749: 1
Branch 6750: 1
Branch 6751: 1
Branch 6752: 1
Branch 6753: 1
Branch 6754: 1
Branch 6755: 1
Branch 6756: 1
Branch 6757: 1
Branch 6758: 1
Branch 6759: 1
Branch 6760: 1
Branch 6761: 1
Branch 6762: 1
Branch 6763: 1
Branch 6764: 1
Branch 6765: 1
Branch 6766: 1
Branch 6767: 1
Branch 6768: 1
Branch 6769: 1
Branch 6770: 1
Branch 6771: 1
Branch 6772: 1
Branch 6773: 1
Branch 6774: 1
Branch 6775: 1
Branch 6776: 1
Branch 6777: 1
Branch 6778: 1
Branch 6779: 1
Branch 6780: 1
Branch 6781: 1
Branch 6782: 1
Branch 6783: 1
Branch 6784: 1
Branch 6785: 1
Branch 6786: 1
Branch 6787: 1
Branch 6788: 1
Branch 6789: 1
Branch 6790: 1
Branch 6791: 1
Branch 6792: 1
Branch 6793: 1
Branch 6794: 1
Branch 6795: 1
Branch 6796: 1
Branch 6797: 1
Branch 6798: 1
Branch 6799: 1
Branch 6800: 1
Branch 6801: 1
Branch 6802: 1
Branch 6803: 1
Branch 6804: 1
Branch 6805: 1
Branch 6806: 1
Branch 6807: 1
Branch 6808: 1
Branch 6809: 1
Branch 6810: 1
Branch 6811: 1
Branch 6812: 1
Branch 6813: 1
Branch 6814: 1
Branch 6815: 1
Branch 6816: 1
Branch 6817: 1
Branch 6818: 1
Branch 6819: 1
Branch 6820: 1
Branch 6821: 1
Branch 6822: 1
Branch 6823: 1
Branch 6824: 1
Branch 6825: 1
Branch 6826: 1
Branch 6827: 1
Branch 6828: 1
Branch 6829: 1
Branch 6830: 1
Branch 6831: 1
Branch 6832: 1
Branch 6833: 1
Branch 6834: 1
Branch 6835: 1
Branch 6836: 1
Branch 6837: 1
Branch 6838: 1
Branch 6839: 1
Branch 6840: 1
Branch 6841: 1
Branch 6842: 1
Branch 6843: 1
Branch 6844: 1
Branch 6845: 1
Branch 6846: 1
Branch 6847: 1
Branch 6848: 1
Branch 6849: 1
Branch 6850: 1
Branch 6851: 1
Branch 6852: 1
Branch 6853: 1
Branch 6854: 1
Branch 6855: 1
Branch 6856: 1
Branch 6857: 1
Branch 6858: 1
Branch 6859: 1
Branch 6860: 1
Branch 6861: 1
Branch 6862: 1
Branch 6863: 1
Branch 6864: 1
Branch 6865: 1
Branch 6866: 1
Branch 6867: 1
Branch 6868: 1
Branch 6869: 1
Branch 6870: 1
Branch 6871: 1
Branch 6872: 1
Branch 6873: 1
Branch 6874: 1
Branch 6875: 1
Branch 6876: 1
Branch 6877: 1
Branch 6878: 1
Branch 6879: 1
Branch 6880: 1
Branch 6881: 1
Branch 6882: 1
Branch 6883: 1
Branch 6884: 1
Branch 6885: 1
Branch 6886: 1
Branch 6887: 1
Branch 6888: 1
Branch 6889: 1
Branch 6890: 1
Branch 6891: 1
Branch 6892: 1
Branch 6893: 1
Branch 6894: 1
Branch 6895: 1
Branch 6896: 1
Branch 6897: 1
Branch 6898: 1
Branch 6899: 1
Branch 6900: 1
Branch 6901: 1
Branch 6902: 1
Branch 6903: 1
Branch 6904: 1
Branch 6905: 1
Branch 6906: 1
Branch 6907: 1
Branch 6908: 1
Branch 6909: 1
Branch 6910: 1
Branch 6911: 1
Branch 6912: 1
Branch 6913: 1
Branch 6914: 1
Branch 6915: 1
Branch 6916: 1
Branch 6917: 1
Branch 6918: 1
Branch 6919: 1
Branch 6920: 1
Branch 6921: 1
Branch 6922: 1
Branch 6923: 1
Branch 6924: 1
Branch 6925: 1
Branch 6926: 1
Branch 6927: 1
Branch 6928: 1
Branch 6929: 1
Branch 6930: 1
Branch 6931: 1
Branch 6932: 1
Branch 6933: 1
Branch 6934: 1
Branch 6935: 1
Branch 6936: 1
Branch 6937: 1
Branch 6938: 1
Branch 6939: 1
Branch 6940: 1
Branch 6941: 1
Branch 6942: 1
Branch 6943: 1
Branch 6944: 1
Branch 6945: 1
Branch 6946: 1
Branch 6947: 1
Branch 6948: 1
Branch 6949: 1
Branch 6950: 1
Branch 6951: 1
Branch 6952: 1
Branch 6953: 1
Branch 6954: 1
Branch 6955: 1
Branch 6956: 1
Branch 6957: 1
Branch 6958: 1
Branch 6959: 1
Branch 6960: 1
Branch 6961: 1
Branch 6962: 1
Branch 6963: 1
Branch 6964: 1
Branch 6965: 1
Branch 6966: 1
Branch 6967: 1
Branch 6968: 1
Branch 6969: 1
Branch 6970: 1
Branch 6971: 1
Branch 6972: 1
Branch 6973: 1
Branch 6974: 1
Branch 6975: 1
Branch 6976: 1
Branch 6977: 1
Branch 6978: 1
Branch 6979: 1
Branch 6980: 1
Branch 6981: 1
Branch 6982: 1
Branch 6983: 1
Branch 6984: 1
Branch 6985: 1
Branch 6986: 1
Branch 6987: 1
Branch 6988: 1
Branch 6989: 1
Branch 6990: 1
Branch 6991: 1
Branch 6992: 1
Branch 6993: 1
Branch 6994: 1
Branch 6995: 1
Branch 6996: 1
Branch 6997: 1
Branch 6998: 1
Branch 6999: 1
Branch 7000: 1
Branch 7001: 1
Branch 7002: 1
Branch 7003: 1
Branch 7004: 1
Branch 7005: 1
Branch 7006: 1
Branch 7007: 1
Branch 7008: 1
Branch 7009: 1
Branch 7010: 1
Branch 7011: 1
Branch 7012: 1
Branch 7013: 1
Branch 7014: 1
Branch 7015: 1
Branch 7016: 1
Branch 7017: 1
Branch 7018: 1
Branch 7019: 1
Branch 7020: 1
Branch 7021: 1
Branch 7022: 1
Branch 7023: 1
Branch 7024: 1
Branch 7025: 1
Branch 7026: 1
Branch 7027: 1
Branch 7028: 1
Branch 7029: 1
Branch 7030: 1
Branch 7031: 1
Branch 7032: 1
Branch 7033: 1
Branch 7034: 1
Branch 7035: 1
Branch 7036: 1
Branch 7037: 1
Branch 7038: 1
Branch 7039: 1
Branch 7040: 1
Branch 7041: 1
Branch 7042: 1
Branch 7043: 1
Branch 7044: 1
Branch 7045: 1
Branch 7046: 1
Branch 7047: 1
Branch 7048: 1
Branch 7049: 1
Branch 7050: 1
Branch 7051: 1
Branch 7052: 1
Branch 7053: 1
Branch 7054: 1
Branch 7055: 1
Branch 7056: 1
Branch 7057: 1
Branch 7058: 1
Branch 7059: 1
Branch 7060: 1
Branch 7061: 1
Branch 7062: 1
Branch 7063: 1
Branch 7064: 1
Branch 7065: 1
Branch 7066: 1
Branch 7067: 1
Branch 7068: 1
Branch 7069: 1
Branch 7070: 1
Branch 7071: 1
Branch 7072: 1
Branch 7073: 1
Branch 7074: 1
Branch 7075: 1
Branch 7076: 1
Branch 7077: 1
Branch 7078: 1
Branch 7079: 1
Branch 7080: 1
Branch 7081: 1
Branch 7082: 1
Branch 7083: 1
Branch 7084: 1
Branch 7085: 1
Branch 7086: 1
Branch 7087: 1
Branch 7088: 1
Branch 7089: 1
Branch 7090: 1
Branch 7091: 1
Branch 7092: 1
Branch 7093: 1
Branch 7094: 1
Branch 7095: 1
Branch 7096: 1
Branch 7097: 1
Branch 7098: 1
Branch 7099: 1
Branch 7100: 1
Branch 7101: 1
Branch 7102: 1
Branch 7103: 1
Branch 7104: 1
Branch 7105: 1
Branch 7106: 1
Branch 7107: 1
Branch 7108: 1
Branch 7109: 1
Branch 7110: 1
Branch 7111: 1
Branch 7112: 1
Branch 7113: 1
Branch 7114: 1
Branch 7115: 1
Branch 7116: 1
Branch 7117: 1
Branch 7118: 1
Branch 7119: 1
Branch 7120: 1
Branch 7121: 1
Branch 7122: 1
Branch 7123: 1
Branch 7124: 1
Branch 7125: 1
Branch 7126: 1
Branch 7127: 1
Branch 7128: 1
Branch 7129: 1
Branch 7130: 1
Branch 7131: 1
Branch 7132: 1
Branch 7133: 1
Branch 7134: 1
Branch 7135: 1
Branch 7136: 1
Branch 7137: 1
Branch 7138: 1
Branch 7139: 1
Branch 7140: 1
Branch 7141: 1
Branch 7142: 1
Branch 7143: 1
Branch 7144: 1
Branch 7145: 1
Branch 7146: 1
Branch 7147: 1
Branch 7148: 1
Branch 7149: 1
Branch 7150: 1
Branch 7151: 1
Branch 7152: 1
Branch 7153: 1
Branch 7154: 1
Branch 7155: 1
Branch 7156: 1
Branch 7157: 1
Branch 7158: 1
Branch 7159: 1
Branch 7160: 1
Branch 7161: 1
Branch 7162: 1
Branch 7163: 1
Branch 7164: 1
Branch 7165: 1
Branch 7166: 1
Branch 7167: 1
Branch 7168: 1
Branch 7169: 1
Branch 7170: 1
Branch 7171: 1
Branch 7172: 1
Branch 7173: 1
Branch 7174: 1
Branch 7175: 1
Branch 7176: 1
Branch 7177: 1
Branch 7178: 1
Branch 7179: 1
Branch 7180: 1
Branch 7181: 1
Branch 7182: 1
Branch 7183: 1
Branch 7184: 1
Branch 7185: 1
Branch 7186: 1
Branch 7187: 1
Branch 7188: 1
Branch 7189: 1
Branch 7190: 1
Branch 7191: 1
Branch 7192: 1
Branch 7193: 1
Branch 7194: 1
Branch 7195: 1
Branch 7196: 1
Branch 7197: 1
Branch 7198: 1
Branch 7199: 1
Branch 7200: 1
Branch 7201: 1
Branch 7202: 1
Branch 7203: 1
Branch 7204: 1
Branch 7205: 1
Branch 7206: 1
Branch 7207: 1
Branch 7208: 1
Branch 7209: 1
Branch 7210: 1
Branch 7211: 1
Branch 7212: 1
Branch 7213: 1
Branch 7214: 1
Branch 7215: 1
Branch 7216: 1
Branch 7217: 1
Branch 7218: 1
Branch 7219: 1
Branch 7220: 1
Branch 7221: 1
Branch 7222: 1
Branch 7223: 1
Branch 7224: 1
Branch 7225: 1
Branch 7226: 1
Branch 7227: 1
Branch 7228: 1
Branch 7229: 1
Branch 7230: 1
Branch 7231: 1
Branch 7232: 1
Branch 7233: 1
Branch 7234: 1
Branch 7235: 1
Branch 7236: 1
Branch 7237: 1
Branch 7238: 1
Branch 7239: 1
Branch 7240: 1
Branch 7241: 1
Branch 7242: 1
Branch 7243: 1
Branch 7244: 1
Branch 7245: 1
Branch 7246: 1
Branch 7247: 1
Branch 7248: 1
Branch 7249: 1
Branch 7250: 1
Branch 7251: 1
Branch 7252: 1
Branch 7253: 1
Branch 7254: 1
Branch 7255: 1
Branch 7256: 1
Branch 7257: 1
Branch 7258: 1
Branch 7259: 1
Branch 7260: 1
Branch 7261: 1
Branch 7262: 1
Branch 7263: 1
Branch 7264: 1
Branch 7265: 1
Branch 7266: 1
Branch 7267: 1
Branch 7268: 1
Branch 7269: 1
Branch 7270: 1
Branch 7271: 1
Branch 7272: 1
Branch 7273: 1
Branch 7274: 1
Branch 7275: 1
Branch 7276: 1
Branch 7277: 1
Branch 7278: 1
Branch 7279: 1
Branch 7280: 1
Branch 7281: 1
Branch 7282: 1
Branch 7283: 1
Branch 7284: 1
Branch 7285: 1
Branch 7286: 1
Branch 7287: 1
Branch 7288: 1
Branch 7289: 1
Branch 7290: 1
Branch 7291: 1
Branch 7292: 1
Branch 7293: 1
Branch 7294: 1
Branch 7295: 1
Branch 7296: 1
Branch 7297: 1
Branch 7298: 1
Branch 7299: 1
Branch 7300: 1
Branch 7301: 1
Branch 7302: 1
Branch 7303: 1
Branch 7304: 1
Branch 7305: 1
Branch 7306: 1
Branch 7307: 1
Branch 7308: 1
Branch 7309: 1
Branch 7310: 1
Branch 7311: 1
Branch 7312: 1
Branch 7313: 1
Branch 7314: 1
Branch 7315: 1
Branch 7316: 1
Branch 7317: 1
Branch 7318: 1
Branch 7319: 1
Branch 7320: 1
Branch 7321: 1
Branch 7322: 1
Branch 7323: 1
Branch 7324: 1
Branch 7325: 1
Branch 7326: 1
Branch 7327: 1
Branch 7328: 1
Branch 7329: 1
Branch 7330: 1
Branch 7331: 1
Branch 7332: 1
Branch 7333: 1
Branch 7334: 1
Branch 7335: 1
Branch 7336: 1
Branch 7337: 1
Branch 7338: 1
Branch 7339: 1
Branch 7340: 1
Branch 7341: 1
Branch 7342: 1
Branch 7343: 1
Branch 7344: 1
Branch 7345: 1
Branch 7346: 1
Branch 7347: 1
Branch 7348: 1
Branch 7349: 1
Branch 7350: 1
Branch 7351: 1
Branch 7352: 1
Branch 7353: 1
Branch 7354: 1
Branch 7355: 1
Branch 7356: 1
Branch 7357: 1
Branch 7358: 1
Branch 7359: 1
Branch 7360: 1
Branch 7361: 1
Branch 7362: 1
Branch 7363: 1
Branch 7364: 1
Branch 7365: 1
Branch 7366: 1
Branch 7367: 1
Branch 7368: 1
Branch 7369: 1
Branch 7370: 1
Branch 7371: 1
Branch 7372: 1
Branch 7373: 1
Branch 7374: 1
Branch 7375: 1
Branch 7376: 1
Branch 7377: 1
Branch 7378: 1
Branch 7379: 1
Branch 7380: 1
Branch 7381: 1
Branch 7382: 1
Branch 7383: 1
Branch 7384: 1
Branch 7385: 1
Branch 7386: 1
Branch 7387: 1
Branch 7388: 1
Branch 7389: 1
Branch 7390: 1
Branch 7391: 1
Branch 7392: 1
Branch 7393: 1
Branch 7394: 1
Branch 7395: 1
Branch 7396: 1
Branch 7397: 1
Branch 7398: 1
Branch 7399: 1
Branch 7400: 1
Branch 7401: 1
Branch 7402: 1
Branch 7403: 1
Branch 7404: 1
Branch 7405: 1
Branch 7406: 1
Branch 7407: 1
Branch 7408: 1
Branch 7409: 1
Branch 7410: 1
Branch 7411: 1
Branch 7412: 1
Branch 7413: 1
Branch 7414: 1
Branch 7415: 1
Branch 7416: 1
Branch 7417: 1
Branch 7418: 1
Branch 7419: 1
Branch 7420: 1
Branch 7421: 1
Branch 7422: 1
Branch 7423: 1
Branch 7424: 1
Branch 7425: 1
Branch 7426: 1
Branch 7427: 1
Branch 7428: 1
Branch 7429: 1
Branch 7430: 1
Branch 7431: 1
Branch 7432: 1
Branch 7433: 1
Branch 7434: 1
Branch 7435: 1
Branch 7436: 1
Branch 7437: 1
Branch 7438: 1
Branch 7439: 1
Branch 7440: 1
Branch 7441: 1
Branch 7442: 1
Branch 7443: 1
Branch 7444: 1
Branch 7445: 1
Branch 7446: 1
Branch 7447: 1
Branch 7448: 1
Branch 7449: 1
Branch 7450: 1
Branch 7451: 1
Branch 7452: 1
Branch 7453: 1
Branch 7454: 1
Branch 7455: 1
Branch 7456: 1
Branch 7457: 1
Branch 7458: 1
Branch 7459: 1
Branch 7460: 1
Branch 7461: 1
Branch 7462: 1
Branch 7463: 1
Branch 7464: 1
Branch 7465: 1
Branch 7466: 1
Branch 7467: 1
Branch 7468: 1
Branch 7469: 1
Branch 7470: 1
Branch 7471: 1
Branch 7472: 1
Branch 7473: 1
Branch 7474: 1
Branch 7475: 1
Branch 7476: 1
Branch 7477: 1
Branch 7478: 1
Branch 7479: 1
Branch 7480: 1
Branch 7481: 1
Branch 7482: 1
Branch 7483: 1
Branch 7484: 1
Branch 7485: 1
Branch 7486: 1
Branch 7487: 1
Branch 7488: 1
Branch 7489: 1
Branch 7490: 1
Branch 7491: 1
Branch 7492: 1
Branch 7493: 1
Branch 7494: 1
Branch 7495: 1
Branch 7496: 1
Branch 7497: 1
Branch 7498: 1
Branch 7499: 1
Branch 7500: 1
Branch 7501: 1
Branch 7502: 1
Branch 7503: 1
Branch 7504: 1
Branch 7505: 1
Branch 7506: 1
Branch 7507: 1
Branch 7508: 1
Branch 7509: 1
Branch 7510: 1
Branch 7511: 1
Branch 7512: 1
Branch 7513: 1
Branch 7514: 1
Branch 7515: 1
Branch 7516: 1
Branch 7517: 1
Branch 7518: 1
Branch 7519: 1
Branch 7520: 1
Branch 7521: 1
Branch 7522: 1
Branch 7523: 1
Branch 7524: 1
Branch 7525: 1
Branch 7526: 1
Branch 7527: 1
Branch 7528: 1
Branch 7529: 1
Branch 7530: 1
Branch 7531: 1
Branch 7532: 1
Branch 7533: 1
Branch 7534: 1
Branch 7535: 1
Branch 7536: 1
Branch 7537: 1
Branch 7538: 1
Branch 7539: 1
Branch 7540: 1
Branch 7541: 1
Branch 7542: 1
Branch 7543: 1
Branch 7544: 1
Branch 7545: 1
Branch 7546: 1
Branch 7547: 1
Branch 7548: 1
Branch 7549: 1
Branch 7550: 1
Branch 7551: 1
Branch 7552: 1
Branch 7553: 1
Branch 7554: 1
Branch 7555: 1
Branch 7556: 1
Branch 7557: 1
Branch 7558: 1
Branch 7559: 1
Branch 7560: 1
Branch 7561: 1
Branch 7562: 1
Branch 7563: 1
Branch 7564: 1
Branch 7565: 1
Branch 7566: 1
Branch 7567: 1
Branch 7568: 1
Branch 7569: 1
Branch 7570: 1
Branch 7571: 1
Branch 7572: 1
Branch 7573: 1
Branch 7574: 1
Branch 7575: 1
Branch 7576: 1
Branch 7577: 1
Branch 7578: 1
Branch 7579: 1
Branch 7580: 1
Branch 7581: 1
Branch 7582: 1
Branch 7583: 1
Branch 7584: 1
Branch 7585: 1
Branch 7586: 1
Branch 7587: 1
Branch 7588: 1
Branch 7589: 1
Branch 7590: 1
Branch 7591: 1
Branch 7592: 1
Branch 7593: 1
Branch 7594: 1
Branch 7595: 1
Branch 7596: 1
Branch 7597: 1
Branch 7598: 1
Branch 7599: 1
Branch 7600: 1
Branch 7601: 1
Branch 7602: 1
Branch 7603: 1
Branch 7604: 1
Branch 7605: 1
Branch 7606: 1
Branch 7607: 1
Branch 7608: 1
Branch 7609: 1
Branch 7610: 1
Branch 7611: 1
Branch 7612: 1
Branch 7613: 1
Branch 7614: 1
Branch 7615: 1
Branch 7616: 1
Branch 7617: 1
Branch 7618: 1
Branch 7619: 1
Branch 7620: 1
Branch 7621: 1
Branch 7622: 1
Branch 7623: 1
Branch 7624: 1
Branch 7625: 1
Branch 7626: 1
Branch 7627: 1
Branch 7628: 1
Branch 7629: 1
Branch 7630: 1
Branch 7631: 1
Branch 7632: 1
Branch 7633: 1
Branch 7634: 1
Branch 7635: 1
Branch 7636: 1
Branch 7637: 1
Branch 7638: 1
Branch 7639: 1
Branch 7640: 1
Branch 7641: 1
Branch 7642: 1
Branch 7643: 1
Branch 7644: 1
Branch 7645: 1
Branch 7646: 1
Branch 7647: 1
Branch 7648: 1
Branch 7649: 1
Branch 7650: 1
Branch 7651: 1
Branch 7652: 1
Branch 7653: 1
Branch 7654: 1
Branch 7655: 1
Branch 7656: 1
Branch 7657: 1
Branch 7658: 1
Branch 7659: 1
Branch 7660: 1
Branch 7661: 1
Branch 7662: 1
Branch 7663: 1
Branch 7664: 1
Branch 7665: 1
Branch 7666: 1
Branch 7667: 1
Branch 7668: 1
Branch 7669: 1
Branch 7670: 1
Branch 7671: 1
Branch 7672: 1
Branch 7673: 1
Branch 7674: 1
Branch 7675: 1
Branch 7676: 1
Branch 7677: 1
Branch 7678: 1
Branch 7679: 1
Branch 7680: 1
Branch 7681: 1
Branch 7682: 1
Branch 7683: 1
Branch 7684: 1
Branch 7685: 1
Branch 7686: 1
Branch 7687: 1
Branch 7688: 1
Branch 7689: 1
Branch 7690: 1
Branch 7691: 1
Branch 7692: 1
Branch 7693: 1
Branch 7694: 1
Branch 7695: 1
Branch 7696: 1
Branch 7697: 1
Branch 7698: 1
Branch 7699: 1
Branch 7700: 1
Branch 7701: 1
Branch 7702: 1
Branch 7703: 1
Branch 7704: 1
Branch 7705: 1
Branch 7706: 1
Branch 7707: 1
Branch 7708: 1
Branch 7709: 1
Branch 7710: 1
Branch 7711: 1
Branch 7712: 1
Branch 7713: 1
Branch 7714: 1
Branch 7715: 1
Branch 7716: 1
Branch 7717: 1
Branch 7718: 1
Branch 7719: 1
Branch 7720: 1
Branch 7721: 1
Branch 7722: 1
Branch 7723: 1
Branch 7724: 1
Branch 7725: 1
Branch 7726: 1
Branch 7727: 1
Branch 7728: 1
Branch 7729: 1
Branch 7730: 1
Branch 7731: 1
Branch 7732: 1
Branch 7733: 1
Branch 7734: 1
Branch 7735: 1
Branch 7736: 1
Branch 7737: 1
Branch 7738: 1
Branch 7739: 1
Branch 7740: 1
Branch 7741: 1
Branch 7742: 1
Branch 7743: 1
Branch 7744: 1
Branch 7745: 1
Branch 7746: 1
Branch 7747: 1
Branch 7748: 1
Branch 7749: 1
Branch 7750: 1
Branch 7751: 1
Branch 7752: 1
Branch 7753: 1
Branch 7754: 1
Branch 7755: 1
Branch 7756: 1
Branch 7757: 1
Branch 7758: 1
Branch 7759: 1
Branch 7760: 1
Branch 7761: 1
Branch 7762: 1
Branch 7763: 1
Branch 7764: 1
Branch 7765: 1
Branch 7766: 1
Branch 7767: 1
Branch 7768: 1
Branch 7769: 1
Branch 7770: 1
Branch 7771: 1
Branch 7772: 1
Branch 7773: 1
Branch 7774: 1
Branch 7775: 1
Branch 7776: 1
Branch 7777: 1
Branch 7778: 1
Branch 7779: 1
Branch 7780: 1
Branch 7781: 1
Branch 7782: 1
Branch 7783: 1
Branch 7784: 1
Branch 7785: 1
Branch 7786: 1
Branch 7787: 1
Branch 7788: 1
Branch 7789: 1
Branch 7790: 1
Branch 7791: 1
Branch 7792: 1
Branch 7793: 1
Branch 7794: 1
Branch 7795: 1
Branch 7796: 1
Branch 7797: 1
Branch 7798: 1
Branch 7799: 1
Branch 7800: 1
Branch 7801: 1
Branch 7802: 1
Branch 7803: 1
Branch 7804: 1
Branch 7805: 1
Branch 7806: 1
Branch 7807: 1
Branch 7808: 1
Branch 7809: 1
Branch 7810: 1
Branch 7811: 1
Branch 7812: 1
Branch 7813: 1
Branch 7814: 1
Branch 7815: 1
Branch 7816: 1
Branch 7817: 1
Branch 7818: 1
Branch 7819: 1
Branch 7820: 1
Branch 7821: 1
Branch 7822: 1
Branch 7823: 1
Branch 7824: 1
Branch 7825: 1
Branch 7826: 1
Branch 7827: 1
Branch 7828: 1
Branch 7829: 1
Branch 7830: 1
Branch 7831: 1
Branch 7832: 1
Branch 7833: 1
Branch 7834: 1
Branch 7835: 1
Branch 7836: 1
Branch 7837: 1
Branch 7838: 1
Branch 7839: 1
Branch 7840: 1
Branch 7841: 1
Branch 7842: 1
Branch 7843: 1
Branch 7844: 1
Branch 7845: 1
Branch 7846: 1
Branch 7847: 1
Branch 7848: 1
Branch 7849: 1
Branch 7850: 1
Branch 7851: 1
Branch 7852: 1
Branch 7853: 1
Branch 7854: 1
Branch 7855: 1
Branch 7856: 1
Branch 7857: 1
Branch 7858: 1
Branch 7859: 1
Branch 7860: 1
Branch 7861: 1
Branch 7862: 1
Branch 7863: 1
Branch 7864: 1
Branch 7865: 1
Branch 7866: 1
Branch 7867: 1
Branch 7868: 1
Branch 7869: 1
Branch 7870: 1
Branch 7871: 1
Branch 7872: 1
Branch 7873: 1
Branch 7874: 1
Branch 7875: 1
Branch 7876: 1
Branch 7877: 1
Branch 7878: 1
Branch 7879: 1
Branch 7880: 1
Branch 7881: 1
Branch 7882: 1
Branch 7883: 1
Branch 7884: 1
Branch 7885: 1
Branch 7886: 1
Branch 7887: 1
Branch 7888: 1
Branch 7889: 1
Branch 7890: 1
Branch 7891: 1
Branch 7892: 1
Branch 7893: 1
Branch 7894: 1
Branch 7895: 1
Branch 7896: 1
Branch 7897: 1
Branch 7898: 1
Branch 7899: 1
Branch 7900: 1
Branch 7901: 1
Branch 7902: 1
Branch 7903: 1
Branch 7904: 1
Branch 7905: 1
Branch 7906: 1
Branch 7907: 1
Branch 7908: 1
Branch 7909: 1
Branch 7910: 1
Branch 7911: 1
Branch 7912: 1
Branch 7913: 1
Branch 7914: 1
Branch 7915: 1
Branch 7916: 1
Branch 7917: 1
Branch 7918: 1
Branch 7919: 1
Branch 7920: 1
Branch 7921: 1
Branch 7922: 1
Branch 7923: 1
Branch 7924: 1
Branch 7925: 1
Branch 7926: 1
Branch 7927: 1
Branch 7928: 1
Branch 7929: 1
Branch 7930: 1
Branch 7931: 1
Branch 7932: 1
Branch 7933: 1
Branch 7934: 1
Branch 7935: 1
Branch 7936: 1
Branch 7937: 1
Branch 7938: 1
Branch 7939: 1
Branch 7940: 1
Branch 7941: 1
Branch 7942: 1
Branch 7943: 1
Branch 7944: 1
Branch 7945: 1
Branch 7946: 1
Branch 7947: 1
Branch 7948: 1
Branch 7949: 1
Branch 7950: 1
Branch 7951: 1
Branch 7952: 1
Branch 7953: 1
Branch 7954: 1
Branch 7955: 1
Branch 7956: 1
Branch 7957: 1
Branch 7958: 1
Branch 7959: 1
Branch 7960: 1
Branch 7961: 1
Branch 7962: 1
Branch 7963: 1
Branch 7964: 1
Branch 7965: 1
Branch 7966: 1
Branch 7967: 1
Branch 7968: 1
Branch 7969: 1
Branch 7970: 1
Branch 7971: 1
Branch 7972: 1
Branch 7973: 1
Branch 7974: 1
Branch 7975: 1
Branch 7976: 1
Branch 7977: 1
Branch 7978: 1
Branch 7979: 1
Branch 7980: 1
Branch 7981: 1
Branch 7982: 1
Branch 7983: 1
Branch 7984: 1
Branch 7985: 1
Branch 7986: 1
Branch 7987: 1
Branch 7988: 1
Branch 7989: 1
Branch 7990: 1
Branch 7991: 1
Branch 7992: 1
Branch 7993: 1
Branch 7994: 1
Branch 7995: 1
Branch 7996: 1
Branch 7997: 1
Branch 7998: 1
Branch 7999: 1
Branch 8000: 1
Branch 8001: 1
Branch 8002: 1
Branch 8003: 1
Branch 8004: 1
Branch 8005: 1
Branch 8006: 1
Branch 8007: 1
Branch 8008: 1
Branch 8009: 1
Branch 8010: 1
Branch 8011: 1
Branch 8012: 1
Branch 8013: 1
Branch 8014: 1
Branch 8015: 1
Branch 8016: 1
Branch 8017: 1
Branch 8018: 1
Branch 8019: 1
Branch 8020: 1
Branch 8021: 1
Branch 8022: 1
Branch 8023: 1
Branch 8024: 1
Branch 8025: 1
Branch 8026: 1
Branch 8027: 1
Branch 8028: 1
Branch 8029: 1
Branch 8030: 1
Branch 8031: 1
Branch 8032: 1
Branch 8033: 1
Branch 8034: 1
Branch 8035: 1
Branch 8036: 1
Branch 8037: 1
Branch 8038: 1
Branch 8039: 1
Branch 8040: 1
Branch 8041: 1
Branch 8042: 1
Branch 8043: 1
Branch 8044: 1
Branch 8045: 1
Branch 8046: 1
Branch 8047: 1
Branch 8048: 1
Branch 8049: 1
Branch 8050: 1
Branch 8051: 1
Branch 8052: 1
Branch 8053: 1
Branch 8054: 1
Branch 8055: 1
Branch 8056: 1
Branch 8057: 1
Branch 8058: 1
Branch 8059: 1
Branch 8060: 1
Branch 8061: 1
Branch 8062: 1
Branch 8063: 1
Branch 8064: 1
Branch 8065: 1
Branch 8066: 1
Branch 8067: 1
Branch 8068: 1
Branch 8069: 1
Branch 8070: 1
Branch 8071: 1
Branch 8072: 1
Branch 8073: 1
Branch 8074: 1
Branch 8075: 1
Branch 8076: 1
Branch 8077: 1
Branch 8078: 1
Branch 8079: 1
Branch 8080: 1
Branch 8081: 1
Branch 8082: 1
Branch 8083: 1
Branch 8084: 1
Branch 8085: 1
Branch 8086: 1
Branch 8087: 1
Branch 8088: 1
Branch 8089: 1
Branch 8090: 1
Branch 8091: 1
Branch 8092: 1
Branch 8093: 1
Branch 8094: 1
Branch 8095: 1
Branch 8096: 1
Branch 8097: 1
Branch 8098: 1
Branch 8099: 1
Branch 8100: 1
Branch 8101: 1
Branch 8102: 1
Branch 8103: 1
Branch 8104: 1
Branch 8105: 1
Branch 8106: 1
Branch 8107: 1
Branch 8108: 1
Branch 8109: 1
Branch 8110: 1
Branch 8111: 1
Branch 8112: 1
Branch 8113: 1
Branch 8114: 1
Branch 8115: 1
Branch 8116: 1
Branch 8117: 1
Branch 8118: 1
Branch 8119: 1
Branch 8120: 1
Branch 8121: 1
Branch 8122: 1
Branch 8123: 1
Branch 8124: 1
Branch 8125: 1
Branch 8126: 1
Branch 8127: 1
Branch 8128: 1
Branch 8129: 1
Branch 8130: 1
Branch 8131: 1
Branch 8132: 1
Branch 8133: 1
Branch 8134: 1
Branch 8135: 1
Branch 8136: 1
Branch 8137: 1
Branch 8138: 1
Branch 8139: 1
Branch 8140: 1
Branch 8141: 1
Branch 8142: 1
Branch 8143: 1
Branch 8144: 1
Branch 8145: 1
Branch 8146: 1
Branch 8147: 1
Branch 8148: 1
Branch 8149: 1
Branch 8150: 1
Branch 8151: 1
Branch 8152: 1
Branch 8153: 1
Branch 8154: 1
Branch 8155: 1
Branch 8156: 1
Branch 8157: 1
Branch 8158: 1
Branch 8159: 1
Branch 8160: 1
Branch 8161: 1
Branch 8162: 1
Branch 8163: 1
Branch 8164: 1
Branch 8165: 1
Branch 8166: 1
Branch 8167: 1
Branch 8168: 1
Branch 8169: 1
Branch 8170: 1
Branch 8171: 1
Branch 8172: 1
Branch 8173: 1
Branch 8174: 1
Branch 8175: 1
Branch 8176: 1
Branch 8177: 1
Branch 8178: 1
Branch 8179: 1
Branch 8180: 1
Branch 8181: 1
Branch 8182: 1
Branch 8183: 1
Branch 8184: 1
Branch 8185: 1
Branch 8186: 1
Branch 8187: 1
Branch 8188: 1
Branch 8189: 1
Branch 8190: 1
Branch 8191: 1
Branch 8192: 1
Branch 8193: 1
Branch 8194: 1
Branch 8195: 1
Branch 8196: 1
Branch 8197: 1
Branch 8198: 1
Branch 8199: 1
Branch 8200: 1
Branch 8201: 1
Branch 8202: 1
Branch 8203: 1
Branch 8204: 1
Branch 8205: 1
Branch 8206: 1
Branch 8207: 1
Branch 8208: 1
Branch 8209: 1
Branch 8210: 1
Branch 8211: 1
Branch 8212: 1
Branch 8213: 1
Branch 8214: 1
Branch 8215: 1
Branch 8216: 1
Branch 8217: 1
Branch 8218: 1
Branch 8219: 1
Branch 8220: 1
Branch 8221: 1
Branch 8222: 1
Branch 8223: 1
Branch 8224: 1
Branch 8225: 1
Branch 8226: 1
Branch 8227: 1
Branch 8228: 1
Branch 8229: 1
Branch 8230: 1
Branch 8231: 1
Branch 8232: 1
Branch 8233: 1
Branch 8234: 1
Branch 8235: 1
Branch 8236: 1
Branch 8237: 1
Branch 8238: 1
Branch 8239: 1
Branch 8240: 1
Branch 8241: 1
Branch 8242: 1
Branch 8243: 1
Branch 8244: 1
Branch 8245: 1
Branch 8246: 1
Branch 8247: 1
Branch 8248: 1
Branch 8249: 1
Branch 8250: 1
Branch 8251: 1
Branch 8252: 1
Branch 8253: 1
Branch 8254: 1
Branch 8255: 1
Branch 8256: 1
Branch 8257: 1
Branch 8258: 1
Branch 8259: 1
Branch 8260: 1
Branch 8261: 1
Branch 8262: 1
Branch 8263: 1
Branch 8264: 1
Branch 8265: 1
Branch 8266: 1
Branch 8267: 1
Branch 8268: 1
Branch 8269: 1
Branch 8270: 1
Branch 8271: 1
Branch 8272: 1
Branch 8273: 1
Branch 8274: 1
Branch 8275: 1
Branch 8276: 1
Branch 8277: 1
Branch 8278: 1
Branch 8279: 1
Branch 8280: 1
Branch 8281: 1
Branch 8282: 1
Branch 8283: 1
Branch 8284: 1
Branch 8285: 1
Branch 8286: 1
Branch 8287: 1
Branch 8288: 1
Branch 8289: 1
Branch 8290: 1
Branch 8291: 1
Branch 8292: 1
Branch 8293: 1
Branch 8294: 1
Branch 8295: 1
Branch 8296: 1
Branch 8297: 1
Branch 8298: 1
Branch 8299: 1
Branch 8300: 1
Branch 8301: 1
Branch 8302: 1
Branch 8303: 1
Branch 8304: 1
Branch 8305: 1
Branch 8306: 1
Branch 8307: 1
Branch 8308: 1
Branch 8309: 1
Branch 8310: 1
Branch 8311: 1
Branch 8312: 1
Branch 8313: 1
Branch 8314: 1
Branch 8315: 1
Branch 8316: 1
Branch 8317: 1
Branch 8318: 1
Branch 8319: 1
Branch 8320: 1
Branch 8321: 1
Branch 8322: 1
Branch 8323: 1
Branch 8324: 1
Branch 8325: 1
Branch 8326: 1
Branch 8327: 1
Branch 8328: 1
Branch 8329: 1
Branch 8330: 1
Branch 8331: 1
Branch 8332: 1
Branch 8333: 1
Branch 8334: 1
Branch 8335: 1
Branch 8336: 1
Branch 8337: 1
Branch 8338: 1
Branch 8339: 1
Branch 8340: 1
Branch 8341: 1
Branch 8342: 1
Branch 8343: 1
Branch 8344: 1
Branch 8345: 1
Branch 8346: 1
Branch 8347: 1
Branch 8348: 1
Branch 8349: 1
Branch 8350: 1
Branch 8351: 1
Branch 8352: 1
Branch 8353: 1
Branch 8354: 1
Branch 8355: 1
Branch 8356: 1
Branch 8357: 1
Branch 8358: 1
Branch 8359: 1
Branch 8360: 1
Branch 8361: 1
Branch 8362: 1
Branch 8363: 1
Branch 8364: 1
Branch 8365: 1
Branch 8366: 1
Branch 8367: 1
Branch 8368: 1
Branch 8369: 1
Branch 8370: 1
Branch 8371: 1
Branch 8372: 1
Branch 8373: 1
Branch 8374: 1
Branch 8375: 1
Branch 8376: 1
Branch 8377: 1
Branch 8378: 1
Branch 8379: 1
Branch 8380: 1
Branch 8381: 1
Branch 8382: 1
Branch 8383: 1
Branch 8384: 1
Branch 8385: 1
Branch 8386: 1
Branch 8387: 1
Branch 8388: 1
Branch 8389: 1
Branch 8390: 1
Branch 8391: 1
Branch 8392: 1
Branch 8393: 1
Branch 8394: 1
Branch 8395: 1
Branch 8396: 1
Branch 8397: 1
Branch 8398: 1
Branch 8399: 1
Branch 8400: 1
Branch 8401: 1
Branch 8402: 1
Branch 8403: 1
Branch 8404: 1
Branch 8405: 1
Branch 8406: 1
Branch 8407: 1
Branch 8408: 1
Branch 8409: 1
Branch 8410: 1
Branch 8411: 1
Branch 8412: 1
Branch 8413: 1
Branch 8414: 1
Branch 8415: 1
Branch 8416: 1
Branch 8417: 1
Branch 8418: 1
Branch 8419: 1
Branch 8420: 1
Branch 8421: 1
Branch 8422: 1
Branch 8423: 1
Branch 8424: 1
Branch 8425: 1
Branch 8426: 1
Branch 8427: 1
Branch 8428: 1
Branch 8429: 1
Branch 8430: 1
Branch 8431: 1
Branch 8432: 1
Branch 8433: 1
Branch 8434: 1
Branch 8435: 1
Branch 8436: 1
Branch 8437: 1
Branch 8438: 1
Branch 8439: 1
Branch 8440: 1
Branch 8441: 1
Branch 8442: 1
Branch 8443: 1
Branch 8444: 1
Branch 8445: 1
Branch 8446: 1
Branch 8447: 1
Branch 8448: 1
Branch 8449: 1
Branch 8450: 1
Branch 8451: 1
Branch 8452: 1
Branch 8453: 1
Branch 8454: 1
Branch 8455: 1
Branch 8456: 1
Branch 8457: 1
Branch 8458: 1
Branch 8459: 1
Branch 8460: 1
Branch 8461: 1
Branch 8462: 1
Branch 8463: 1
Branch 8464: 1
Branch 8465: 1
Branch 8466: 1
Branch 8467: 1
Branch 8468: 1
Branch 8469: 1
Branch 8470: 1
Branch 8471: 1
Branch 8472: 1
Branch 8473: 1
Branch 8474: 1
Branch 8475: 1
Branch 8476: 1
Branch 8477: 1
Branch 8478: 1
Branch 8479: 1
Branch 8480: 1
Branch 8481: 1
Branch 8482: 1
Branch 8483: 1
Branch 8484: 1
Branch 8485: 1
Branch 8486: 1
Branch 8487: 1
Branch 8488: 1
Branch 8489: 1
Branch 8490: 1
Branch 8491: 1
Branch 8492: 1
Branch 8493: 1
Branch 8494: 1
Branch 8495: 1
Branch 8496: 1
Branch 8497: 1
Branch 8498: 1
Branch 8499: 1
Branch 8500: 1
Branch 8501: 1
Branch 8502: 1
Branch 8503: 1
Branch 8504: 1
Branch 8505: 1
Branch 8506: 1
Branch 8507: 1
Branch 8508: 1
Branch 8509: 1
Branch 8510: 1
Branch 8511: 1
Branch 8512: 1
Branch 8513: 1
Branch 8514: 1
Branch 8515: 1
Branch 8516: 1
Branch 8517: 1
Branch 8518: 1
Branch 8519: 1
Branch 8520: 1
Branch 8521: 1
Branch 8522: 1
Branch 8523: 1
Branch 8524: 1
Branch 8525: 1
Branch 8526: 1
Branch 8527: 1
Branch 8528: 1
Branch 8529: 1
Branch 8530: 1
Branch 8531: 1
Branch 8532: 1
Branch 8533: 1
Branch 8534: 1
Branch 8535: 1
Branch 8536: 1
Branch 8537: 1
Branch 8538: 1
Branch 8539: 1
Branch 8540: 1
Branch 8541: 1
Branch 8542: 1
Branch 8543: 1
Branch 8544: 1
Branch 8545: 1
Branch 8546: 1
Branch 8547: 1
Branch 8548: 1
Branch 8549: 1
Branch 8550: 1
Branch 8551: 1
Branch 8552: 1
Branch 8553: 1
Branch 8554: 1
Branch 8555: 1
Branch 8556: 1
Branch 8557: 1
Branch 8558: 1
Branch 8559: 1
Branch 8560: 1
Branch 8561: 1
Branch 8562: 1
Branch 8563: 1
Branch 8564: 1
Branch 8565: 1
Branch 8566: 1
Branch 8567: 1
Branch 8568: 1
Branch 8569: 1
Branch 8570: 1
Branch 8571: 1
Branch 8572: 1
Branch 8573: 1
Branch 8574: 1
Branch 8575: 1
Branch 8576: 1
Branch 8577: 1
Branch 8578: 1
Branch 8579: 1
Branch 8580: 1
Branch 8581: 1
Branch 8582: 1
Branch 8583: 1
Branch 8584: 1
Branch 8585: 1
Branch 8586: 1
Branch 8587: 1
Branch 8588: 1
Branch 8589: 1
Branch 8590: 1
Branch 8591: 1
Branch 8592: 1
Branch 8593: 1
Branch 8594: 1
Branch 8595: 1
Branch 8596: 1
Branch 8597: 1
Branch 8598: 1
Branch 8599: 1
Branch 8600: 1
Branch 8601: 1
Branch 8602: 1
Branch 8603: 1
Branch 8604: 1
Branch 8605: 1
Branch 8606: 1
Branch 8607: 1
Branch 8608: 1
Branch 8609: 1
Branch 8610: 1
Branch 8611: 1
Branch 8612: 1
Branch 8613: 1
Branch 8614: 1
Branch 8615: 1
Branch 8616: 1
Branch 8617: 1
Branch 8618: 1
Branch 8619: 1
Branch 8620: 1
Branch 8621: 1
Branch 8622: 1
Branch 8623: 1
Branch 8624: 1
Branch 8625: 1
Branch 8626: 1
Branch 8627: 1
Branch 8628: 1
Branch 8629: 1
Branch 8630: 1
Branch 8631: 1
Branch 8632: 1
Branch 8633: 1
Branch 8634: 1
Branch 8635: 1
Branch 8636: 1
Branch 8637: 1
Branch 8638: 1
Branch 8639: 1
Branch 8640: 1
Branch 8641: 1
Branch 8642: 1
Branch 8643: 1
Branch 8644: 1
Branch 8645: 1
Branch 8646: 1
Branch 8647: 1
Branch 8648: 1
Branch 8649: 1
Branch 8650: 1
Branch 8651: 1
Branch 8652: 1
Branch 8653: 1
Branch 8654: 1
Branch 8655: 1
Branch 8656: 1
Branch 8657: 1
Branch 8658: 1
Branch 8659: 1
Branch 8660: 1
Branch 8661: 1
Branch 8662: 1
Branch 8663: 1
Branch 8664: 1
Branch 8665: 1
Branch 8666: 1
Branch 8667: 1
Branch 8668: 1
Branch 8669: 1
Branch 8670: 1
Branch 8671: 1
Branch 8672: 1
Branch 8673: 1
Branch 8674: 1
Branch 8675: 1
Branch 8676: 1
Branch 8677: 1
Branch 8678: 1
Branch 8679: 1
Branch 8680: 1
Branch 8681: 1
Branch 8682: 1
Branch 8683: 1
Branch 8684: 1
Branch 8685: 1
Branch 8686: 1
Branch 8687: 1
Branch 8688: 1
Branch 8689: 1
Branch 8690: 1
Branch 8691: 1
Branch 8692: 1
Branch 8693: 1
Branch 8694: 1
Branch 8695: 1
Branch 8696: 1
Branch 8697: 1
Branch 8698: 1
Branch 8699: 1
Branch 8700: 1
Branch 8701: 1
Branch 8702: 1
Branch 8703: 1
Branch 8704: 1
Branch 8705: 1
Branch 8706: 1
Branch 8707: 1
Branch 8708: 1
Branch 8709: 1
Branch 8710: 1
Branch 8711: 1
Branch 8712: 1
Branch 8713: 1
Branch 8714: 1
Branch 8715: 1
Branch 8716: 1
Branch 8717: 1
Branch 8718: 1
Branch 8719: 1
Branch 8720: 1
Branch 8721: 1
Branch 8722: 1
Branch 8723: 1
Branch 8724: 1
Branch 8725: 1
Branch 8726: 1
Branch 8727: 1
Branch 8728: 1
Branch 8729: 1
Branch 8730: 1
Branch 8731: 1
Branch 8732: 1
Branch 8733: 1
Branch 8734: 1
Branch 8735: 1
Branch 8736: 1
Branch 8737: 1
Branch 8738: 1
Branch 8739: 1
Branch 8740: 1
Branch 8741: 1
Branch 8742: 1
Branch 8743: 1
Branch 8744: 1
Branch 8745: 1
Branch 8746: 1
Branch 8747: 1
Branch 8748: 1
Branch 8749: 1
Branch 8750: 1
Branch 8751: 1
Branch 8752: 1
Branch 8753: 1
Branch 8754: 1
Branch 8755: 1
Branch 8756: 1
Branch 8757: 1
Branch 8758: 1
Branch 8759: 1
Branch 8760: 1
Branch 8761: 1
Branch 8762: 1
Branch 8763: 1
Branch 8764: 1
Branch 8765: 1
Branch 8766: 1
Branch 8767: 1
Branch 8768: 1
Branch 8769: 1
Branch 8770: 1
Branch 8771: 1
Branch 8772: 1
Branch 8773: 1
Branch 8774: 1
Branch 8775: 1
Branch 8776: 1
Branch 8777: 1
Branch 8778: 1
Branch 8779: 1
Branch 8780: 1
Branch 8781: 1
Branch 8782: 1
Branch 8783: 1
Branch 8784: 1
Branch 8785: 1
Branch 8786: 1
Branch 8787: 1
Branch 8788: 1
Branch 8789: 1
Branch 8790: 1
Branch 8791: 1
Branch 8792: 1
Branch 8793: 1
Branch 8794: 1
Branch 8795: 1
Branch 8796: 1
Branch 8797: 1
Branch 8798: 1
Branch 8799: 1
Branch 8800: 1
Branch 8801: 1
Branch 8802: 1
Branch 8803: 1
Branch 8804: 1
Branch 8805: 1
Branch 8806: 1
Branch 8807: 1
Branch 8808: 1
Branch 8809: 1
Branch 8810: 1
Branch 8811: 1
Branch 8812: 1
Branch 8813: 1
Branch 8814: 1
Branch 8815: 1
Branch 8816: 1
Branch 8817: 1
Branch 8818: 1
Branch 8819: 1
Branch 8820: 1
Branch 8821: 1
Branch 8822: 1
Branch 8823: 1
Branch 8824: 1
Branch 8825: 1
Branch 8826: 1
Branch 8827: 1
Branch 8828: 1
Branch 8829: 1
Branch 8830: 1
Branch 8831: 1
Branch 8832: 1
Branch 8833: 1
Branch 8834: 1
Branch 8835: 1
Branch 8836: 1
Branch 8837: 1
Branch 8838: 1
Branch 8839: 1
Branch 8840: 1
Branch 8841: 1
Branch 8842: 1
Branch 8843: 1
Branch 8844: 1
Branch 8845: 1
Branch 8846: 1
Branch 8847: 1
Branch 8848: 1
Branch 8849: 1
Branch 8850: 1
Branch 8851: 1
Branch 8852: 1
Branch 8853: 1
Branch 8854: 1
Branch 8855: 1
Branch 8856: 1
Branch 8857: 1
Branch 8858: 1
Branch 8859: 1
Branch 8860: 1
Branch 8861: 1
Branch 8862: 1
Branch 8863: 1
Branch 8864: 1
Branch 8865: 1
Branch 8866: 1
Branch 8867: 1
Branch 8868: 1
Branch 8869: 1
Branch 8870: 1
Branch 8871: 1
Branch 8872: 1
Branch 8873: 1
Branch 8874: 1
Branch 8875: 1
Branch 8876: 1
Branch 8877: 1
Branch 8878: 1
Branch 8879: 1
Branch 8880: 1
Branch 8881: 1
Branch 8882: 1
Branch 8883: 1
Branch 8884: 1
Branch 8885: 1
Branch 8886: 1
Branch 8887: 1
Branch 8888: 1
Branch 8889: 1
Branch 8890: 1
Branch 8891: 1
Branch 8892: 1
Branch 8893: 1
Branch 8894: 1
Branch 8895: 1
Branch 8896: 1
Branch 8897: 1
Branch 8898: 1
Branch 8899: 1
Branch 8900: 1
Branch 8901: 1
Branch 8902: 1
Branch 8903: 1
Branch 8904: 1
Branch 8905: 1
Branch 8906: 1
Branch 8907: 1
Branch 8908: 1
Branch 8909: 1
Branch 8910: 1
Branch 8911: 1
Branch 8912: 1
Branch 8913: 1
Branch 8914: 1
Branch 8915: 1
Branch 8916: 1
Branch 8917: 1
Branch 8918: 1
Branch 8919: 1
Branch 8920: 1
Branch 8921: 1
Branch 8922: 1
Branch 8923: 1
Branch 8924: 1
Branch 8925: 1
Branch 8926: 1
Branch 8927: 1
Branch 8928: 1
Branch 8929: 1
Branch 8930: 1
Branch 8931: 1
Branch 8932: 1
Branch 8933: 1
Branch 8934: 1
Branch 8935: 1
Branch 8936: 1
Branch 8937: 1
Branch 8938: 1
Branch 8939: 1
Branch 8940: 1
Branch 8941: 1
Branch 8942: 1
Branch 8943: 1
Branch 8944: 1
Branch 8945: 1
Branch 8946: 1
Branch 8947: 1
Branch 8948: 1
Branch 8949: 1
Branch 8950: 1
Branch 8951: 1
Branch 8952: 1
Branch 8953: 1
Branch 8954: 1
Branch 8955: 1
Branch 8956: 1
Branch 8957: 1
Branch 8958: 1
Branch 8959: 1
Branch 8960: 1
Branch 8961: 1
Branch 8962: 1
Branch 8963: 1
Branch 8964: 1
Branch 8965: 1
Branch 8966: 1
Branch 8967: 1
Branch 8968: 1
Branch 8969: 1
Branch 8970: 1
Branch 8971: 1
Branch 8972: 1
Branch 8973: 1
Branch 8974: 1
Branch 8975: 1
Branch 8976: 1
Branch 8977: 1
Branch 8978: 1
Branch 8979: 1
Branch 8980: 1
Branch 8981: 1
Branch 8982: 1
Branch 8983: 1
Branch 8984: 1
Branch 8985: 1
Branch 8986: 1
Branch 8987: 1
Branch 8988: 1
Branch 8989: 1
Branch 8990: 1
Branch 8991: 1
Branch 8992: 1
Branch 8993: 1
Branch 8994: 1
Branch 8995: 1
Branch 8996: 1
Branch 8997: 1
Branch 8998: 1
Branch 8999: 1
Branch 9000: 1
Branch 9001: 1
Branch 9002: 1
Branch 9003: 1
Branch 9004: 1
Branch 9005: 1
Branch 9006: 1
Branch 9007: 1
Branch 9008: 1
Branch 9009: 1
Branch 9010: 1
Branch 9011: 1
Branch 9012: 1
Branch 9013: 1
Branch 9014: 1
Branch 9015: 1
Branch 9016: 1
Branch 9017: 1
Branch 9018: 1
Branch 9019: 1
Branch 9020: 1
Branch 9021: 1
Branch 9022: 1
Branch 9023: 1
Branch 9024: 1
Branch 9025: 1
Branch 9026: 1
Branch 9027: 1
Branch 9028: 1
Branch 9029: 1
Branch 9030: 1
Branch 9031: 1
Branch 9032: 1
Branch 9033: 1
Branch 9034: 1
Branch 9035: 1
Branch 9036: 1
Branch 9037: 1
Branch 9038: 1
Branch 9039: 1
Branch 9040: 1
Branch 9041: 1
Branch 9042: 1
Branch 9043: 1
Branch 9044: 1
Branch 9045: 1
Branch 9046: 1
Branch 9047: 1
Branch 9048: 1
Branch 9049: 1
Branch 9050: 1
Branch 9051: 1
Branch 9052: 1
Branch 9053: 1
Branch 9054: 1
Branch 9055: 1
Branch 9056: 1
Branch 9057: 1
Branch 9058: 1
Branch 9059: 1
Branch 9060: 1
Branch 9061: 1
Branch 9062: 1
Branch 9063: 1
Branch 9064: 1
Branch 9065: 1
Branch 9066: 1
Branch 9067: 1
Branch 9068: 1
Branch 9069: 1
Branch 9070: 1
Branch 9071: 1
Branch 9072: 1
Branch 9073: 1
Branch 9074: 1
Branch 9075: 1
Branch 9076: 1
Branch 9077: 1
Branch 9078: 1
Branch 9079: 1
Branch 9080: 1
Branch 9081: 1
Branch 9082: 1
Branch 9083: 1
Branch 9084: 1
Branch 9085: 1
Branch 9086: 1
Branch 9087: 1
Branch 9088: 1
Branch 9089: 1
Branch 9090: 1
Branch 9091: 1
Branch 9092: 1
Branch 9093: 1
Branch 9094: 1
Branch 9095: 1
Branch 9096: 1
Branch 9097: 1
Branch 9098: 1
Branch 9099: 1
Branch 9100: 1
Branch 9101: 1
Branch 9102: 1
Branch 9103: 1
Branch 9104: 1
Branch 9105: 1
Branch 9106: 1
Branch 9107: 1
Branch 9108: 1
Branch 9109: 1
Branch 9110: 1
Branch 9111: 1
Branch 9112: 1
Branch 9113: 1
Branch 9114: 1
Branch 9115: 1
Branch 9116: 1
Branch 9117: 1
Branch 9118: 1
Branch 9119: 1
Branch 9120: 1
Branch 9121: 1
Branch 9122: 1
Branch 9123: 1
Branch 9124: 1
Branch 9125: 1
Branch 9126: 1
Branch 9127: 1
Branch 9128: 1
Branch 9129: 1
Branch 9130: 1
Branch 9131: 1
Branch 9132: 1
Branch 9133: 1
Branch 9134: 1
Branch 9135: 1
Branch 9136: 1
Branch 9137: 1
Branch 9138: 1
Branch 9139: 1
Branch 9140: 1
Branch 9141: 1
Branch 9142: 1
Branch 9143: 1
Branch 9144: 1
Branch 9145: 1
Branch 9146: 1
Branch 9147: 1
Branch 9148: 1
Branch 9149: 1
Branch 9150: 1
Branch 9151: 1
Branch 9152: 1
Branch 9153: 1
Branch 9154: 1
Branch 9155: 1
Branch 9156: 1
Branch 9157: 1
Branch 9158: 1
Branch 9159: 1
Branch 9160: 1
Branch 9161: 1
Branch 9162: 1
Branch 9163: 1
Branch 9164: 1
Branch 9165: 1
Branch 9166: 1
Branch 9167: 1
Branch 9168: 1
Branch 9169: 1
Branch 9170: 1
Branch 9171: 1
Branch 9172: 1
Branch 9173: 1
Branch 9174: 1
Branch 9175: 1
Branch 9176: 1
Branch 9177: 1
Branch 9178: 1
Branch 9179: 1
Branch 9180: 1
Branch 9181: 1
Branch 9182: 1
Branch 9183: 1
Branch 9184: 1
Branch 9185: 1
Branch 9186: 1
Branch 9187: 1
Branch 9188: 1
Branch 9189: 1
Branch 9190: 1
Branch 9191: 1
Branch 9192: 1
Branch 9193: 1
Branch 9194: 1
Branch 9195: 1
Branch 9196: 1
Branch 9197: 1
Branch 9198: 1
Branch 9199: 1
Branch 9200: 1
Branch 9201: 1
Branch 9202: 1
Branch 9203: 1
Branch 9204: 1
Branch 9205: 1
Branch 9206: 1
Branch 9207: 1
Branch 9208: 1
Branch 9209: 1
Branch 9210: 1
Branch 9211: 1
Branch 9212: 1
Branch 9213: 1
Branch 9214: 1
Branch 9215: 1
Branch 9216: 1
Branch 9217: 1
Branch 9218: 1
Branch 9219: 1
Branch 9220: 1
Branch 9221: 1
Branch 9222: 1
Branch 9223: 1
Branch 9224: 1
Branch 9225: 1
Branch 9226: 1
Branch 9227: 1
Branch 9228: 1
Branch 9229: 1
Branch 9230: 1
Branch 9231: 1
Branch 9232: 1
Branch 9233: 1
Branch 9234: 1
Branch 9235: 1
Branch 9236: 1
Branch 9237: 1
Branch 9238: 1
Branch 9239: 1
Branch 9240: 1
Branch 9241: 1
Branch 9242: 1
Branch 9243: 1
Branch 9244: 1
Branch 9245: 1
Branch 9246: 1
Branch 9247: 1
Branch 9248: 1
Branch 9249: 1
Branch 9250: 1
Branch 9251: 1
Branch 9252: 1
Branch 9253: 1
Branch 9254: 1
Branch 9255: 1
Branch 9256: 1
Branch 9257: 1
Branch 9258: 1
Branch 9259: 1
Branch 9260: 1
Branch 9261: 1
Branch 9262: 1
Branch 9263: 1
Branch 9264: 1
Branch 9265: 1
Branch 9266: 1
Branch 9267: 1
Branch 9268: 1
Branch 9269: 1
Branch 9270: 1
Branch 9271: 1
Branch 9272: 1
Branch 9273: 1
Branch 9274: 1
Branch 9275: 1
Branch 9276: 1
Branch 9277: 1
Branch 9278: 1
Branch 9279: 1
Branch 9280: 1
Branch 9281: 1
Branch 9282: 1
Branch 9283: 1
Branch 9284: 1
Branch 9285: 1
Branch 9286: 1
Branch 9287: 1
Branch 9288: 1
Branch 9289: 1
Branch 9290: 1
Branch 9291: 1
Branch 9292: 1
Branch 9293: 1
Branch 9294: 1
Branch 9295: 1
Branch 9296: 1
Branch 9297: 1
Branch 9298: 1
Branch 9299: 1
Branch 9300: 1
Branch 9301: 1
Branch 9302: 1
Branch 9303: 1
Branch 9304: 1
Branch 9305: 1
Branch 9306: 1
Branch 9307: 1
Branch 9308: 1
Branch 9309: 1
Branch 9310: 1
Branch 9311: 1
Branch 9312: 1
Branch 9313: 1
Branch 9314: 1
Branch 9315: 1
Branch 9316: 1
Branch 9317: 1
Branch 9318: 1
Branch 9319: 1
Branch 9320: 1
Branch 9321: 1
Branch 9322: 1
Branch 9323: 1
Branch 9324: 1
Branch 9325: 1
Branch 9326: 1
Branch 9327: 1
Branch 9328: 1
Branch 9329: 1
Branch 9330: 1
Branch 9331: 1
Branch 9332: 1
Branch 9333: 1
Branch 9334: 1
Branch 9335: 1
Branch 9336: 1
Branch 9337: 1
Branch 9338: 1
Branch 9339: 1
Branch 9340: 1
Branch 9341: 1
Branch 9342: 1
Branch 9343: 1
Branch 9344: 1
Branch 9345: 1
Branch 9346: 1
Branch 9347: 1
Branch 9348: 1
Branch 9349: 1
Branch 9350: 1
Branch 9351: 1
Branch 9352: 1
Branch 9353: 1
Branch 9354: 1
Branch 9355: 1
Branch 9356: 1
Branch 9357: 1
Branch 9358: 1
Branch 9359: 1
Branch 9360: 1
Branch 9361: 1
Branch 9362: 1
Branch 9363: 1
Branch 9364: 1
Branch 9365: 1
Branch 9366: 1
Branch 9367: 1
Branch 9368: 1
Branch 9369: 1
Branch 9370: 1
Branch 9371: 1
Branch 9372: 1
Branch 9373: 1
Branch 9374: 1
Branch 9375: 1
Branch 9376: 1
Branch 9377: 1
Branch 9378: 1
Branch 9379: 1
Branch 9380: 1
Branch 9381: 1
Branch 9382: 1
Branch 9383: 1
Branch 9384: 1
Branch 9385: 1
Branch 9386: 1
Branch 9387: 1
Branch 9388: 1
Branch 9389: 1
Branch 9390: 1
Branch 9391: 1
Branch 9392: 1
Branch 9393: 1
Branch 9394: 1
Branch 9395: 1
Branch 9396: 1
Branch 9397: 1
Branch 9398: 1
Branch 9399: 1
Branch 9400: 1
Branch 9401: 1
Branch 9402: 1
Branch 9403: 1
Branch 9404: 1
Branch 9405: 1
Branch 9406: 1
Branch 9407: 1
Branch 9408: 1
Branch 9409: 1
Branch 9410: 1
Branch 9411: 1
Branch 9412: 1
Branch 9413: 1
Branch 9414: 1
Branch 9415: 1
Branch 9416: 1
Branch 9417: 1
Branch 9418: 1
Branch 9419: 1
Branch 9420: 1
Branch 9421: 1
Branch 9422: 1
Branch 9423: 1
Branch 9424: 1
Branch 9425: 1
Branch 9426: 1
Branch 9427: 1
Branch 9428: 1
Branch 9429: 1
Branch 9430: 1
Branch 9431: 1
Branch 9432: 1
Branch 9433: 1
Branch 9434: 1
Branch 9435: 1
Branch 9436: 1
Branch 9437: 1
Branch 9438: 1
Branch 9439: 1
Branch 9440: 1
Branch 9441: 1
Branch 9442: 1
Branch 9443: 1
Branch 9444: 1
Branch 9445: 1
Branch 9446: 1
Branch 9447: 1
Branch 9448: 1
Branch 9449: 1
Branch 9450: 1
Branch 9451: 1
Branch 9452: 1
Branch 9453: 1
Branch 9454: 1
Branch 9455: 1
Branch 9456: 1
Branch 9457: 1
Branch 9458: 1
Branch 9459: 1
Branch 9460: 1
Branch 9461: 1
Branch 9462: 1
Branch 9463: 1
Branch 9464: 1
Branch 9465: 1
Branch 9466: 1
Branch 9467: 1
Branch 9468: 1
Branch 9469: 1
Branch 9470: 1
Branch 9471: 1
Branch 9472: 1
Branch 9473: 1
Branch 9474: 1
Branch 9475: 1
Branch 9476: 1
Branch 9477: 1
Branch 9478: 1
Branch 9479: 1
Branch 9480: 1
Branch 9481: 1
Branch 9482: 1
Branch 9483: 1
Branch 9484: 1
Branch 9485: 1
Branch 9486: 1
Branch 9487: 1
Branch 9488: 1
Branch 9489: 1
Branch 9490: 1
Branch 9491: 1
Branch 9492: 1
Branch 9493: 1
Branch 9494: 1
Branch 9495: 1
Branch 9496: 1
Branch 9497: 1
Branch 9498: 1
Branch 9499: 1
Branch 9500: 1
Branch 9501: 1
Branch 9502: 1
Branch 9503: 1
Branch 9504: 1
Branch 9505: 1
Branch 9506: 1
Branch 9507: 1
Branch 9508: 1
Branch 9509: 1
Branch 9510: 1
Branch 9511: 1
Branch 9512: 1
Branch 9513: 1
Branch 9514: 1
Branch 9515: 1
Branch 9516: 1
Branch 9517: 1
Branch 9518: 1
Branch 9519: 1
Branch 9520: 1
Branch 9521: 1
Branch 9522: 1
Branch 9523: 1
Branch 9524: 1
Branch 9525: 1
Branch 9526: 1
Branch 9527: 1
Branch 9528: 1
Branch 9529: 1
Branch 9530: 1
Branch 9531: 1
Branch 9532: 1
Branch 9533: 1
Branch 9534: 1
Branch 9535: 1
Branch 9536: 1
Branch 9537: 1
Branch 9538: 1
Branch 9539: 1
Branch 9540: 1
Branch 9541: 1
Branch 9542: 1
Branch 9543: 1
Branch 9544: 1
Branch 9545: 1
Branch 9546: 1
Branch 9547: 1
Branch 9548: 1
Branch 9549: 1
Branch 9550: 1
Branch 9551: 1
Branch 9552: 1
Branch 9553: 1
Branch 9554: 1
Branch 9555: 1
Branch 9556: 1
Branch 9557: 1
Branch 9558: 1
Branch 9559: 1
Branch 9560: 1
Branch 9561: 1
Branch 9562: 1
Branch 9563: 1
Branch 9564: 1
Branch 9565: 1
Branch 9566: 1
Branch 9567: 1
Branch 9568: 1
Branch 9569: 1
Branch 9570: 1
Branch 9571: 1
Branch 9572: 1
Branch 9573: 1
Branch 9574: 1
Branch 9575: 1
Branch 9576: 1
Branch 9577: 1
Branch 9578: 1
Branch 9579: 1
Branch 9580: 1
Branch 9581: 1
Branch 9582: 1
Branch 9583: 1
Branch 9584: 1
Branch 9585: 1
Branch 9586: 1
Branch 9587: 1
Branch 9588: 1
Branch 9589: 1
Branch 9590: 1
Branch 9591: 1
Branch 9592: 1
Branch 9593: 1
Branch 9594: 1
Branch 9595: 1
Branch 9596: 1
Branch 9597: 1
Branch 9598: 1
Branch 9599: 1
Branch 9600: 1
Branch 9601: 1
Branch 9602: 1
Branch 9603: 1
Branch 9604: 1
Branch 9605: 1
Branch 9606: 1
Branch 9607: 1
Branch 9608: 1
Branch 9609: 1
Branch 9610: 1
Branch 9611: 1
Branch 9612: 1
Branch 9613: 1
Branch 9614: 1
Branch 9615: 1
Branch 9616: 1
Branch 9617: 1
Branch 9618: 1
Branch 9619: 1
Branch 9620: 1
Branch 9621: 1
Branch 9622: 1
Branch 9623: 1
Branch 9624: 1
Branch 9625: 1
Branch 9626: 1
Branch 9627: 1
Branch 9628: 1
Branch 9629: 1
Branch 9630: 1
Branch 9631: 1
Branch 9632: 1
Branch 9633: 1
Branch 9634: 1
Branch 9635: 1
Branch 9636: 1
Branch 9637: 1
Branch 9638: 1
Branch 9639: 1
Branch 9640: 1
Branch 9641: 1
Branch 9642: 1
Branch 9643: 1
Branch 9644: 1
Branch 9645: 1
Branch 9646: 1
Branch 9647: 1
Branch 9648: 1
Branch 9649: 1
Branch 9650: 1
Branch 9651: 1
Branch 9652: 1
Branch 9653: 1
Branch 9654: 1
Branch 9655: 1
Branch 9656: 1
Branch 9657: 1
Branch 9658: 1
Branch 9659: 1
Branch 9660: 1
Branch 9661: 1
Branch 9662: 1
Branch 9663: 1
Branch 9664: 1
Branch 9665: 1
Branch 9666: 1
Branch 9667: 1
Branch 9668: 1
Branch 9669: 1
Branch 9670: 1
Branch 9671: 1
Branch 9672: 1
Branch 9673: 1
Branch 9674: 1
Branch 9675: 1
Branch 9676: 1
Branch 9677: 1
Branch 9678: 1
Branch 9679: 1
Branch 9680: 1
Branch 9681: 1
Branch 9682: 1
Branch 9683: 1
Branch 9684: 1
Branch 9685: 1
Branch 9686: 1
Branch 9687: 1
Branch 9688: 1
Branch 9689: 1
Branch 9690: 1
Branch 9691: 1
Branch 9692: 1
Branch 9693: 1
Branch 9694: 1
Branch 9695: 1
Branch 9696: 1
Branch 9697: 1
Branch 9698: 1
Branch 9699: 1
Branch 9700: 1
Branch 9701: 1
Branch 9702: 1
Branch 9703: 1
Branch 9704: 1
Branch 9705: 1
Branch 9706: 1
Branch 9707: 1
Branch 9708: 1
Branch 9709: 1
Branch 9710: 1
Branch 9711: 1
Branch 9712: 1
Branch 9713: 1
Branch 9714: 1
Branch 9715: 1
Branch 9716: 1
Branch 9717: 1
Branch 9718: 1
Branch 9719: 1
Branch 9720: 1
Branch 9721: 1
Branch 9722: 1
Branch 9723: 1
Branch 9724: 1
Branch 9725: 1
Branch 9726: 1
Branch 9727: 1
Branch 9728: 1
Branch 9729: 1
Branch 9730: 1
Branch 9731: 1
Branch 9732: 1
Branch 9733: 1
Branch 9734: 1
Branch 9735: 1
Branch 9736: 1
Branch 9737: 1
Branch 9738: 1
Branch 9739: 1
Branch 9740: 1
Branch 9741: 1
Branch 9742: 1
Branch 9743: 1
Branch 9744: 1
Branch 9745: 1
Branch 9746: 1
Branch 9747: 1
Branch 9748: 1
Branch 9749: 1
Branch 9750: 1
Branch 9751: 1
Branch 9752: 1
Branch 9753: 1
Branch 9754: 1
Branch 9755: 1
Branch 9756: 1
Branch 9757: 1
Branch 9758: 1
Branch 9759: 1
Branch 9760: 1
Branch 9761: 1
Branch 9762: 1
Branch 9763: 1
Branch 9764: 1
Branch 9765: 1
Branch 9766: 1
Branch 9767: 1
Branch 9768: 1
Branch 9769: 1
Branch 9770: 1
Branch 9771: 1
Branch 9772: 1
Branch 9773: 1
Branch 9774: 1
Branch 9775: 1
Branch 9776: 1
Branch 9777: 1
Branch 9778: 1
Branch 9779: 1
Branch 9780: 1
Branch 9781: 1
Branch 9782: 1
Branch 9783: 1
Branch 9784: 1
Branch 9785: 1
Branch 9786: 1
Branch 9787: 1
Branch 9788: 1
Branch 9789: 1
Branch 9790: 1
Branch 9791: 1
Branch 9792: 1
Branch 9793: 1
Branch 9794: 1
Branch 9795: 1
Branch 9796: 1
Branch 9797: 1
Branch 9798: 1
Branch 9799: 1
Branch 9800: 1
Branch 9801: 1
Branch 9802: 1
Branch 9803: 1
Branch 9804: 1
Branch 9805: 1
Branch 9806: 1
Branch 9807: 1
Branch 9808: 1
Branch 9809: 1
Branch 9810: 1
Branch 9811: 1
Branch 9812: 1
Branch 9813: 1
Branch 9814: 1
Branch 9815: 1
Branch 9816: 1
Branch 9817: 1
Branch 9818: 1
Branch 9819: 1
Branch 9820: 1
Branch 9821: 1
Branch 9822: 1
Branch 9823: 1
Branch 9824: 1
Branch 9825: 1
Branch 9826: 1
Branch 9827: 1
Branch 9828: 1
Branch 9829: 1
Branch 9830: 1
Branch 9831: 1
Branch 9832: 1
Branch 9833: 1
Branch 9834: 1
Branch 9835: 1
Branch 9836: 1
Branch 9837: 1
Branch 9838: 1
Branch 9839: 1
Branch 9840: 1
Branch 9841: 1
Branch 9842: 1
Branch 9843: 1
Branch 9844: 1
Branch 9845: 1
Branch 9846: 1
Branch 9847: 1
Branch 9848: 1
Branch 9849: 1
Branch 9850: 1
Branch 9851: 1
Branch 9852: 1
Branch 9853: 1
Branch 9854: 1
Branch 9855: 1
Branch 9856: 1
Branch 9857: 1
Branch 9858: 1
Branch 9859: 1
Branch 9860: 1
Branch 9861: 1
Branch 9862: 1
Branch 9863: 1
Branch 9864: 1
Branch 9865: 1
Branch 9866: 1
Branch 9867: 1
Branch 9868: 1
Branch 9869: 1
Branch 9870: 1
Branch 9871: 1
Branch 9872: 1
Branch 9873: 1
Branch 9874: 1
Branch 9875: 1
Branch 9876: 1
Branch 9877: 1
Branch 9878: 1
Branch 9879: 1
Branch 9880: 1
Branch 9881: 1
Branch 9882: 1
Branch 9883: 1
Branch 9884: 1
Branch 9885: 1
Branch 9886: 1
Branch 9887: 1
Branch 9888: 1
Branch 9889: 1
Branch 9890: 1
Branch 9891: 1
Branch 9892: 1
Branch 9893: 1
Branch 9894: 1
Branch 9895: 1
Branch 9896: 1
Branch 9897: 1
Branch 9898: 1
Branch 9899: 1
Branch 9900: 1
Branch 9901: 1
Branch 9902: 1
Branch 9903: 1
Branch 9904: 1
Branch 9905: 1
Branch 9906: 1
Branch 9907: 1
Branch 9908: 1
Branch 9909: 1
Branch 9910: 1
Branch 9911: 1
Branch 9912: 1
Branch 9913: 1
Branch 9914: 1
Branch 9915: 1
Branch 9916: 1
Branch 9917: 1
Branch 9918: 1
Branch 9919: 1
Branch 9920: 1
Branch 9921: 1
Branch 9922: 1
Branch 9923: 1
Branch 9924: 1
Branch 9925: 1
Branch 9926: 1
Branch 9927: 1
Branch 9928: 1
Branch 9929: 1
Branch 9930: 1
Branch 9931: 1
Branch 9932: 1
Branch 9933: 1
Branch 9934: 1
Branch 9935: 1
Branch 9936: 1
Branch 9937: 1
Branch 9938: 1
Branch 9939: 1
Branch 9940: 1
Branch 9941: 1
Branch 9942: 1
Branch 9943: 1
Branch 9944: 1
Branch 9945: 1
Branch 9946: 1
Branch 9947: 1
Branch 9948: 1
Branch 9949: 1
Branch 9950: 1
Branch 9951: 1
Branch 9952: 1
Branch 9953: 1
Branch 9954: 1
Branch 9955: 1
Branch 9956: 1
Branch 9957: 1
Branch 9958: 1
Branch 9959: 1
Branch 9960: 1
Branch 9961: 1
Branch 9962: 1
Branch 9963: 1
Branch 9964: 1
Branch 9965: 1
Branch 9966: 1
Branch 9967: 1
Branch 9968: 1
Branch 9969: 1
Branch 9970: 1
Branch 9971: 1
Branch 9972: 1
Branch 9973: 1
Branch 9974: 1
Branch 9975: 1
Branch 9976: 1
Branch 9977: 1
Branch 9978: 1
Branch 9979: 1
Branch 9980: 1
Branch 9981: 1
Branch 9982: 1
Branch 9983: 1
Branch 9984: 1
Branch 9985: 1
Branch 9986: 1
Branch 9987: 1
Branch 9988: 1
Branch 9989: 1
Branch 9990: 1
Branch 9991: 1
Branch 9992: 1
Branch 9993: 1
Branch 9994: 1
Branch 9995: 1
Branch 9996: 1
Branch 9997: 1
Branch 9998: 1
Branch 9999: 1
Branch 10000: 1
Branch 10001: 1
Branch 10002: 1
Branch 10003: 1
Branch 10004: 1
Branch 10005: 1
Branch 10006: 1
Branch 10007: 1
Branch 10008: 1
Branch 10009: 1
Branch 10010: 1
Branch 10011: 1
Branch 10012: 1
Branch 10013: 1
Branch 10014: 1
Branch 10015: 1
Branch 10016: 1
Branch 10017: 1
Branch 10018: 1
Branch 10019: 1
Branch 10020: 1
Branch 10021: 1
Branch 10022: 1
Branch 10023: 1
Branch 10024: 1
Branch 10025: 1
Branch 10026: 1
Branch 10027: 1
Branch 10028: 1
Branch 10029: 1
Branch 10030: 1
Branch 10031: 1
Branch 10032: 1
Branch 10033: 1
Branch 10034: 1
Branch 10035: 1
Branch 10036: 1
Branch 10037: 1
Branch 10038: 1
Branch 10039: 1
Branch 10040: 1
Branch 10041: 1
Branch 10042: 1
Branch 10043: 1
Branch 10044: 1
Branch 10045: 1
Branch 10046: 1
Branch 10047: 1
Branch 10048: 1
Branch 10049: 1
Branch 10050: 1
Branch 10051: 1
Branch 10052: 1
Branch 10053: 1
Branch 10054: 1
Branch 10055: 1
Branch 10056: 1
Branch 10057: 1
Branch 10058: 1
Branch 10059: 1
Branch 10060: 1
Branch 10061: 1
Branch 10062: 1
Branch 10063: 1
Branch 10064: 1
Branch 10065: 1
Branch 10066: 1
Branch 10067: 1
Branch 10068: 1
Branch 10069: 1
Branch 10070: 1
Branch 10071: 1
Branch 10072: 1
Branch 10073: 1
Branch 10074: 1
Branch 10075: 1
Branch 10076: 1
Branch 10077: 1
Branch 10078: 1
Branch 10079: 1
Branch 10080: 1
Branch 10081: 1
Branch 10082: 1
Branch 10083: 1
Branch 10084: 1
Branch 10085: 1
Branch 10086: 1
Branch 10087: 1
Branch 10088: 1
Branch 10089: 1
Branch 10090: 1
Branch 10091: 1
Branch 10092: 1
Branch 10093: 1
Branch 10094: 1
Branch 10095: 1
Branch 10096: 1
Branch 10097: 1
Branch 10098: 1
Branch 10099: 1
Branch 10100: 1
Branch 10101: 1
Branch 10102: 1
Branch 10103: 1
Branch 10104: 1
Branch 10105: 1
Branch 10106: 1
Branch 10107: 1
Branch 10108: 1
Branch 10109: 1
Branch 10110: 1
Branch 10111: 1
Branch 10112: 1
Branch 10113: 1
Branch 10114: 1
Branch 10115: 1
Branch 10116: 1
Branch 10117: 1
Branch 10118: 1
Branch 10119: 1
Branch 10120: 1
Branch 10121: 1
Branch 10122: 1
Branch 10123: 1
Branch 10124: 1
Branch 10125: 1
Branch 10126: 1
Branch 10127: 1
Branch 10128: 1
Branch 10129: 1
Branch 10130: 1
Branch 10131: 1
Branch 10132: 1
Branch 10133: 1
Branch 10134: 1
Branch 10135: 1
Branch 10136: 1
Branch 10137: 1
Branch 10138: 1
Branch 10139: 1
Branch 10140: 1
Branch 10141: 1
Branch 10142: 1
Branch 10143: 1
Branch 10144: 1
Branch 10145: 1
Branch 10146: 1
Branch 10147: 1
Branch 10148: 1
Branch 10149: 1
Branch 10150: 1
Branch 10151: 1
Branch 10152: 1
Branch 10153: 1
Branch 10154: 1
Branch 10155: 1
Branch 10156: 1
Branch 10157: 1
Branch 10158: 1
Branch 10159: 1
Branch 10160: 1
Branch 10161: 1
Branch 10162: 1
Branch 10163: 1
Branch 10164: 1
Branch 10165: 1
Branch 10166: 1
Branch 10167: 1
Branch 10168: 1
Branch 10169: 1
Branch 10170: 1
Branch 10171: 1
Branch 10172: 1
Branch 10173: 1
Branch 10174: 1
Branch 10175: 1
Branch 10176: 1
Branch 10177: 1
Branch 10178: 1
Branch 10179: 1
Branch 10180: 1
Branch 10181: 1
Branch 10182: 1
Branch 10183: 1
Branch 10184: 1
Branch 10185: 1
Branch 10186: 1
Branch 10187: 1
Branch 10188: 1
Branch 10189: 1
Branch 10190: 1
Branch 10191: 1
Branch 10192: 1
Branch 10193: 1
Branch 10194: 1
Branch 10195: 1
Branch 10196: 1
Branch 10197: 1
Branch 10198: 1
Branch 10199: 1
Branch 10200: 1
Branch 10201: 1
Branch 10202: 1
Branch 10203: 1
Branch 10204: 1
Branch 10205: 1
Branch 10206: 1
Branch 10207: 1
Branch 10208: 1
Branch 10209: 1
Branch 10210: 1
Branch 10211: 1
Branch 10212: 1
Branch 10213: 1
Branch 10214: 1
Branch 10215: 1
Branch 10216: 1
Branch 10217: 1
Branch 10218: 1
Branch 10219: 1
Branch 10220: 1
Branch 10221: 1
Branch 10222: 1
Branch 10223: 1
Branch 10224: 1
Branch 10225: 1
Branch 10226: 1
Branch 10227: 1
Branch 10228: 1
Branch 10229: 1
Branch 10230: 1
Branch 10231: 1
Branch 10232: 1
Branch 10233: 1
Branch 10234: 1
Branch 10235: 1
Branch 10236: 1
Branch 10237: 1
Branch 10238: 1
Branch 10239: 1
Branch 10240: 1
Branch 10241: 1
Branch 10242: 1
Branch 10243: 1
Branch 10244: 1
Branch 10245: 1
Branch 10246: 1
Branch 10247: 1
Branch 10248: 1
Branch 10249: 1
Branch 10250: 1
Branch 10251: 1
Branch 10252: 1
Branch 10253: 1
Branch 10254: 1
Branch 10255: 1
Branch 10256: 1
Branch 10257: 1
Branch 10258: 1
Branch 10259: 1
Branch 10260: 1
Branch 10261: 1
Branch 10262: 1
Branch 10263: 1
Branch 10264: 1
Branch 10265: 1
Branch 10266: 1
Branch 10267: 1
Branch 10268: 1
Branch 10269: 1
Branch 10270: 1
Branch 10271: 1
Branch 10272: 1
Branch 10273: 1
Branch 10274: 1
Branch 10275: 1
Branch 10276: 1
Branch 10277: 1
Branch 10278: 1
Branch 10279: 1
Branch 10280: 1
Branch 10281: 1
Branch 10282: 1
Branch 10283: 1
Branch 10284: 1
Branch 10285: 1
Branch 10286: 1
Branch 10287: 1
Branch 10288: 1
Branch 10289: 1
Branch 10290: 1
Branch 10291: 1
Branch 10292: 1
Branch 10293: 1
Branch 10294: 1
Branch 10295: 1
Branch 10296: 1
Branch 10297: 1
Branch 10298: 1
Branch 10299: 1
Branch 10300: 1
Branch 10301: 1
Branch 10302: 1
Branch 10303: 1
Branch 10304: 1
Branch 10305: 1
Branch 10306: 1
Branch 10307: 1
Branch 10308: 1
Branch 10309: 1
Branch 10310: 1
Branch 10311: 1
Branch 10312: 1
Branch 10313: 1
Branch 10314: 1
Branch 10315: 1
Branch 10316: 1
Branch 10317: 1
Branch 10318: 1
Branch 10319: 1
Branch 10320: 1
Branch 10321: 1
Branch 10322: 1
Branch 10323: 1
Branch 10324: 1
Branch 10325: 1
Branch 10326: 1
Branch 10327: 1
Branch 10328: 1
Branch 10329: 1
Branch 10330: 1
Branch 10331: 1
Branch 10332: 1
Branch 10333: 1
Branch 10334: 1
Branch 10335: 1
Branch 10336: 1
Branch 10337: 1
Branch 10338: 1
Branch 10339: 1
Branch 10340: 1
Branch 10341: 1
Branch 10342: 1
Branch 10343: 1
Branch 10344: 1
Branch 10345: 1
Branch 10346: 1
Branch 10347: 1
Branch 10348: 1
Branch 10349: 1
Branch 10350: 1
Branch 10351: 1
Branch 10352: 1
Branch 10353: 1
Branch 10354: 1
Branch 10355: 1
Branch 10356: 1
Branch 10357: 1
Branch 10358: 1
Branch 10359: 1
Branch 10360: 1
Branch 10361: 1
Branch 10362: 1
Branch 10363: 1
Branch 10364: 1
Branch 10365: 1
Branch 10366: 1
Branch 10367: 1
Branch 10368: 1
Branch 10369: 1
Branch 10370: 1
Branch 10371: 1
Branch 10372: 1
Branch 10373: 1
Branch 10374: 1
Branch 10375: 1
Branch 10376: 1
Branch 10377: 1
Branch 10378: 1
Branch 10379: 1
Branch 10380: 1
Branch 10381: 1
Branch 10382: 1
Branch 10383: 1
Branch 10384: 1
Branch 10385: 1
Branch 10386: 1
Branch 10387: 1
Branch 10388: 1
Branch 10389: 1
Branch 10390: 1
Branch 10391: 1
Branch 10392: 1
Branch 10393: 1
Branch 10394: 1
Branch 10395: 1
Branch 10396: 1
Branch 10397: 1
Branch 10398: 1
Branch 10399: 1
Branch 10400: 1
Branch 10401: 1
Branch 10402: 1
Branch 10403: 1
Branch 10404: 1
Branch 10405: 1
Branch 10406: 1
Branch 10407: 1
Branch 10408: 1
Branch 10409: 1
Branch 10410: 1
Branch 10411: 1
Branch 10412: 1
Branch 10413: 1
Branch 10414: 1
Branch 10415: 1
Branch 10416: 1
Branch 10417: 1
Branch 10418: 1
Branch 10419: 1
Branch 10420: 1
Branch 10421: 1
Branch 10422: 1
Branch 10423: 1
Branch 10424: 1
Branch 10425: 1
Branch 10426: 1
Branch 10427: 1
Branch 10428: 1
Branch 10429: 1
Branch 10430: 1
Branch 10431: 1
Branch 10432: 1
Branch 10433: 1
Branch 10434: 1
Branch 10435: 1
Branch 10436: 1
Branch 10437: 1
Branch 10438: 1
Branch 10439: 1
Branch 10440: 1
Branch 10441: 1
Branch 10442: 1
Branch 10443: 1
Branch 10444: 1
Branch 10445: 1
Branch 10446: 1
Branch 10447: 1
Branch 10448: 1
Branch 10449: 1
Branch 10450: 1
Branch 10451: 1
Branch 10452: 1
Branch 10453: 1
Branch 10454: 1
Branch 10455: 1
Branch 10456: 1
Branch 10457: 1
Branch 10458: 1
Branch 10459: 1
Branch 10460: 1
Branch 10461: 1
Branch 10462: 1
Branch 10463: 1
Branch 10464: 1
Branch 10465: 1
Branch 10466: 1
Branch 10467: 1
Branch 10468: 1
Branch 10469: 1
Branch 10470: 1
Branch 10471: 1
Branch 10472: 1
Branch 10473: 1
Branch 10474: 1
Branch 10475: 1
Branch 10476: 1
Branch 10477: 1
Branch 10478: 1
Branch 10479: 1
Branch 10480: 1
Branch 10481: 1
Branch 10482: 1
Branch 10483: 1
Branch 10484: 1
Branch 10485: 1
Branch 10486: 1
Branch 10487: 1
Branch 10488: 1
Branch 10489: 1
Branch 10490: 1
Branch 10491: 1
Branch 10492: 1
Branch 10493: 1
Branch 10494: 1
Branch 10495: 1
Branch 10496: 1
Branch 10497: 1
Branch 10498: 1
Branch 10499: 1
Branch 10500: 1
Branch 10501: 1
Branch 10502: 1
Branch 10503: 1
Branch 10504: 1
Branch 10505: 1
Branch 10506: 1
Branch 10507: 1
Branch 10508: 1
Branch 10509: 1
Branch 10510: 1
Branch 10511: 1
Branch 10512: 1
Branch 10513: 1
Branch 10514: 1
Branch 10515: 1
Branch 10516: 1
Branch 10517: 1
Branch 10518: 1
Branch 10519: 1
Branch 10520: 1
Branch 10521: 1
Branch 10522: 1
Branch 10523: 1
Branch 10524: 1
Branch 10525: 1
Branch 10526: 1
Branch 10527: 1
Branch 10528: 1
Branch 10529: 1
Branch 10530: 1
Branch 10531: 1
Branch 10532: 1
Branch 10533: 1
Branch 10534: 1
Branch 10535: 1
Branch 10536: 1
Branch 10537: 1
Branch 10538: 1
Branch 10539: 1
Branch 10540: 1
Branch 10541: 1
Branch 10542: 1
Branch 10543: 1
Branch 10544: 1
Branch 10545: 1
Branch 10546: 1
Branch 10547: 1
Branch 10548: 1
Branch 10549: 1
Branch 10550: 1
Branch 10551: 1
Branch 10552: 1
Branch 10553: 1
Branch 10554: 1
Branch 10555: 1
Branch 10556: 1
Branch 10557: 1
Branch 10558: 1
Branch 10559: 1
Branch 10560: 1
Branch 10561: 1
Branch 10562: 1
Branch 10563: 1
Branch 10564: 1
Branch 10565: 1
Branch 10566: 1
Branch 10567: 1
Branch 10568: 1
Branch 10569: 1
Branch 10570: 1
Branch 10571: 1
Branch 10572: 1
Branch 10573: 1
Branch 10574: 1
Branch 10575: 1
Branch 10576: 1
Branch 10577: 1
Branch 10578: 1
Branch 10579: 1
Branch 10580: 1
Branch 10581: 1
Branch 10582: 1
Branch 10583: 1
Branch 10584: 1
Branch 10585: 1
Branch 10586: 1
Branch 10587: 1
Branch 10588: 1
Branch 10589: 1
Branch 10590: 1
Branch 10591: 1
Branch 10592: 1
Branch 10593: 1
Branch 10594: 1
Branch 10595: 1
Branch 10596: 1
Branch 10597: 1
Branch 10598: 1
Branch 10599: 1
Branch 10600: 1
Branch 10601: 1
Branch 10602: 1
Branch 10603: 1
Branch 10604: 1
Branch 10605: 1
Branch 10606: 1
Branch 10607: 1
Branch 10608: 1
Branch 10609: 1
Branch 10610: 1
Branch 10611: 1
Branch 10612: 1
Branch 10613: 1
Branch 10614: 1
Branch 10615: 1
Branch 10616: 1
Branch 10617: 1
Branch 10618: 1
Branch 10619: 1
Branch 10620: 1
Branch 10621: 1
Branch 10622: 1
Branch 10623: 1
Branch 10624: 1
Branch 10625: 1
Branch 10626: 1
Branch 10627: 1
Branch 10628: 1
Branch 10629: 1
Branch 10630: 1
Branch 10631: 1
Branch 10632: 1
Branch 10633: 1
Branch 10634: 1
Branch 10635: 1
Branch 10636: 1
Branch 10637: 1
Branch 10638: 1
Branch 10639: 1
Branch 10640: 1
Branch 10641: 1
Branch 10642: 1
Branch 10643: 1
Branch 10644: 1
Branch 10645: 1
Branch 10646: 1
Branch 10647: 1
Branch 10648: 1
Branch 10649: 1
Branch 10650: 1
Branch 10651: 1
Branch 10652: 1
Branch 10653: 1
Branch 10654: 1
Branch 10655: 1
Branch 10656: 1
Branch 10657: 1
Branch 10658: 1
Branch 10659: 1
Branch 10660: 1
Branch 10661: 1
Branch 10662: 1
Branch 10663: 1
Branch 10664: 1
Branch 10665: 1
Branch 10666: 1
Branch 10667: 1
Branch 10668: 1
Branch 10669: 1
Branch 10670: 1
Branch 10671: 1
Branch 10672: 1
Branch 10673: 1
Branch 10674: 1
Branch 10675: 1
Branch 10676: 1
Branch 10677: 1
Branch 10678: 1
Branch 10679: 1
Branch 10680: 1
Branch 10681: 1
Branch 10682: 1
Branch 10683: 1
Branch 10684: 1
Branch 10685: 1
Branch 10686: 1
Branch 10687: 1
Branch 10688: 1
Branch 10689: 1
Branch 10690: 1
Branch 10691: 1
Branch 10692: 1
Branch 10693: 1
Branch 10694: 1
Branch 10695: 1
Branch 10696: 1
Branch 10697: 1
Branch 10698: 1
Branch 10699: 1
Branch 10700: 1
Branch 10701: 1
Branch 10702: 1
Branch 10703: 1
Branch 10704: 1
Branch 10705: 1
Branch 10706: 1
Branch 10707: 1
Branch 10708: 1
Branch 10709: 1
Branch 10710: 1
Branch 10711: 1
Branch 10712: 1
Branch 10713: 1
Branch 10714: 1
Branch 10715: 1
Branch 10716: 1
Branch 10717: 1
Branch 10718: 1
Branch 10719: 1
Branch 10720: 1
Branch 10721: 1
Branch 10722: 1
Branch 10723: 1
Branch 10724: 1
Branch 10725: 1
Branch 10726: 1
Branch 10727: 1
Branch 10728: 1
Branch 10729: 1
Branch 10730: 1
Branch 10731: 1
Branch 10732: 1
Branch 10733: 1
Branch 10734: 1
Branch 10735: 1
Branch 10736: 1
Branch 10737: 1
Branch 10738: 1
Branch 10739: 1
Branch 10740: 1
Branch 10741: 1
Branch 10742: 1
Branch 10743: 1
Branch 10744: 1
Branch 10745: 1
Branch 10746: 1
Branch 10747: 1
Branch 10748: 1
Branch 10749: 1
Branch 10750: 1
Branch 10751: 1
Branch 10752: 1
Branch 10753: 1
Branch 10754: 1
Branch 10755: 1
Branch 10756: 1
Branch 10757: 1
Branch 10758: 1
Branch 10759: 1
Branch 10760: 1
Branch 10761: 1
Branch 10762: 1
Branch 10763: 1
Branch 10764: 1
Branch 10765: 1
Branch 10766: 1
Branch 10767: 1
Branch 10768: 1
Branch 10769: 1
Branch 10770: 1
Branch 10771: 1
Branch 10772: 1
Branch 10773: 1
Branch 10774: 1
Branch 10775: 1
Branch 10776: 1
Branch 10777: 1
Branch 10778: 1
Branch 10779: 1
Branch 10780: 1
Branch 10781: 1
Branch 10782: 1
Branch 10783: 1
Branch 10784: 1
Branch 10785: 1
Branch 10786: 1
Branch 10787: 1
Branch 10788: 1
Branch 10789: 1
Branch 10790: 1
Branch 10791: 1
Branch 10792: 1
Branch 10793: 1
Branch 10794: 1
Branch 10795: 1
Branch 10796: 1
Branch 10797: 1
Branch 10798: 1
Branch 10799: 1
Branch 10800: 1
Branch 10801: 1
Branch 10802: 1
Branch 10803: 1
Branch 10804: 1
Branch 10805: 1
Branch 10806: 1
Branch 10807: 1
Branch 10808: 1
Branch 10809: 1
Branch 10810: 1
Branch 10811: 1
Branch 10812: 1
Branch 10813: 1
Branch 10814: 1
Branch 10815: 1
Branch 10816: 1
Branch 10817: 1
Branch 10818: 1
Branch 10819: 1
Branch 10820: 1
Branch 10821: 1
Branch 10822: 1
Branch 10823: 1
Branch 10824: 1
Branch 10825: 1
Branch 10826: 1
Branch 10827: 1
Branch 10828: 1
Branch 10829: 1
Branch 10830: 1
Branch 10831: 1
Branch 10832: 1
Branch 10833: 1
Branch 10834: 1
Branch 10835: 1
Branch 10836: 1
Branch 10837: 1
Branch 10838: 1
Branch 10839: 1
Branch 10840: 1
Branch 10841: 1
Branch 10842: 1
Branch 10843: 1
Branch 10844: 1
Branch 10845: 1
Branch 10846: 1
Branch 10847: 1
Branch 10848: 1
Branch 10849: 1
Branch 10850: 1
Branch 10851: 1
Branch 10852: 1
Branch 10853: 1
Branch 10854: 1
Branch 10855: 1
Branch 10856: 1
Branch 10857: 1
Branch 10858: 1
Branch 10859: 1
Branch 10860: 1
Branch 10861: 1
Branch 10862: 1
Branch 10863: 1
Branch 10864: 1
Branch 10865: 1
Branch 10866: 1
Branch 10867: 1
Branch 10868: 1
Branch 10869: 1
Branch 10870: 1
Branch 10871: 1
Branch 10872: 1
Branch 10873: 1
Branch 10874: 1
Branch 10875: 1
Branch 10876: 1
Branch 10877: 1
Branch 10878: 1
Branch 10879: 1
Branch 10880: 1
Branch 10881: 1
Branch 10882: 1
Branch 10883: 1
Branch 10884: 1
Branch 10885: 1
Branch 10886: 1
Branch 10887: 1
Branch 10888: 1
Branch 10889: 1
Branch 10890: 1
Branch 10891: 1
Branch 10892: 1
Branch 10893: 1
Branch 10894: 1
Branch 10895: 1
Branch 10896: 1
Branch 10897: 1
Branch 10898: 1
Branch 10899: 1
Branch 10900: 1
Branch 10901: 1
Branch 10902: 1
Branch 10903: 1
Branch 10904: 1
Branch 10905: 1
Branch 10906: 1
Branch 10907: 1
Branch 10908: 1
Branch 10909: 1
Branch 10910: 1
Branch 10911: 1
Branch 10912: 1
Branch 10913: 1
Branch 10914: 1
Branch 10915: 1
Branch 10916: 1
Branch 10917: 1
Branch 10918: 1
Branch 10919: 1
Branch 10920: 1
Branch 10921: 1
Branch 10922: 1
Branch 10923: 1
Branch 10924: 1
Branch 10925: 1
Branch 10926: 1
Branch 10927: 1
Branch 10928: 1
Branch 10929: 1
Branch 10930: 1
Branch 10931: 1
Branch 10932: 1
Branch 10933: 1
Branch 10934: 1
Branch 10935: 1
Branch 10936: 1
Branch 10937: 1
Branch 10938: 1
Branch 10939: 1
Branch 10940: 1
Branch 10941: 1
Branch 10942: 1
Branch 10943: 1
Branch 10944: 1
Branch 10945: 1
Branch 10946: 1
Branch 10947: 1
Branch 10948: 1
Branch 10949: 1
Branch 10950: 1
Branch 10951: 1
Branch 10952: 1
Branch 10953: 1
Branch 10954: 1
Branch 10955: 1
Branch 10956: 1
Branch 10957: 1
Branch 10958: 1
Branch 10959: 1
Branch 10960: 1
Branch 10961: 1
Branch 10962: 1
Branch 10963: 1
Branch 10964: 1
Branch 10965: 1
Branch 10966: 1
Branch 10967: 1
Branch 10968: 1
Branch 10969: 1
Branch 10970: 1
Branch 10971: 1
Branch 10972: 1
Branch 10973: 1
Branch 10974: 1
Branch 10975: 1
Branch 10976: 1
Branch 10977: 1
Branch 10978: 1
Branch 10979: 1
Branch 10980: 1
Branch 10981: 1
Branch 10982: 1
Branch 10983: 1
Branch 10984: 1
Branch 10985: 1
Branch 10986: 1
Branch 10987: 1
Branch 10988: 1
Branch 10989: 1
Branch 10990: 1
Branch 10991: 1
Branch 10992: 1
Branch 10993: 1
Branch 10994: 1
Branch 10995: 1
Branch 10996: 1
Branch 10997: 1
Branch 10998: 1
Branch 10999: 1
Branch 11000: 1
Branch 11001: 1
Branch 11002: 1
Branch 11003: 1
Branch 11004: 1
Branch 11005: 1
Branch 11006: 1
Branch 11007: 1
Branch 11008: 1
Branch 11009: 1
Branch 11010: 1
Branch 11011: 1
Branch 11012: 1
Branch 11013: 1
Branch 11014: 1
Branch 11015: 1
Branch 11016: 1
Branch 11017: 1
Branch 11018: 1
Branch 11019: 1
Branch 11020: 1
Branch 11021: 1
Branch 11022: 1
Branch 11023: 1
Branch 11024: 1
Branch 11025: 1
Branch 11026: 1
Branch 11027: 1
Branch 11028: 1
Branch 11029: 1
Branch 11030: 1
Branch 11031: 1
Branch 11032: 1
Branch 11033: 1
Branch 11034: 1
Branch 11035: 1
Branch 11036: 1
Branch 11037: 1
Branch 11038: 1
Branch 11039: 1
Branch 11040: 1
Branch 11041: 1
Branch 11042: 1
Branch 11043: 1
Branch 11044: 1
Branch 11045: 1
Branch 11046: 1
Branch 11047: 1
Branch 11048: 1
Branch 11049: 1
Branch 11050: 1
Branch 11051: 1
Branch 11052: 1
Branch 11053: 1
Branch 11054: 1
Branch 11055: 1
Branch 11056: 1
Branch 11057: 1
Branch 11058: 1
Branch 11059: 1
Branch 11060: 1
Branch 11061: 1
Branch 11062: 1
Branch 11063: 1
Branch 11064: 1
Branch 11065: 1
Branch 11066: 1
Branch 11067: 1
Branch 11068: 1
Branch 11069: 1
Branch 11070: 1
Branch 11071: 1
Branch 11072: 1
Branch 11073: 1
Branch 11074: 1
Branch 11075: 1
Branch 11076: 1
Branch 11077: 1
Branch 11078: 1
Branch 11079: 1
Branch 11080: 1
Branch 11081: 1
Branch 11082: 1
Branch 11083: 1
Branch 11084: 1
Branch 11085: 1
Branch 11086: 1
Branch 11087: 1
Branch 11088: 1
Branch 11089: 1
Branch 11090: 1
Branch 11091: 1
Branch 11092: 1
Branch 11093: 1
Branch 11094: 1
Branch 11095: 1
Branch 11096: 1
Branch 11097: 1
Branch 11098: 1
Branch 11099: 1
Branch 11100: 1
Branch 11101: 1
Branch 11102: 1
Branch 11103: 1
Branch 11104: 1
Branch 11105: 1
Branch 11106: 1
Branch 11107: 1
Branch 11108: 1
Branch 11109: 1
Branch 11110: 1
Branch 11111: 1
Branch 11112: 1
Branch 11113: 1
Branch 11114: 1
Branch 11115: 1
Branch 11116: 1
Branch 11117: 1
Branch 11118: 1
Branch 11119: 1
Branch 11120: 1
Branch 11121: 1
Branch 11122: 1
Branch 11123: 1
Branch 11124: 1
Branch 11125: 1
Branch 11126: 1
Branch 11127: 1
Branch 11128: 1
Branch 11129: 1
Branch 11130: 1
Branch 11131: 1
Branch 11132: 1
Branch 11133: 1
Branch 11134: 1
Branch 11135: 1
Branch 11136: 1
Branch 11137: 1
Branch 11138: 1
Branch 11139: 1
Branch 11140: 1
Branch 11141: 1
Branch 11142: 1
Branch 11143: 1
Branch 11144: 1
Branch 11145: 1
Branch 11146: 1
Branch 11147: 1
Branch 11148: 1
Branch 11149: 1
Branch 11150: 1
Branch 11151: 1
Branch 11152: 1
Branch 11153: 1
Branch 11154: 1
Branch 11155: 1
Branch 11156: 1
Branch 11157: 1
Branch 11158: 1
Branch 11159: 1
Branch 11160: 1
Branch 11161: 1
Branch 11162: 1
Branch 11163: 1
Branch 11164: 1
Branch 11165: 1
Branch 11166: 1
Branch 11167: 1
Branch 11168: 1
Branch 11169: 1
Branch 11170: 1
Branch 11171: 1
Branch 11172: 1
Branch 11173: 1
Branch 11174: 1
Branch 11175: 1
Branch 11176: 1
Branch 11177: 1
Branch 11178: 1
Branch 11179: 1
Branch 11180: 1
Branch 11181: 1
Branch 11182: 1
Branch 11183: 1
Branch 11184: 1
Branch 11185: 1
Branch 11186: 1
Branch 11187: 1
Branch 11188: 1
Branch 11189: 1
Branch 11190: 1
Branch 11191: 1
Branch 11192: 1
Branch 11193: 1
Branch 11194: 1
Branch 11195: 1
Branch 11196: 1
Branch 11197: 1
Branch 11198: 1
Branch 11199: 1
Branch 11200: 1
Branch 11201: 1
Branch 11202: 1
Branch 11203: 1
Branch 11204: 1
Branch 11205: 1
Branch 11206: 1
Branch 11207: 1
Branch 11208: 1
Branch 11209: 1
Branch 11210: 1
Branch 11211: 1
Branch 11212: 1
Branch 11213: 1
Branch 11214: 1
Branch 11215: 1
Branch 11216: 1
Branch 11217: 1
Branch 11218: 1
Branch 11219: 1
Branch 11220: 1
Branch 11221: 1
Branch 11222: 1
Branch 11223: 1
Branch 11224: 1
Branch 11225: 1
Branch 11226: 1
Branch 11227: 1
Branch 11228: 1
Branch 11229: 1
Branch 11230: 1
Branch 11231: 1
Branch 11232: 1
Branch 11233: 1
Branch 11234: 1
Branch 11235: 1
Branch 11236: 1
Branch 11237: 1
Branch 11238: 1
Branch 11239: 1
Branch 11240: 1
Branch 11241: 1
Branch 11242: 1
Branch 11243: 1
Branch 11244: 1
Branch 11245: 1
Branch 11246: 1
Branch 11247: 1
Branch 11248: 1
Branch 11249: 1
Branch 11250: 1
Branch 11251: 1
Branch 11252: 1
Branch 11253: 1
Branch 11254: 1
Branch 11255: 1
Branch 11256: 1
Branch 11257: 1
Branch 11258: 1
Branch 11259: 1
Branch 11260: 1
Branch 11261: 1
Branch 11262: 1
Branch 11263: 1
Branch 11264: 1
Branch 11265: 1
Branch 11266: 1
Branch 11267: 1
Branch 11268: 1
Branch 11269: 1
Branch 11270: 1
Branch 11271: 1
Branch 11272: 1
Branch 11273: 1
Branch 11274: 1
Branch 11275: 1
Branch 11276: 1
Branch 11277: 1
Branch 11278: 1
Branch 11279: 1
Branch 11280: 1
Branch 11281: 1
Branch 11282: 1
Branch 11283: 1
Branch 11284: 1
Branch 11285: 1
Branch 11286: 1
Branch 11287: 1
Branch 11288: 1
Branch 11289: 1
Branch 11290: 1
Branch 11291: 1
Branch 11292: 1
Branch 11293: 1
Branch 11294: 1
Branch 11295: 1
Branch 11296: 1
Branch 11297: 1
Branch 11298: 1
Branch 11299: 1
Branch 11300: 1
Branch 11301: 1
Branch 11302: 1
Branch 11303: 1
Branch 11304: 1
Branch 11305: 1
Branch 11306: 1
Branch 11307: 1
Branch 11308: 1
Branch 11309: 1
Branch 11310: 1
Branch 11311: 1
Branch 11312: 1
Branch 11313: 1
Branch 11314: 1
Branch 11315: 1
Branch 11316: 1
Branch 11317: 1
Branch 11318: 1
Branch 11319: 1
Branch 11320: 1
Branch 11321: 1
Branch 11322: 1
Branch 11323: 1
Branch 11324: 1
Branch 11325: 1
Branch 11326: 1
Branch 11327: 1
Branch 11328: 1
Branch 11329: 1
Branch 11330: 1
Branch 11331: 1
Branch 11332: 1
Branch 11333: 1
Branch 11334: 1
Branch 11335: 1
Branch 11336: 1
Branch 11337: 1
Branch 11338: 1
Branch 11339: 1
Branch 11340: 1
Branch 11341: 1
Branch 11342: 1
Branch 11343: 1
Branch 11344: 1
Branch 11345: 1
Branch 11346: 1
Branch 11347: 1
Branch 11348: 1
Branch 11349: 1
Branch 11350: 1
Branch 11351: 1
Branch 11352: 1
Branch 11353: 1
Branch 11354: 1
Branch 11355: 1
Branch 11356: 1
Branch 11357: 1
Branch 11358: 1
Branch 11359: 1
Branch 11360: 1
Branch 11361: 1
Branch 11362: 1
Branch 11363: 1
Branch 11364: 1
Branch 11365: 1
Branch 11366: 1
Branch 11367: 1
Branch 11368: 1
Branch 11369: 1
Branch 11370: 1
Branch 11371: 1
Branch 11372: 1
Branch 11373: 1
Branch 11374: 1
Branch 11375: 1
Branch 11376: 1
Branch 11377: 1
Branch 11378: 1
Branch 11379: 1
Branch 11380: 1
Branch 11381: 1
Branch 11382: 1
Branch 11383: 1
Branch 11384: 1
Branch 11385: 1
Branch 11386: 1
Branch 11387: 1
Branch 11388: 1
Branch 11389: 1
Branch 11390: 1
Branch 11391: 1
Branch 11392: 1
Branch 11393: 1
Branch 11394: 1
Branch 11395: 1
Branch 11396: 1
Branch 11397: 1
Branch 11398: 1
Branch 11399: 1
Branch 11400: 1
Branch 11401: 1
Branch 11402: 1
Branch 11403: 1
Branch 11404: 1
Branch 11405: 1
Branch 11406: 1
Branch 11407: 1
Branch 11408: 1
Branch 11409: 1
Branch 11410: 1
Branch 11411: 1
Branch 11412: 1
Branch 11413: 1
Branch 11414: 1
Branch 11415: 1
Branch 11416: 1
Branch 11417: 1
Branch 11418: 1
Branch 11419: 1
Branch 11420: 1
Branch 11421: 1
Branch 11422: 1
Branch 11423: 1
Branch 11424: 1
Branch 11425: 1
Branch 11426: 1
Branch 11427: 1
Branch 11428: 1
Branch 11429: 1
Branch 11430: 1
Branch 11431: 1
Branch 11432: 1
Branch 11433: 1
Branch 11434: 1
Branch 11435: 1
Branch 11436: 1
Branch 11437: 1
Branch 11438: 1
Branch 11439: 1
Branch 11440: 1
Branch 11441: 1
Branch 11442: 1
Branch 11443: 1
Branch 11444: 1
Branch 11445: 1
Branch 11446: 1
Branch 11447: 1
Branch 11448: 1
Branch 11449: 1
Branch 11450: 1
Branch 11451: 1
Branch 11452: 1
Branch 11453: 1
Branch 11454: 1
Branch 11455: 1
Branch 11456: 1
Branch 11457: 1
Branch 11458: 1
Branch 11459: 1
Branch 11460: 1
Branch 11461: 1
Branch 11462: 1
Branch 11463: 1
Branch 11464: 1
Branch 11465: 1
Branch 11466: 1
Branch 11467: 1
Branch 11468: 1
Branch 11469: 1
Branch 11470: 1
Branch 11471: 1
Branch 11472: 1
Branch 11473: 1
Branch 11474: 1
Branch 11475: 1
Branch 11476: 1
Branch 11477: 1
Branch 11478: 1
Branch 11479: 1
Branch 11480: 1
Branch 11481: 1
Branch 11482: 1
Branch 11483: 1
Branch 11484: 1
Branch 11485: 1
Branch 11486: 1
Branch 11487: 1
Branch 11488: 1
Branch 11489: 1
Branch 11490: 1
Branch 11491: 1
Branch 11492: 1
Branch 11493: 1
Branch 11494: 1
Branch 11495: 1
Branch 11496: 1
Branch 11497: 1
Branch 11498: 1
Branch 11499: 1
Branch 11500: 1
Branch 11501: 1
Branch 11502: 1
Branch 11503: 1
Branch 11504: 1
Branch 11505: 1
Branch 11506: 1
Branch 11507: 1
Branch 11508: 1
Branch 11509: 1
Branch 11510: 1
Branch 11511: 1
Branch 11512: 1
Branch 11513: 1
Branch 11514: 1
Branch 11515: 1
Branch 11516: 1
Branch 11517: 1
Branch 11518: 1
Branch 11519: 1
Branch 11520: 1
Branch 11521: 1
Branch 11522: 1
Branch 11523: 1
Branch 11524: 1
Branch 11525: 1
Branch 11526: 1
Branch 11527: 1
Branch 11528: 1
Branch 11529: 1
Branch 11530: 1
Branch 11531: 1
Branch 11532: 1
Branch 11533: 1
Branch 11534: 1
Branch 11535: 1
Branch 11536: 1
Branch 11537: 1
Branch 11538: 1
Branch 11539: 1
Branch 11540: 1
Branch 11541: 1
Branch 11542: 1
Branch 11543: 1
Branch 11544: 1
Branch 11545: 1
Branch 11546: 1
Branch 11547: 1
Branch 11548: 1
Branch 11549: 1
Branch 11550: 1
Branch 11551: 1
Branch 11552: 1
Branch 11553: 1
Branch 11554: 1
Branch 11555: 1
Branch 11556: 1
Branch 11557: 1
Branch 11558: 1
Branch 11559: 1
Branch 11560: 1
Branch 11561: 1
Branch 11562: 1
Branch 11563: 1
Branch 11564: 1
Branch 11565: 1
Branch 11566: 1
Branch 11567: 1
Branch 11568: 1
Branch 11569: 1
Branch 11570: 1
Branch 11571: 1
Branch 11572: 1
Branch 11573: 1
Branch 11574: 1
Branch 11575: 1
Branch 11576: 1
Branch 11577: 1
Branch 11578: 1
Branch 11579: 1
Branch 11580: 1
Branch 11581: 1
Branch 11582: 1
Branch 11583: 1
Branch 11584: 1
Branch 11585: 1
Branch 11586: 1
Branch 11587: 1
Branch 11588: 1
Branch 11589: 1
Branch 11590: 1
Branch 11591: 1
Branch 11592: 1
Branch 11593: 1
Branch 11594: 1
Branch 11595: 1
Branch 11596: 1
Branch 11597: 1
Branch 11598: 1
Branch 11599: 1
Branch 11600: 1
Branch 11601: 1
Branch 11602: 1
Branch 11603: 1
Branch 11604: 1
Branch 11605: 1
Branch 11606: 1
Branch 11607: 1
Branch 11608: 1
Branch 11609: 1
Branch 11610: 1
Branch 11611: 1
Branch 11612: 1
Branch 11613: 1
Branch 11614: 1
Branch 11615: 1
Branch 11616: 1
Branch 11617: 1
Branch 11618: 1
Branch 11619: 1
Branch 11620: 1
Branch 11621: 1
Branch 11622: 1
Branch 11623: 1
Branch 11624: 1
Branch 11625: 1
Branch 11626: 1
Branch 11627: 1
Branch 11628: 1
Branch 11629: 1
Branch 11630: 1
Branch 11631: 1
Branch 11632: 1
Branch 11633: 1
Branch 11634: 1
Branch 11635: 1
Branch 11636: 1
Branch 11637: 1
Branch 11638: 1
Branch 11639: 1
Branch 11640: 1
Branch 11641: 1
Branch 11642: 1
Branch 11643: 1
Branch 11644: 1
Branch 11645: 1
Branch 11646: 1
Branch 11647: 1
Branch 11648: 1
Branch 11649: 1
Branch 11650: 1
Branch 11651: 1
Branch 11652: 1
Branch 11653: 1
Branch 11654: 1
Branch 11655: 1
Branch 11656: 1
Branch 11657: 1
Branch 11658: 1
Branch 11659: 1
Branch 11660: 1
Branch 11661: 1
Branch 11662: 1
Branch 11663: 1
Branch 11664: 1
Branch 11665: 1
Branch 11666: 1
Branch 11667: 1
Branch 11668: 1
Branch 11669: 1
Branch 11670: 1
Branch 11671: 1
Branch 11672: 1
Branch 11673: 1
Branch 11674: 1
Branch 11675: 1
Branch 11676: 1
Branch 11677: 1
Branch 11678: 1
Branch 11679: 1
Branch 11680: 1
Branch 11681: 1
Branch 11682: 1
Branch 11683: 1
Branch 11684: 1
Branch 11685: 1
Branch 11686: 1
Branch 11687: 1
Branch 11688: 1
Branch 11689: 1
Branch 11690: 1
Branch 11691: 1
Branch 11692: 1
Branch 11693: 1
Branch 11694: 1
Branch 11695: 1
Branch 11696: 1
Branch 11697: 1
Branch 11698: 1
Branch 11699: 1
Branch 11700: 1
Branch 11701: 1
Branch 11702: 1
Branch 11703: 1
Branch 11704: 1
Branch 11705: 1
Branch 11706: 1
Branch 11707: 1
Branch 11708: 1
Branch 11709: 1
Branch 11710: 1
Branch 11711: 1
Branch 11712: 1
Branch 11713: 1
Branch 11714: 1
Branch 11715: 1
Branch 11716: 1
Branch 11717: 1
Branch 11718: 1
Branch 11719: 1
Branch 11720: 1
Branch 11721: 1
Branch 11722: 1
Branch 11723: 1
Branch 11724: 1
Branch 11725: 1
Branch 11726: 1
Branch 11727: 1
Branch 11728: 1
Branch 11729: 1
Branch 11730: 1
Branch 11731: 1
Branch 11732: 1
Branch 11733: 1
Branch 11734: 1
Branch 11735: 1
Branch 11736: 1
Branch 11737: 1
Branch 11738: 1
Branch 11739: 1
Branch 11740: 1
Branch 11741: 1
Branch 11742: 1
Branch 11743: 1
Branch 11744: 1
Branch 11745: 1
Branch 11746: 1
Branch 11747: 1
Branch 11748: 1
Branch 11749: 1
Branch 11750: 1
Branch 11751: 1
Branch 11752: 1
Branch 11753: 1
Branch 11754: 1
Branch 11755: 1
Branch 11756: 1
Branch 11757: 1
Branch 11758: 1
Branch 11759: 1
Branch 11760: 1
Branch 11761: 1
Branch 11762: 1
Branch 11763: 1
Branch 11764: 1
Branch 11765: 1
Branch 11766: 1
Branch 11767: 1
Branch 11768: 1
Branch 11769: 1
Branch 11770: 1
Branch 11771: 1
Branch 11772: 1
Branch 11773: 1
Branch 11774: 1
Branch 11775: 1
Branch 11776: 1
Branch 11777: 1
Branch 11778: 1
Branch 11779: 1
Branch 11780: 1
Branch 11781: 1
Branch 11782: 1
Branch 11783: 1
Branch 11784: 1
Branch 11785: 1
Branch 11786: 1
Branch 11787: 1
Branch 11788: 1
Branch 11789: 1
Branch 11790: 1
Branch 11791: 1
Branch 11792: 1
Branch 11793: 1
Branch 11794: 1
Branch 11795: 1
Branch 11796: 1
Branch 11797: 1
Branch 11798: 1
Branch 11799: 1
Branch 11800: 1
Branch 11801: 1
Branch 11802: 1
Branch 11803: 1
Branch 11804: 1
Branch 11805: 1
Branch 11806: 1
Branch 11807: 1
Branch 11808: 1
Branch 11809: 1
Branch 11810: 1
Branch 11811: 1
Branch 11812: 1
Branch 11813: 1
Branch 11814: 1
Branch 11815: 1
Branch 11816: 1
Branch 11817: 1
Branch 11818: 1
Branch 11819: 1
Branch 11820: 1
Branch 11821: 1
Branch 11822: 1
Branch 11823: 1
Branch 11824: 1
Branch 11825: 1
Branch 11826: 1
Branch 11827: 1
Branch 11828: 1
Branch 11829: 1
Branch 11830: 1
Branch 11831: 1
Branch 11832: 1
Branch 11833: 1
Branch 11834: 1
Branch 11835: 1
Branch 11836: 1
Branch 11837: 1
Branch 11838: 1
Branch 11839: 1
Branch 11840: 1
Branch 11841: 1
Branch 11842: 1
Branch 11843: 1
Branch 11844: 1
Branch 11845: 1
Branch 11846: 1
Branch 11847: 1
Branch 11848: 1
Branch 11849: 1
Branch 11850: 1
Branch 11851: 1
Branch 11852: 1
Branch 11853: 1
Branch 11854: 1
Branch 11855: 1
Branch 11856: 1
Branch 11857: 1
Branch 11858: 1
Branch 11859: 1
Branch 11860: 1
Branch 11861: 1
Branch 11862: 1
Branch 11863: 1
Branch 11864: 1
Branch 11865: 1
Branch 11866: 1
Branch 11867: 1
Branch 11868: 1
Branch 11869: 1
Branch 11870: 1
Branch 11871: 1
Branch 11872: 1
Branch 11873: 1
Branch 11874: 1
Branch 11875: 1
Branch 11876: 1
Branch 11877: 1
Branch 11878: 1
Branch 11879: 1
Branch 11880: 1
Branch 11881: 1
Branch 11882: 1
Branch 11883: 1
Branch 11884: 1
Branch 11885: 1
Branch 11886: 1
Branch 11887: 1
Branch 11888: 1
Branch 11889: 1
Branch 11890: 1
Branch 11891: 1
Branch 11892: 1
Branch 11893: 1
Branch 11894: 1
Branch 11895: 1
Branch 11896: 1
Branch 11897: 1
Branch 11898: 1
Branch 11899: 1
Branch 11900: 1
Branch 11901: 1
Branch 11902: 1
Branch 11903: 1
Branch 11904: 1
Branch 11905: 1
Branch 11906: 1
Branch 11907: 1
Branch 11908: 1
Branch 11909: 1
Branch 11910: 1
Branch 11911: 1
Branch 11912: 1
Branch 11913: 1
Branch 11914: 1
Branch 11915: 1
Branch 11916: 1
Branch 11917: 1
Branch 11918: 1
Branch 11919: 1
Branch 11920: 1
Branch 11921: 1
Branch 11922: 1
Branch 11923: 1
Branch 11924: 1
Branch 11925: 1
Branch 11926: 1
Branch 11927: 1
Branch 11928: 1
Branch 11929: 1
Branch 11930: 1
Branch 11931: 1
Branch 11932: 1
Branch 11933: 1
Branch 11934: 1
Branch 11935: 1
Branch 11936: 1
Branch 11937: 1
Branch 11938: 1
Branch 11939: 1
Branch 11940: 1
Branch 11941: 1
Branch 11942: 1
Branch 11943: 1
Branch 11944: 1
Branch 11945: 1
Branch 11946: 1
Branch 11947: 1
Branch 11948: 1
Branch 11949: 1
Branch 11950: 1
Branch 11951: 1
Branch 11952: 1
Branch 11953: 1
Branch 11954: 1
Branch 11955: 1
Branch 11956: 1
Branch 11957: 1
Branch 11958: 1
Branch 11959: 1
Branch 11960: 1
Branch 11961: 1
Branch 11962: 1
Branch 11963: 1
Branch 11964: 1
Branch 11965: 1
Branch 11966: 1
Branch 11967: 1
Branch 11968: 1
Branch 11969: 1
Branch 11970: 1
Branch 11971: 1
Branch 11972: 1
Branch 11973: 1
Branch 11974: 1
Branch 11975: 1
Branch 11976: 1
Branch 11977: 1
Branch 11978: 1
Branch 11979: 1
Branch 11980: 1
Branch 11981: 1
Branch 11982: 1
Branch 11983: 1
Branch 11984: 1
Branch 11985: 1
Branch 11986: 1
Branch 11987: 1
Branch 11988: 1
Branch 11989: 1
Branch 11990: 1
Branch 11991: 1
Branch 11992: 1
Branch 11993: 1
Branch 11994: 1
Branch 11995: 1
Branch 11996: 1
Branch 11997: 1
Branch 11998: 1
Branch 11999: 1
Branch 12000: 1
Branch 12001: 1
Branch 12002: 1
Branch 12003: 1
Branch 12004: 1
Branch 12005: 1
Branch 12006: 1
Branch 12007: 1
Branch 12008: 1
Branch 12009: 1
Branch 12010: 1
Branch 12011: 1
Branch 12012: 1
Branch 12013: 1
Branch 12014: 1
Branch 12015: 1
Branch 12016: 1
Branch 12017: 1
Branch 12018: 1
Branch 12019: 1
Branch 12020: 1
Branch 12021: 1
Branch 12022: 1
Branch 12023: 1
Branch 12024: 1
Branch 12025: 1
Branch 12026: 1
Branch 12027: 1
Branch 12028: 1
Branch 12029: 1
Branch 12030: 1
Branch 12031: 1
Branch 12032: 1
Branch 12033: 1
Branch 12034: 1
Branch 12035: 1
Branch 12036: 1
Branch 12037: 1
Branch 12038: 1
Branch 12039: 1
Branch 12040: 1
Branch 12041: 1
Branch 12042: 1
Branch 12043: 1
Branch 12044: 1
Branch 12045: 1
Branch 12046: 1
Branch 12047: 1
Branch 12048: 1
Branch 12049: 1
Branch 12050: 1
Branch 12051: 1
Branch 12052: 1
Branch 12053: 1
Branch 12054: 1
Branch 12055: 1
Branch 12056: 1
Branch 12057: 1
Branch 12058: 1
Branch 12059: 1
Branch 12060: 1
Branch 12061: 1
Branch 12062: 1
Branch 12063: 1
Branch 12064: 1
Branch 12065: 1
Branch 12066: 1
Branch 12067: 1
Branch 12068: 1
Branch 12069: 1
Branch 12070: 1
Branch 12071: 1
Branch 12072: 1
Branch 12073: 1
Branch 12074: 1
Branch 12075: 1
Branch 12076: 1
Branch 12077: 1
Branch 12078: 1
Branch 12079: 1
Branch 12080: 1
Branch 12081: 1
Branch 12082: 1
Branch 12083: 1
Branch 12084: 1
Branch 12085: 1
Branch 12086: 1
Branch 12087: 1
Branch 12088: 1
Branch 12089: 1
Branch 12090: 1
Branch 12091: 1
Branch 12092: 1
Branch 12093: 1
Branch 12094: 1
Branch 12095: 1
Branch 12096: 1
Branch 12097: 1
Branch 12098: 1
Branch 12099: 1
Branch 12100: 1
Branch 12101: 1
Branch 12102: 1
Branch 12103: 1
Branch 12104: 1
Branch 12105: 1
Branch 12106: 1
Branch 12107: 1
Branch 12108: 1
Branch 12109: 1
Branch 12110: 1
Branch 12111: 1
Branch 12112: 1
Branch 12113: 1
Branch 12114: 1
Branch 12115: 1
Branch 12116: 1
Branch 12117: 1
Branch 12118: 1
Branch 12119: 1
Branch 12120: 1
Branch 12121: 1
Branch 12122: 1
Branch 12123: 1
Branch 12124: 1
Branch 12125: 1
Branch 12126: 1
Branch 12127: 1
Branch 12128: 1
Branch 12129: 1
Branch 12130: 1
Branch 12131: 1
Branch 12132: 1
Branch 12133: 1
Branch 12134: 1
Branch 12135: 1
Branch 12136: 1
Branch 12137: 1
Branch 12138: 1
Branch 12139: 1
Branch 12140: 1
Branch 12141: 1
Branch 12142: 1
Branch 12143: 1
Branch 12144: 1
Branch 12145: 1
Branch 12146: 1
Branch 12147: 1
Branch 12148: 1
Branch 12149: 1
Branch 12150: 1
Branch 12151: 1
Branch 12152: 1
Branch 12153: 1
Branch 12154: 1
Branch 12155: 1
Branch 12156: 1
Branch 12157: 1
Branch 12158: 1
Branch 12159: 1
Branch 12160: 1
Branch 12161: 1
Branch 12162: 1
Branch 12163: 1
Branch 12164: 1
Branch 12165: 1
Branch 12166: 1
Branch 12167: 1
Branch 12168: 1
Branch 12169: 1
Branch 12170: 1
Branch 12171: 1
Branch 12172: 1
Branch 12173: 1
Branch 12174: 1
Branch 12175: 1
Branch 12176: 1
Branch 12177: 1
Branch 12178: 1
Branch 12179: 1
Branch 12180: 1
Branch 12181: 1
Branch 12182: 1
Branch 12183: 1
Branch 12184: 1
Branch 12185: 1
Branch 12186: 1
Branch 12187: 1
Branch 12188: 1
Branch 12189: 1
Branch 12190: 1
Branch 12191: 1
Branch 12192: 1
Branch 12193: 1
Branch 12194: 1
Branch 12195: 1
Branch 12196: 1
Branch 12197: 1
Branch 12198: 1
Branch 12199: 1
Branch 12200: 1
Branch 12201: 1
Branch 12202: 1
Branch 12203: 1
Branch 12204: 1
Branch 12205: 1
Branch 12206: 1
Branch 12207: 1
Branch 12208: 1
Branch 12209: 1
Branch 12210: 1
Branch 12211: 1
Branch 12212: 1
Branch 12213: 1
Branch 12214: 1
Branch 12215: 1
Branch 12216: 1
Branch 12217: 1
Branch 12218: 1
Branch 12219: 1
Branch 12220: 1
Branch 12221: 1
Branch 12222: 1
Branch 12223: 1
Branch 12224: 1
Branch 12225: 1
Branch 12226: 1
Branch 12227: 1
Branch 12228: 1
Branch 12229: 1
Branch 12230: 1
Branch 12231: 1
Branch 12232: 1
Branch 12233: 1
Branch 12234: 1
Branch 12235: 1
Branch 12236: 1
Branch 12237: 1
Branch 12238: 1
Branch 12239: 1
Branch 12240: 1
Branch 12241: 1
Branch 12242: 1
Branch 12243: 1
Branch 12244: 1
Branch 12245: 1
Branch 12246: 1
Branch 12247: 1
Branch 12248: 1
Branch 12249: 1
Branch 12250: 1
Branch 12251: 1
Branch 12252: 1
Branch 12253: 1
Branch 12254: 1
Branch 12255: 1
Branch 12256: 1
Branch 12257: 1
Branch 12258: 1
Branch 12259: 1
Branch 12260: 1
Branch 12261: 1
Branch 12262: 1
Branch 12263: 1
Branch 12264: 1
Branch 12265: 1
Branch 12266: 1
Branch 12267: 1
Branch 12268: 1
Branch 12269: 1
Branch 12270: 1
Branch 12271: 1
Branch 12272: 1
Branch 12273: 1
Branch 12274: 1
Branch 12275: 1
Branch 12276: 1
Branch 12277: 1
Branch 12278: 1
Branch 12279: 1
Branch 12280: 1
Branch 12281: 1
Branch 12282: 1
Branch 12283: 1
Branch 12284: 1
Branch 12285: 0
Branch 12286: 0
Branch 12287: 0
Branch 12288: 0
Branch 12289: 0
Branch 12290: 0
Branch 12291: 0
Branch 12292: 0
Branch 12293: 0
Branch 12294: 0
Branch 12295: 0
Branch 12296: 0
Branch 12297: 0
Branch 12298: 0
Branch 12299: 0
Branch 12300: 0
Branch 12301: 0
Branch 12302: 0
Branch 12303: 0
Branch 12304: 0
Branch 12305: 0
Branch 12306: 0
Branch 12307: 0
Branch 12308: 0
Branch 12309: 0
Branch 12310: 0
Branch 12311: 0
Branch 12312: 0
Branch 12313: 0
Branch 12314: 0
Branch 12315: 0
Branch 12316: 0
Branch 12317: 0
Branch 12318: 0
Branch 12319: 0
Branch 12320: 0
Branch 12321: 0
Branch 12322: 0
Branch 12323: 0
Branch 12324: 0
Branch 12325: 0
Branch 12326: 0
Branch 12327: 0
Branch 12328: 0
Branch 12329: 0
Branch 12330: 0
Branch 12331: 0
Branch 12332: 0
Branch 12333: 0
Branch 12334: 0
Branch 12335: 0
Branch 12336: 0
Branch 12337: 0
Branch 12338: 0
Branch 12339: 0
Branch 12340: 0
Branch 12341: 0
Branch 12342: 0
Branch 12343: 0
Branch 12344: 0
Branch 12345: 0
Branch 12346: 0
Branch 12347: 0
Branch 12348: 0
Branch 12349: 0
Branch 12350: 0
Branch 12351: 0
Branch 12352: 0
Branch 12353: 0
Branch 12354: 0
Branch 12355: 0
Branch 12356: 0
Branch 12357: 0
Branch 12358: 0
Branch 12359: 0
Branch 12360: 0
Branch 12361: 0
Branch 12362: 0
Branch 12363: 0
Branch 12364: 0
Branch 12365: 0
Branch 12366: 0
Branch 12367: 0
Branch 12368: 0
Branch 12369: 0
Branch 12370: 0
Branch 12371: 0
Branch 12372: 0
Branch 12373: 0
Branch 12374: 0
Branch 12375: 0
Branch 12376: 0
Branch 12377: 0
Branch 12378: 0
Branch 12379: 0
Branch 12380: 0
Branch 12381: 0
Branch 12382: 0
Branch 12383: 0
Branch 12384: 0
Branch 12385: 0
Branch 12386: 0
Branch 12387: 0
Branch 12388: 0
Branch 12389: 0
Branch 12390: 0
Branch 12391: 0
Branch 12392: 0
Branch 12393: 0
Branch 12394: 0
Branch 12395: 0
Branch 12396: 0
Branch 12397: 0
Branch 12398: 0
Branch 12399: 0
Branch 12400: 0
Branch 12401: 0
Branch 12402: 0
Branch 12403: 0
Branch 12404: 0
Branch 12405: 0
Branch 12406: 0
Branch 12407: 0
Branch 12408: 0
Branch 12409: 0
Branch 12410: 0
Branch 12411: 0
Branch 12412: 0
Branch 12413: 0
Branch 12414: 0
Branch 12415: 0
Branch 12416: 0
Branch 12417: 0
Branch 12418: 0
Branch 12419: 0
Branch 12420: 0
Branch 12421: 0
Branch 12422: 0
Branch 12423: 0
Branch 12424: 0
Branch 12425: 0
Branch 12426: 0
Branch 12427: 0
Branch 12428: 0
Branch 12429: 0
Branch 12430: 0
Branch 12431: 0
Branch 12432: 0
Branch 12433: 0
Branch 12434: 0
Branch 12435: 0
Branch 12436: 0
Branch 12437: 0
Branch 12438: 0
Branch 12439: 0
Branch 12440: 0
Branch 12441: 0
Branch 12442: 0
Branch 12443: 0
Branch 12444: 0
Branch 12445: 0
Branch 12446: 0
Branch 12447: 0
Branch 12448: 0
Branch 12449: 0
Branch 12450: 0
Branch 12451: 0
Branch 12452: 0
Branch 12453: 0
Branch 12454: 0
Branch 12455: 0
Branch 12456: 0
Branch 12457: 0
Branch 12458: 0
Branch 12459: 0
Branch 12460: 0
Branch 12461: 0
Branch 12462: 0
Branch 12463: 0
Branch 12464: 0
Branch 12465: 0
Branch 12466: 0
Branch 12467: 0
Branch 12468: 0
Branch 12469: 0
Branch 12470: 0
Branch 12471: 0
Branch 12472: 0
Branch 12473: 0
Branch 12474: 0
Branch 12475: 0
Branch 12476: 0
Branch 12477: 0
Branch 12478: 0
Branch 12479: 0
Branch 12480: 0
Branch 12481: 0
Branch 12482: 0
Branch 12483: 0
Branch 12484: 0
Branch 12485: 0
Branch 12486: 0
Branch 12487: 0
Branch 12488: 0
Branch 12489: 0
Branch 12490: 0
Branch 12491: 0
Branch 12492: 0
Branch 12493: 0
Branch 12494: 0
Branch 12495: 0
Branch 12496: 0
Branch 12497: 0
Branch 12498: 0
Branch 12499: 0
Branch 12500: 0
Branch 12501: 0
Branch 12502: 0
Branch 12503: 0
Branch 12504: 0
Branch 12505: 0
Branch 12506: 0
Branch 12507: 0
Branch 12508: 0
Branch 12509: 0
Branch 12510: 0
Branch 12511: 0
Branch 12512: 0
Branch 12513: 0
Branch 12514: 0
Branch 12515: 0
Branch 12516: 0
Branch 12517: 0
Branch 12518: 0
Branch 12519: 0
Branch 12520: 0
Branch 12521: 0
Branch 12522: 0
Branch 12523: 0
Branch 12524: 0
Branch 12525: 0
Branch 12526: 0
Branch 12527: 0
Branch 12528: 0
Branch 12529: 0
Branch 12530: 0
Branch 12531: 0
Branch 12532: 0
Branch 12533: 0
Branch 12534: 0
Branch 12535: 0
Branch 12536: 0
Branch 12537: 0
Branch 12538: 0
Branch 12539: 0
Branch 12540: 0
Branch 12541: 0
Branch 12542: 0
Branch 12543: 0
Branch 12544: 0
Branch 12545: 0
Branch 12546: 0
Branch 12547: 0
Branch 12548: 0
Branch 12549: 0
Branch 12550: 0
Branch 12551: 0
Branch 12552: 0
Branch 12553: 0
Branch 12554: 0
Branch 12555: 0
Branch 12556: 0
Branch 12557: 0
Branch 12558: 0
Branch 12559: 0
Branch 12560: 0
Branch 12561: 0
Branch 12562: 0
Branch 12563: 0
Branch 12564: 0
Branch 12565: 0
Branch 12566: 0
Branch 12567: 0
Branch 12568: 0
Branch 12569: 0
Branch 12570: 0
Branch 12571: 0
Branch 12572: 0
Branch 12573: 0
Branch 12574: 0
Branch 12575: 0
Branch 12576: 0
Branch 12577: 0
Branch 12578: 0
Branch 12579: 0
Branch 12580: 0
Branch 12581: 0
Branch 12582: 0
Branch 12583: 0
Branch 12584: 0
Branch 12585: 0
Branch 12586: 0
Branch 12587: 0
Branch 12588: 0
Branch 12589: 0
Branch 12590: 0
Branch 12591: 0
Branch 12592: 0
Branch 12593: 0
Branch 12594: 0
Branch 12595: 0
Branch 12596: 0
Branch 12597: 0
Branch 12598: 0
Branch 12599: 0
Branch 12600: 0
Branch 12601: 0
Branch 12602: 0
Branch 12603: 0
Branch 12604: 0
Branch 12605: 0
Branch 12606: 0
Branch 12607: 0
Branch 12608: 0
Branch 12609: 0
Branch 12610: 0
Branch 12611: 0
Branch 12612: 0
Branch 12613: 0
Branch 12614: 0
Branch 12615: 0
Branch 12616: 0
Branch 12617: 0
Branch 12618: 0
Branch 12619: 0
Branch 12620: 0
Branch 12621: 0
Branch 12622: 0
Branch 12623: 0
Branch 12624: 0
Branch 12625: 0
Branch 12626: 0
Branch 12627: 0
Branch 12628: 0
Branch 12629: 0
Branch 12630: 0
Branch 12631: 0
Branch 12632: 0
Branch 12633: 0
Branch 12634: 0
Branch 12635: 0
Branch 12636: 0
Branch 12637: 0
Branch 12638: 0
Branch 12639: 0
Branch 12640: 0
Branch 12641: 0
Branch 12642: 0
Branch 12643: 0
Branch 12644: 0
Branch 12645: 0
Branch 12646: 0
Branch 12647: 0
Branch 12648: 0
Branch 12649: 0
Branch 12650: 0
Branch 12651: 0
Branch 12652: 0
Branch 12653: 0
Branch 12654: 0
Branch 12655: 0
Branch 12656: 0
Branch 12657: 0
Branch 12658: 0
Branch 12659: 0
Branch 12660: 0
Branch 12661: 0
Branch 12662: 0
Branch 12663: 0
Branch 12664: 0
Branch 12665: 0
Branch 12666: 0
Branch 12667: 0
Branch 12668: 0
Branch 12669: 0
Branch 12670: 0
Branch 12671: 0
Branch 12672: 0
Branch 12673: 0
Branch 12674: 0
Branch 12675: 0
Branch 12676: 0
Branch 12677: 0
Branch 12678: 0
Branch 12679: 0
Branch 12680: 0
Branch 12681: 0
Branch 12682: 0
Branch 12683: 0
Branch 12684: 0
Branch 12685: 0
Branch 12686: 0
Branch 12687: 0
Branch 12688: 0
Branch 12689: 0
Branch 12690: 0
Branch 12691: 0
Branch 12692: 0
Branch 12693: 0
Branch 12694: 0
Branch 12695: 0
Branch 12696: 0
Branch 12697: 0
Branch 12698: 0
Branch 12699: 0
Branch 12700: 0
Branch 12701: 0
Branch 12702: 0
Branch 12703: 0
Branch 12704: 0
Branch 12705: 0
Branch 12706: 0
Branch 12707: 0
Branch 12708: 0
Branch 12709: 0
Branch 12710: 0
Branch 12711: 0
Branch 12712: 0
Branch 12713: 0
Branch 12714: 0
Branch 12715: 0
Branch 12716: 0
Branch 12717: 0
Branch 12718: 0
Branch 12719: 0
Branch 12720: 0
Branch 12721: 0
Branch 12722: 0
Branch 12723: 0
Branch 12724: 0
Branch 12725: 0
Branch 12726: 0
Branch 12727: 0
Branch 12728: 0
Branch 12729: 0
Branch 12730: 0
Branch 12731: 0
Branch 12732: 0
Branch 12733: 0
Branch 12734: 0
Branch 12735: 0
Branch 12736: 0
Branch 12737: 0
Branch 12738: 0
Branch 12739: 0
Branch 12740: 0
Branch 12741: 0
Branch 12742: 0
Branch 12743: 0
Branch 12744: 1
Branch 12745: 1
Branch 12746: 1
Branch 12747: 1
Branch 12748: 1
Branch 12749: 1
Branch 12750: 1
Branch 12751: 1
Branch 12752: 1
Branch 12753: 1
Branch 12754: 1
Branch 12755: 1
Branch 12756: 1
Branch 12757: 1
Branch 12758: 1
Branch 12759: 1
Branch 12760: 1
Branch 12761: 1
Branch 12762: 1
Branch 12763: 1
Branch 12764: 1
Branch 12765: 1
Branch 12766: 1
Branch 12767: 1
Branch 12768: 1
Branch 12769: 1
Branch 12770: 1
Branch 12771: 1
Branch 12772: 1
Branch 12773: 1
Branch 12774: 1
Branch 12775: 1
Branch 12776: 1
Branch 12777: 1
Branch 12778: 1
Branch 12779: 1
Branch 12780: 1
Branch 12781: 1
Branch 12782: 1
Branch 12783: 1
Branch 12784: 1
Branch 12785: 1
Branch 12786: 1
Branch 12787: 1
Branch 12788: 1
Branch 12789: 1
Branch 12790: 1
Branch 12791: 1
Branch 12792: 1
Branch 12793: 1
Branch 12794: 1
Branch 12795: 1
Branch 12796: 1
Branch 12797: 1
Branch 12798: 1
Branch 12799: 1
Branch 12800: 1
Branch 12801: 1
Branch 12802: 1
Branch 12803: 1
Branch 12804: 1
Branch 12805: 1
Branch 12806: 1
Branch 12807: 1
Branch 12808: 1
Branch 12809: 1
Branch 12810: 1
Branch 12811: 1
Branch 12812: 1
Branch 12813: 1
Branch 12814: 1
Branch 12815: 1
Branch 12816: 1
Branch 12817: 1
Branch 12818: 1
Branch 12819: 1
Branch 12820: 1
Branch 12821: 1
Branch 12822: 1
Branch 12823: 1
Branch 12824: 1
Branch 12825: 1
Branch 12826: 1
Branch 12827: 1
Branch 12828: 1
Branch 12829: 1
Branch 12830: 1
Branch 12831: 1
Branch 12832: 1
Branch 12833: 1
Branch 12834: 1
Branch 12835: 1
Branch 12836: 1
Branch 12837: 1
Branch 12838: 1
Branch 12839: 1
Branch 12840: 1
Branch 12841: 1
Branch 12842: 1
Branch 12843: 1
Branch 12844: 1
Branch 12845: 1
Branch 12846: 1
Branch 12847: 1
Branch 12848: 1
Branch 12849: 1
Branch 12850: 1
Branch 12851: 1
Branch 12852: 1
Branch 12853: 1
Branch 12854: 1
Branch 12855: 1
Branch 12856: 1
Branch 12857: 1
Branch 12858: 1
Branch 12859: 1
Branch 12860: 1
Branch 12861: 1
Branch 12862: 1
Branch 12863: 1
Branch 12864: 1
Branch 12865: 1
Branch 12866: 1
Branch 12867: 1
Branch 12868: 1
Branch 12869: 1
Branch 12870: 1
Branch 12871: 1
Branch 12872: 1
Branch 12873: 1
Branch 12874: 1
Branch 12875: 1
Branch 12876: 1
Branch 12877: 1
Branch 12878: 1
Branch 12879: 1
Branch 12880: 1
Branch 12881: 1
Branch 12882: 1
Branch 12883: 1
Branch 12884: 1
Branch 12885: 1
Branch 12886: 1
Branch 12887: 1
Branch 12888: 1
Branch 12889: 1
Branch 12890: 1
Branch 12891: 1
Branch 12892: 1
Branch 12893: 1
Branch 12894: 1
Branch 12895: 1
Branch 12896: 1
Branch 12897: 1
Branch 12898: 1
Branch 12899: 1
Branch 12900: 1
Branch 12901: 1
Branch 12902: 1
Branch 12903: 1
Branch 12904: 1
Branch 12905: 1
Branch 12906: 1
Branch 12907: 1
Branch 12908: 1
Branch 12909: 1
Branch 12910: 1
Branch 12911: 1
Branch 12912: 1
Branch 12913: 1
Branch 12914: 1
Branch 12915: 1
Branch 12916: 1
Branch 12917: 1
Branch 12918: 1
Branch 12919: 1
Branch 12920: 1
Branch 12921: 1
Branch 12922: 1
Branch 12923: 1
Branch 12924: 1
Branch 12925: 1
Branch 12926: 1
Branch 12927: 1
Branch 12928: 1
Branch 12929: 1
Branch 12930: 1
Branch 12931: 1
Branch 12932: 1
Branch 12933: 1
Branch 12934: 1
Branch 12935: 1
Branch 12936: 1
Branch 12937: 1
Branch 12938: 1
Branch 12939: 1
Branch 12940: 1
Branch 12941: 1
Branch 12942: 1
Branch 12943: 1
Branch 12944: 1
Branch 12945: 1
Branch 12946: 1
Branch 12947: 1
Branch 12948: 1
Branch 12949: 1
Branch 12950: 1
Branch 12951: 1
Branch 12952: 1
Branch 12953: 1
Branch 12954: 1
Branch 12955: 1
Branch 12956: 1
Branch 12957: 1
Branch 12958: 1
Branch 12959: 1
Branch 12960: 1
Branch 12961: 1
Branch 12962: 1
Branch 12963: 1
Branch 12964: 1
Branch 12965: 1
Branch 12966: 1
Branch 12967: 1
Branch 12968: 1
Branch 12969: 1
Branch 12970: 1
Branch 12971: 1
Branch 12972: 1
Branch 12973: 1
Branch 12974: 1
Branch 12975: 1
Branch 12976: 1
Branch 12977: 1
Branch 12978: 1
Branch 12979: 1
Branch 12980: 1
Branch 12981: 1
Branch 12982: 1
Branch 12983: 1
Branch 12984: 1
Branch 12985: 1
Branch 12986: 1
Branch 12987: 1
Branch 12988: 1
Branch 12989: 1
Branch 12990: 1
Branch 12991: 1
Branch 12992: 1
Branch 12993: 1
Branch 12994: 1
Branch 12995: 1
Branch 12996: 1
Branch 12997: 1
Branch 12998: 1
Branch 12999: 1
Branch 13000: 1
Branch 13001: 1
Branch 13002: 1
Branch 13003: 1
Branch 13004: 1
Branch 13005: 1
Branch 13006: 1
Branch 13007: 1
Branch 13008: 1
Branch 13009: 1
Branch 13010: 1
Branch 13011: 1
Branch 13012: 1
Branch 13013: 1
Branch 13014: 1
Branch 13015: 1
Branch 13016: 1
Branch 13017: 1
Branch 13018: 1
Branch 13019: 1
Branch 13020: 1
Branch 13021: 1
Branch 13022: 1
Branch 13023: 1
Branch 13024: 1
Branch 13025: 1
Branch 13026: 1
Branch 13027: 1
Branch 13028: 1
Branch 13029: 1
Branch 13030: 1
Branch 13031: 1
Branch 13032: 1
Branch 13033: 1
Branch 13034: 1
Branch 13035: 1
Branch 13036: 1
Branch 13037: 1
Branch 13038: 1
Branch 13039: 1
Branch 13040: 1
Branch 13041: 1
Branch 13042: 1
Branch 13043: 1
Branch 13044: 1
Branch 13045: 1
Branch 13046: 1
Branch 13047: 1
Branch 13048: 1
Branch 13049: 1
Branch 13050: 1
Branch 13051: 1
Branch 13052: 1
Branch 13053: 1
Branch 13054: 1
Branch 13055: 1
Branch 13056: 1
Branch 13057: 1
Branch 13058: 1
Branch 13059: 1
Branch 13060: 1
Branch 13061: 1
Branch 13062: 1
Branch 13063: 1
Branch 13064: 1
Branch 13065: 1
Branch 13066: 1
Branch 13067: 1
Branch 13068: 1
Branch 13069: 1
Branch 13070: 1
Branch 13071: 1
Branch 13072: 1
Branch 13073: 1
Branch 13074: 1
Branch 13075: 1
Branch 13076: 1
Branch 13077: 1
Branch 13078: 1
Branch 13079: 1
Branch 13080: 1
Branch 13081: 1
Branch 13082: 1
Branch 13083: 1
Branch 13084: 1
Branch 13085: 1
Branch 13086: 1
Branch 13087: 1
Branch 13088: 1
Branch 13089: 1
Branch 13090: 1
Branch 13091: 1
Branch 13092: 1
Branch 13093: 1
Branch 13094: 1
Branch 13095: 1
Branch 13096: 1
Branch 13097: 1
Branch 13098: 1
Branch 13099: 1
Branch 13100: 1
Branch 13101: 1
Branch 13102: 1
Branch 13103: 1
Branch 13104: 1
Branch 13105: 1
Branch 13106: 1
Branch 13107: 1
Branch 13108: 1
Branch 13109: 1
Branch 13110: 1
Branch 13111: 1
Branch 13112: 1
Branch 13113: 1
Branch 13114: 1
Branch 13115: 1
Branch 13116: 1
Branch 13117: 1
Branch 13118: 1
Branch 13119: 1
Branch 13120: 1
Branch 13121: 1
Branch 13122: 1
Branch 13123: 1
Branch 13124: 1
Branch 13125: 1
Branch 13126: 1
Branch 13127: 1
Branch 13128: 1
Branch 13129: 1
Branch 13130: 1
Branch 13131: 1
Branch 13132: 1
Branch 13133: 1
Branch 13134: 1
Branch 13135: 1
Branch 13136: 1
Branch 13137: 1
Branch 13138: 1
Branch 13139: 1
Branch 13140: 1
Branch 13141: 1
Branch 13142: 1
Branch 13143: 1
Branch 13144: 1
Branch 13145: 1
Branch 13146: 1
Branch 13147: 1
Branch 13148: 1
Branch 13149: 1
Branch 13150: 1
Branch 13151: 1
Branch 13152: 1
Branch 13153: 1
Branch 13154: 1
Branch 13155: 1
Branch 13156: 1
Branch 13157: 1
Branch 13158: 1
Branch 13159: 1
Branch 13160: 1
Branch 13161: 1
Branch 13162: 1
Branch 13163: 1
Branch 13164: 1
Branch 13165: 1
Branch 13166: 1
Branch 13167: 1
Branch 13168: 1
Branch 13169: 1
Branch 13170: 1
Branch 13171: 1
Branch 13172: 1
Branch 13173: 1
Branch 13174: 1
Branch 13175: 1
Branch 13176: 1
Branch 13177: 1
Branch 13178: 1
Branch 13179: 1
Branch 13180: 1
Branch 13181: 1
Branch 13182: 1
Branch 13183: 1
Branch 13184: 1
Branch 13185: 1
Branch 13186: 1
Branch 13187: 1
Branch 13188: 1
Branch 13189: 1
Branch 13190: 1
Branch 13191: 1
Branch 13192: 1
Branch 13193: 1
Branch 13194: 1
Branch 13195: 1
Branch 13196: 1
Branch 13197: 1
Branch 13198: 1
Branch 13199: 1
Branch 13200: 1
Branch 13201: 1
Branch 13202: 1
Branch 13203: 1
Branch 13204: 1
Branch 13205: 1
Branch 13206: 1
Branch 13207: 1
Branch 13208: 1
Branch 13209: 1
Branch 13210: 1
Branch 13211: 1
Branch 13212: 1
Branch 13213: 1
Branch 13214: 1
Branch 13215: 1
Branch 13216: 1
Branch 13217: 1
Branch 13218: 1
Branch 13219: 1
Branch 13220: 1
Branch 13221: 1
Branch 13222: 1
Branch 13223: 1
Branch 13224: 1
Branch 13225: 1
Branch 13226: 1
Branch 13227: 1
Branch 13228: 1
Branch 13229: 1
Branch 13230: 1
Branch 13231: 1
Branch 13232: 1
Branch 13233: 1
Branch 13234: 1
Branch 13235: 1
Branch 13236: 1
Branch 13237: 1
Branch 13238: 1
Branch 13239: 1
Branch 13240: 1
Branch 13241: 1
Branch 13242: 1
Branch 13243: 1
Branch 13244: 1
Branch 13245: 1
Branch 13246: 1
Branch 13247: 1
Branch 13248: 1
Branch 13249: 1
Branch 13250: 1
Branch 13251: 1
Branch 13252: 1
Branch 13253: 1
Branch 13254: 1
Branch 13255: 1
Branch 13256: 1
Branch 13257: 1
Branch 13258: 1
Branch 13259: 1
Branch 13260: 1
Branch 13261: 1
Branch 13262: 1
Branch 13263: 1
Branch 13264: 1
Branch 13265: 1
Branch 13266: 1
Branch 13267: 1
Branch 13268: 1
Branch 13269: 1
Branch 13270: 1
Branch 13271: 1
Branch 13272: 1
Branch 13273: 1
Branch 13274: 1
Branch 13275: 1
Branch 13276: 1
Branch 13277: 1
Branch 13278: 1
Branch 13279: 1
Branch 13280: 1
Branch 13281: 1
Branch 13282: 1
Branch 13283: 1
Branch 13284: 1
Branch 13285: 1
Branch 13286: 1
Branch 13287: 1
Branch 13288: 1
Branch 13289: 1
Branch 13290: 1
Branch 13291: 1
Branch 13292: 1
Branch 13293: 1
Branch 13294: 1
Branch 13295: 1
Branch 13296: 1
Branch 13297: 1
Branch 13298: 1
Branch 13299: 1
Branch 13300: 1
Branch 13301: 1
Branch 13302: 1
Branch 13303: 1
Branch 13304: 1
Branch 13305: 1
Branch 13306: 1
Branch 13307: 1
Branch 13308: 1
Branch 13309: 1
Branch 13310: 1
Branch 13311: 1
Branch 13312: 1
Branch 13313: 1
Branch 13314: 1
Branch 13315: 1
Branch 13316: 1
Branch 13317: 1
Branch 13318: 1
Branch 13319: 1
Branch 13320: 1
Branch 13321: 1
Branch 13322: 1
Branch 13323: 1
Branch 13324: 1
Branch 13325: 1
Branch 13326: 1
Branch 13327: 1
Branch 13328: 1
Branch 13329: 1
Branch 13330: 1
Branch 13331: 1
Branch 13332: 1
Branch 13333: 1
Branch 13334: 1
Branch 13335: 1
Branch 13336: 1
Branch 13337: 1
Branch 13338: 1
Branch 13339: 1
Branch 13340: 1
Branch 13341: 1
Branch 13342: 1
Branch 13343: 1
Branch 13344: 1
Branch 13345: 1
Branch 13346: 1
Branch 13347: 1
Branch 13348: 1
Branch 13349: 1
Branch 13350: 1
Branch 13351: 1
Branch 13352: 1
Branch 13353: 1
Branch 13354: 1
Branch 13355: 1
Branch 13356: 1
Branch 13357: 1
Branch 13358: 1
Branch 13359: 1
Branch 13360: 1
Branch 13361: 1
Branch 13362: 1
Branch 13363: 1
Branch 13364: 1
Branch 13365: 1
Branch 13366: 1
Branch 13367: 1
Branch 13368: 1
Branch 13369: 1
Branch 13370: 1
Branch 13371: 1
Branch 13372: 1
Branch 13373: 1
Branch 13374: 1
Branch 13375: 1
Branch 13376: 1
Branch 13377: 1
Branch 13378: 1
Branch 13379: 1
Branch 13380: 1
Branch 13381: 1
Branch 13382: 1
Branch 13383: 1
Branch 13384: 1
Branch 13385: 1
Branch 13386: 1
Branch 13387: 1
Branch 13388: 1
Branch 13389: 1
Branch 13390: 1
Branch 13391: 1
Branch 13392: 1
Branch 13393: 1
Branch 13394: 1
Branch 13395: 1
Branch 13396: 1
Branch 13397: 1
Branch 13398: 1
Branch 13399: 1
Branch 13400: 1
Branch 13401: 1
Branch 13402: 1
Branch 13403: 1
Branch 13404: 1
Branch 13405: 1
Branch 13406: 1
Branch 13407: 1
Branch 13408: 1
Branch 13409: 1
Branch 13410: 1
Branch 13411: 1
Branch 13412: 1
Branch 13413: 1
Branch 13414: 1
Branch 13415: 1
Branch 13416: 1
Branch 13417: 1
Branch 13418: 1
Branch 13419: 1
Branch 13420: 1
Branch 13421: 1
Branch 13422: 1
Branch 13423: 1
Branch 13424: 1
Branch 13425: 1
Branch 13426: 1
Branch 13427: 1
Branch 13428: 1
Branch 13429: 1
Branch 13430: 1
Branch 13431: 1
Branch 13432: 1
Branch 13433: 1
Branch 13434: 1
Branch 13435: 1
Branch 13436: 1
Branch 13437: 1
Branch 13438: 1
Branch 13439: 1
Branch 13440: 1
Branch 13441: 1
Branch 13442: 1
Branch 13443: 1
Branch 13444: 1
Branch 13445: 1
Branch 13446: 1
Branch 13447: 1
Branch 13448: 1
Branch 13449: 1
Branch 13450: 1
Branch 13451: 1
Branch 13452: 1
Branch 13453: 1
Branch 13454: 1
Branch 13455: 1
Branch 13456: 1
Branch 13457: 1
Branch 13458: 1
Branch 13459: 1
Branch 13460: 1
Branch 13461: 1
Branch 13462: 1
Branch 13463: 1
Branch 13464: 1
Branch 13465: 1
Branch 13466: 1
Branch 13467: 1
Branch 13468: 1
Branch 13469: 1
Branch 13470: 1
Branch 13471: 1
Branch 13472: 1
Branch 13473: 1
Branch 13474: 1
Branch 13475: 1
Branch 13476: 1
Branch 13477: 1
Branch 13478: 1
Branch 13479: 1
Branch 13480: 1
Branch 13481: 1
Branch 13482: 1
Branch 13483: 1
Branch 13484: 1
Branch 13485: 1
Branch 13486: 1
Branch 13487: 1
Branch 13488: 1
Branch 13489: 1
Branch 13490: 1
Branch 13491: 1
Branch 13492: 1
Branch 13493: 1
Branch 13494: 1
Branch 13495: 1
Branch 13496: 1
Branch 13497: 1
Branch 13498: 1
Branch 13499: 1
Branch 13500: 1
Branch 13501: 1
Branch 13502: 1
Branch 13503: 1
Branch 13504: 1
Branch 13505: 1
Branch 13506: 1
Branch 13507: 1
Branch 13508: 1
Branch 13509: 1
Branch 13510: 1
Branch 13511: 1
Branch 13512: 1
Branch 13513: 1
Branch 13514: 1
Branch 13515: 1
Branch 13516: 1
Branch 13517: 1
Branch 13518: 1
Branch 13519: 1
Branch 13520: 1
Branch 13521: 1
Branch 13522: 1
Branch 13523: 1
Branch 13524: 1
Branch 13525: 1
Branch 13526: 1
Branch 13527: 1
Branch 13528: 1
Branch 13529: 1
Branch 13530: 1
Branch 13531: 1
Branch 13532: 1
Branch 13533: 1
Branch 13534: 1
Branch 13535: 1
Branch 13536: 1
Branch 13537: 1
Branch 13538: 1
Branch 13539: 1
Branch 13540: 1
Branch 13541: 1
Branch 13542: 1
Branch 13543: 1
Branch 13544: 1
Branch 13545: 1
Branch 13546: 1
Branch 13547: 1
Branch 13548: 1
Branch 13549: 1
Branch 13550: 1
Branch 13551: 1
Branch 13552: 1
Branch 13553: 1
Branch 13554: 1
Branch 13555: 1
Branch 13556: 1
Branch 13557: 1
Branch 13558: 1
Branch 13559: 1
Branch 13560: 1
Branch 13561: 1
Branch 13562: 1
Branch 13563: 1
Branch 13564: 1
Branch 13565: 1
Branch 13566: 1
Branch 13567: 1
Branch 13568: 1
Branch 13569: 1
Branch 13570: 1
Branch 13571: 1
Branch 13572: 1
Branch 13573: 1
Branch 13574: 1
Branch 13575: 1
Branch 13576: 1
Branch 13577: 1
Branch 13578: 1
Branch 13579: 1
Branch 13580: 1
Branch 13581: 1
Branch 13582: 1
Branch 13583: 1
Branch 13584: 1
Branch 13585: 1
Branch 13586: 1
Branch 13587: 1
Branch 13588: 1
Branch 13589: 1
Branch 13590: 1
Branch 13591: 1
Branch 13592: 1
Branch 13593: 1
Branch 13594: 1
Branch 13595: 1
Branch 13596: 1
Branch 13597: 1
Branch 13598: 1
Branch 13599: 1
Branch 13600: 1
Branch 13601: 1
Branch 13602: 1
Branch 13603: 1
Branch 13604: 1
Branch 13605: 1
Branch 13606: 1
Branch 13607: 1
Branch 13608: 1
Branch 13609: 1
Branch 13610: 1
Branch 13611: 1
Branch 13612: 1
Branch 13613: 1
Branch 13614: 1
Branch 13615: 1
Branch 13616: 1
Branch 13617: 1
Branch 13618: 1
Branch 13619: 1
Branch 13620: 1
Branch 13621: 1
Branch 13622: 1
Branch 13623: 1
Branch 13624: 1
Branch 13625: 1
Branch 13626: 1
Branch 13627: 1
Branch 13628: 1
Branch 13629: 1
Branch 13630: 1
Branch 13631: 1
Branch 13632: 1
Branch 13633: 1
Branch 13634: 1
Branch 13635: 1
Branch 13636: 1
Branch 13637: 1
Branch 13638: 1
Branch 13639: 1
Branch 13640: 1
Branch 13641: 1
Branch 13642: 1
Branch 13643: 1
Branch 13644: 1
Branch 13645: 1
Branch 13646: 1
Branch 13647: 1
Branch 13648: 1
Branch 13649: 1
Branch 13650: 1
Branch 13651: 1
Branch 13652: 1
Branch 13653: 1
Branch 13654: 1
Branch 13655: 1
Branch 13656: 1
Branch 13657: 1
Branch 13658: 1
Branch 13659: 1
Branch 13660: 1
Branch 13661: 1
Branch 13662: 1
Branch 13663: 1
Branch 13664: 1
Branch 13665: 1
Branch 13666: 1
Branch 13667: 1
Branch 13668: 1
Branch 13669: 1
Branch 13670: 1
Branch 13671: 1
Branch 13672: 1
Branch 13673: 1
Branch 13674: 1
Branch 13675: 1
Branch 13676: 1
Branch 13677: 1
Branch 13678: 1
Branch 13679: 1
Branch 13680: 1
Branch 13681: 1
Branch 13682: 1
Branch 13683: 1
Branch 13684: 1
Branch 13685: 1
Branch 13686: 1
Branch 13687: 1
Branch 13688: 1
Branch 13689: 1
Branch 13690: 1
Branch 13691: 1
Branch 13692: 1
Branch 13693: 1
Branch 13694: 1
Branch 13695: 1
Branch 13696: 1
Branch 13697: 1
Branch 13698: 1
Branch 13699: 1
Branch 13700: 1
Branch 13701: 1
Branch 13702: 1
Branch 13703: 1
Branch 13704: 1
Branch 13705: 1
Branch 13706: 1
Branch 13707: 1
Branch 13708: 1
Branch 13709: 1
Branch 13710: 1
Branch 13711: 1
Branch 13712: 1
Branch 13713: 1
Branch 13714: 1
Branch 13715: 1
Branch 13716: 1
Branch 13717: 1
Branch 13718: 1
Branch 13719: 1
Branch 13720: 1
Branch 13721: 1
Branch 13722: 1
Branch 13723: 1
Branch 13724: 1
Branch 13725: 1
Branch 13726: 1
Branch 13727: 1
Branch 13728: 1
Branch 13729: 1
Branch 13730: 1
Branch 13731: 1
Branch 13732: 1
Branch 13733: 1
Branch 13734: 1
Branch 13735: 1
Branch 13736: 1
Branch 13737: 1
Branch 13738: 1
Branch 13739: 1
Branch 13740: 1
Branch 13741: 1
Branch 13742: 1
Branch 13743: 1
Branch 13744: 1
Branch 13745: 1
Branch 13746: 1
Branch 13747: 1
Branch 13748: 1
Branch 13749: 1
Branch 13750: 1
Branch 13751: 1
Branch 13752: 1
Branch 13753: 1
Branch 13754: 1
Branch 13755: 1
Branch 13756: 1
Branch 13757: 1
Branch 13758: 1
Branch 13759: 1
Branch 13760: 1
Branch 13761: 1
Branch 13762: 1
Branch 13763: 1
Branch 13764: 1
Branch 13765: 1
Branch 13766: 1
Branch 13767: 1
Branch 13768: 1
Branch 13769: 1
Branch 13770: 1
Branch 13771: 1
Branch 13772: 1
Branch 13773: 1
Branch 13774: 1
Branch 13775: 1
Branch 13776: 1
Branch 13777: 1
Branch 13778: 1
Branch 13779: 1
Branch 13780: 1
Branch 13781: 1
Branch 13782: 1
Branch 13783: 1
Branch 13784: 1
Branch 13785: 1
Branch 13786: 1
Branch 13787: 1
Branch 13788: 1
Branch 13789: 1
Branch 13790: 1
Branch 13791: 1
Branch 13792: 1
Branch 13793: 1
Branch 13794: 1
Branch 13795: 1
Branch 13796: 1
Branch 13797: 1
Branch 13798: 1
Branch 13799: 1
Branch 13800: 1
Branch 13801: 1
Branch 13802: 1
Branch 13803: 1
Branch 13804: 1
Branch 13805: 1
Branch 13806: 1
Branch 13807: 1
Branch 13808: 1
Branch 13809: 1
Branch 13810: 1
Branch 13811: 1
Branch 13812: 1
Branch 13813: 1
Branch 13814: 1
Branch 13815: 1
Branch 13816: 1
Branch 13817: 1
Branch 13818: 1
Branch 13819: 1
Branch 13820: 1
Branch 13821: 1
Branch 13822: 1
Branch 13823: 1
Branch 13824: 1
Branch 13825: 1
Branch 13826: 1
Branch 13827: 1
Branch 13828: 1
Branch 13829: 1
Branch 13830: 1
Branch 13831: 1
Branch 13832: 1
Branch 13833: 1
Branch 13834: 1
Branch 13835: 1
Branch 13836: 1
Branch 13837: 1
Branch 13838: 1
Branch 13839: 1
Branch 13840: 1
Branch 13841: 1
Branch 13842: 1
Branch 13843: 1
Branch 13844: 1
Branch 13845: 1
Branch 13846: 1
Branch 13847: 1
Branch 13848: 1
Branch 13849: 1
Branch 13850: 1
Branch 13851: 1
Branch 13852: 1
Branch 13853: 1
Branch 13854: 1
Branch 13855: 1
Branch 13856: 1
Branch 13857: 1
Branch 13858: 1
Branch 13859: 1
Branch 13860: 1
Branch 13861: 1
Branch 13862: 1
Branch 13863: 1
Branch 13864: 1
Branch 13865: 1
Branch 13866: 1
Branch 13867: 1
Branch 13868: 1
Branch 13869: 1
Branch 13870: 1
Branch 13871: 1
Branch 13872: 1
Branch 13873: 1
Branch 13874: 1
Branch 13875: 1
Branch 13876: 1
Branch 13877: 1
Branch 13878: 1
Branch 13879: 1
Branch 13880: 1
Branch 13881: 1
Branch 13882: 1
Branch 13883: 1
Branch 13884: 1
Branch 13885: 1
Branch 13886: 1
Branch 13887: 1
Branch 13888: 1
Branch 13889: 1
Branch 13890: 1
Branch 13891: 1
Branch 13892: 1
Branch 13893: 1
Branch 13894: 1
Branch 13895: 1
Branch 13896: 1
Branch 13897: 1
Branch 13898: 1
Branch 13899: 1
Branch 13900: 1
Branch 13901: 1
Branch 13902: 1
Branch 13903: 1
Branch 13904: 1
Branch 13905: 1
Branch 13906: 1
Branch 13907: 1
Branch 13908: 1
Branch 13909: 1
Branch 13910: 1
Branch 13911: 1
Branch 13912: 1
Branch 13913: 1
Branch 13914: 1
Branch 13915: 1
Branch 13916: 1
Branch 13917: 1
Branch 13918: 1
Branch 13919: 1
Branch 13920: 1
Branch 13921: 1
Branch 13922: 1
Branch 13923: 1
Branch 13924: 1
Branch 13925: 1
Branch 13926: 1
Branch 13927: 1
Branch 13928: 1
Branch 13929: 1
Branch 13930: 1
Branch 13931: 1
Branch 13932: 1
Branch 13933: 1
Branch 13934: 1
Branch 13935: 1
Branch 13936: 1
Branch 13937: 1
Branch 13938: 1
Branch 13939: 1
Branch 13940: 1
Branch 13941: 1
Branch 13942: 1
Branch 13943: 1
Branch 13944: 1
Branch 13945: 1
Branch 13946: 1
Branch 13947: 1
Branch 13948: 1
Branch 13949: 1
Branch 13950: 1
Branch 13951: 1
Branch 13952: 1
Branch 13953: 1
Branch 13954: 1
Branch 13955: 1
Branch 13956: 1
Branch 13957: 1
Branch 13958: 1
Branch 13959: 1
Branch 13960: 1
Branch 13961: 1
Branch 13962: 1
Branch 13963: 1
Branch 13964: 1
Branch 13965: 1
Branch 13966: 1
Branch 13967: 1
Branch 13968: 1
Branch 13969: 1
Branch 13970: 1
Branch 13971: 1
Branch 13972: 1
Branch 13973: 1
Branch 13974: 1
Branch 13975: 1
Branch 13976: 1
Branch 13977: 1
Branch 13978: 1
Branch 13979: 1
Branch 13980: 1
Branch 13981: 1
Branch 13982: 1
Branch 13983: 1
Branch 13984: 1
Branch 13985: 1
Branch 13986: 1
Branch 13987: 1
Branch 13988: 1
Branch 13989: 1
Branch 13990: 1
Branch 13991: 1
Branch 13992: 1
Branch 13993: 1
Branch 13994: 1
Branch 13995: 1
Branch 13996: 1
Branch 13997: 1
Branch 13998: 1
Branch 13999: 1
Branch 14000: 1
Branch 14001: 1
Branch 14002: 1
Branch 14003: 1
Branch 14004: 1
Branch 14005: 1
Branch 14006: 1
Branch 14007: 1
Branch 14008: 1
Branch 14009: 1
Branch 14010: 1
Branch 14011: 1
Branch 14012: 1
Branch 14013: 1
Branch 14014: 1
Branch 14015: 1
Branch 14016: 1
Branch 14017: 1
Branch 14018: 1
Branch 14019: 1
Branch 14020: 1
Branch 14021: 1
Branch 14022: 1
Branch 14023: 1
Branch 14024: 1
Branch 14025: 1
Branch 14026: 1
Branch 14027: 1
Branch 14028: 1
Branch 14029: 1
Branch 14030: 1
Branch 14031: 1
Branch 14032: 1
Branch 14033: 1
Branch 14034: 1
Branch 14035: 1
Branch 14036: 1
Branch 14037: 1
Branch 14038: 1
Branch 14039: 1
Branch 14040: 1
Branch 14041: 1
Branch 14042: 1
Branch 14043: 1
Branch 14044: 1
Branch 14045: 1
Branch 14046: 1
Branch 14047: 1
Branch 14048: 1
Branch 14049: 1
Branch 14050: 1
Branch 14051: 1
Branch 14052: 1
Branch 14053: 1
Branch 14054: 1
Branch 14055: 1
Branch 14056: 1
Branch 14057: 1
Branch 14058: 1
Branch 14059: 1
Branch 14060: 1
Branch 14061: 1
Branch 14062: 1
Branch 14063: 1
Branch 14064: 1
Branch 14065: 1
Branch 14066: 1
Branch 14067: 1
Branch 14068: 1
Branch 14069: 1
Branch 14070: 1
Branch 14071: 1
Branch 14072: 1
Branch 14073: 1
Branch 14074: 1
Branch 14075: 1
Branch 14076: 1
Branch 14077: 1
Branch 14078: 1
Branch 14079: 1
Branch 14080: 1
Branch 14081: 1
Branch 14082: 1
Branch 14083: 1
Branch 14084: 1
Branch 14085: 1
Branch 14086: 1
Branch 14087: 1
Branch 14088: 1
Branch 14089: 1
Branch 14090: 1
Branch 14091: 1
Branch 14092: 1
Branch 14093: 1
Branch 14094: 1
Branch 14095: 1
Branch 14096: 1
Branch 14097: 1
Branch 14098: 1
Branch 14099: 1
Branch 14100: 1
Branch 14101: 1
Branch 14102: 1
Branch 14103: 1
Branch 14104: 1
Branch 14105: 1
Branch 14106: 1
Branch 14107: 1
Branch 14108: 1
Branch 14109: 1
Branch 14110: 1
Branch 14111: 1
Branch 14112: 1
Branch 14113: 1
Branch 14114: 1
Branch 14115: 1
Branch 14116: 1
Branch 14117: 1
Branch 14118: 1
Branch 14119: 1
Branch 14120: 1
Branch 14121: 1
Branch 14122: 1
Branch 14123: 1
Branch 14124: 1
Branch 14125: 1
Branch 14126: 1
Branch 14127: 1
Branch 14128: 1
Branch 14129: 1
Branch 14130: 1
Branch 14131: 1
Branch 14132: 1
Branch 14133: 1
Branch 14134: 1
Branch 14135: 1
Branch 14136: 1
Branch 14137: 1
Branch 14138: 1
Branch 14139: 1
Branch 14140: 1
Branch 14141: 1
Branch 14142: 1
Branch 14143: 1
Branch 14144: 1
Branch 14145: 1
Branch 14146: 1
Branch 14147: 1
Branch 14148: 1
Branch 14149: 1
Branch 14150: 1
Branch 14151: 1
Branch 14152: 1
Branch 14153: 1
Branch 14154: 1
Branch 14155: 1
Branch 14156: 1
Branch 14157: 1
Branch 14158: 1
Branch 14159: 1
Branch 14160: 1
Branch 14161: 1
Branch 14162: 1
Branch 14163: 1
Branch 14164: 1
Branch 14165: 1
Branch 14166: 1
Branch 14167: 1
Branch 14168: 1
Branch 14169: 1
Branch 14170: 1
Branch 14171: 1
Branch 14172: 1
Branch 14173: 1
Branch 14174: 1
Branch 14175: 1
Branch 14176: 1
Branch 14177: 1
Branch 14178: 1
Branch 14179: 1
Branch 14180: 1
Branch 14181: 1
Branch 14182: 1
Branch 14183: 1
Branch 14184: 1
Branch 14185: 1
Branch 14186: 1
Branch 14187: 1
Branch 14188: 1
Branch 14189: 1
Branch 14190: 1
Branch 14191: 1
Branch 14192: 1
Branch 14193: 1
Branch 14194: 1
Branch 14195: 1
Branch 14196: 1
Branch 14197: 1
Branch 14198: 1
Branch 14199: 1
Branch 14200: 1
Branch 14201: 1
Branch 14202: 1
Branch 14203: 1
Branch 14204: 1
Branch 14205: 1
Branch 14206: 1
Branch 14207: 1
Branch 14208: 1
Branch 14209: 1
Branch 14210: 1
Branch 14211: 1
Branch 14212: 1
Branch 14213: 1
Branch 14214: 1
Branch 14215: 1
Branch 14216: 1
Branch 14217: 1
Branch 14218: 1
Branch 14219: 1
Branch 14220: 1
Branch 14221: 1
Branch 14222: 1
Branch 14223: 1
Branch 14224: 1
Branch 14225: 1
Branch 14226: 1
Branch 14227: 1
Branch 14228: 1
Branch 14229: 1
Branch 14230: 1
Branch 14231: 1
Branch 14232: 1
Branch 14233: 1
Branch 14234: 1
Branch 14235: 1
Branch 14236: 1
Branch 14237: 1
Branch 14238: 1
Branch 14239: 1
Branch 14240: 1
Branch 14241: 1
Branch 14242: 1
Branch 14243: 1
Branch 14244: 1
Branch 14245: 1
Branch 14246: 1
Branch 14247: 1
Branch 14248: 1
Branch 14249: 1
Branch 14250: 1
Branch 14251: 1
Branch 14252: 1
Branch 14253: 1
Branch 14254: 1
Branch 14255: 1
Branch 14256: 1
Branch 14257: 1
Branch 14258: 1
Branch 14259: 1
Branch 14260: 1
Branch 14261: 1
Branch 14262: 1
Branch 14263: 1
Branch 14264: 1
Branch 14265: 1
Branch 14266: 1
Branch 14267: 1
Branch 14268: 1
Branch 14269: 1
Branch 14270: 1
Branch 14271: 1
Branch 14272: 1
Branch 14273: 1
Branch 14274: 1
Branch 14275: 1
Branch 14276: 1
Branch 14277: 1
Branch 14278: 1
Branch 14279: 1
Branch 14280: 1
Branch 14281: 1
Branch 14282: 1
Branch 14283: 1
Branch 14284: 1
Branch 14285: 1
Branch 14286: 1
Branch 14287: 1
Branch 14288: 1
Branch 14289: 1
Branch 14290: 1
Branch 14291: 1
Branch 14292: 1
Branch 14293: 1
Branch 14294: 1
Branch 14295: 1
Branch 14296: 1
Branch 14297: 1
Branch 14298: 1
Branch 14299: 1
Branch 14300: 1
Branch 14301: 1
Branch 14302: 1
Branch 14303: 1
Branch 14304: 1
Branch 14305: 1
Branch 14306: 1
Branch 14307: 1
Branch 14308: 1
Branch 14309: 1
Branch 14310: 1
Branch 14311: 1
Branch 14312: 1
Branch 14313: 1
Branch 14314: 1
Branch 14315: 1
Branch 14316: 1
Branch 14317: 1
Branch 14318: 1
Branch 14319: 1
Branch 14320: 1
Branch 14321: 1
Branch 14322: 1
Branch 14323: 1
Branch 14324: 1
Branch 14325: 1
Branch 14326: 1
Branch 14327: 1
Branch 14328: 1
Branch 14329: 1
Branch 14330: 1
Branch 14331: 1
Branch 14332: 1
Branch 14333: 1
Branch 14334: 1
Branch 14335: 1
Branch 14336: 1
Branch 14337: 1
Branch 14338: 1
Branch 14339: 1
Branch 14340: 1
Branch 14341: 1
Branch 14342: 1
Branch 14343: 1
Branch 14344: 1
Branch 14345: 1
Branch 14346: 1
Branch 14347: 1
Branch 14348: 1
Branch 14349: 1
Branch 14350: 1
Branch 14351: 1
Branch 14352: 1
Branch 14353: 1
Branch 14354: 1
Branch 14355: 1
Branch 14356: 1
Branch 14357: 1
Branch 14358: 1
Branch 14359: 1
Branch 14360: 1
Branch 14361: 1
Branch 14362: 1
Branch 14363: 1
Branch 14364: 1
Branch 14365: 1
Branch 14366: 1
Branch 14367: 1
Branch 14368: 1
Branch 14369: 1
Branch 14370: 1
Branch 14371: 1
Branch 14372: 1
Branch 14373: 1
Branch 14374: 1
Branch 14375: 1
Branch 14376: 1
Branch 14377: 1
Branch 14378: 1
Branch 14379: 1
Branch 14380: 1
Branch 14381: 1
Branch 14382: 1
Branch 14383: 1
Branch 14384: 1
Branch 14385: 1
Branch 14386: 1
Branch 14387: 1
Branch 14388: 1
Branch 14389: 1
Branch 14390: 1
Branch 14391: 1
Branch 14392: 1
Branch 14393: 1
Branch 14394: 1
Branch 14395: 1
Branch 14396: 1
Branch 14397: 1
Branch 14398: 1
Branch 14399: 1
Branch 14400: 1
Branch 14401: 1
Branch 14402: 1
Branch 14403: 1
Branch 14404: 1
Branch 14405: 1
Branch 14406: 1
Branch 14407: 1
Branch 14408: 1
Branch 14409: 1
Branch 14410: 1
Branch 14411: 1
Branch 14412: 1
Branch 14413: 1
Branch 14414: 1
Branch 14415: 1
Branch 14416: 1
Branch 14417: 1
Branch 14418: 1
Branch 14419: 1
Branch 14420: 1
Branch 14421: 1
Branch 14422: 1
Branch 14423: 1
Branch 14424: 1
Branch 14425: 1
Branch 14426: 1
Branch 14427: 1
Branch 14428: 1
Branch 14429: 1
Branch 14430: 1
Branch 14431: 1
Branch 14432: 1
Branch 14433: 1
Branch 14434: 1
Branch 14435: 1
Branch 14436: 1
Branch 14437: 1
Branch 14438: 1
Branch 14439: 1
Branch 14440: 1
Branch 14441: 1
Branch 14442: 1
Branch 14443: 1
Branch 14444: 1
Branch 14445: 1
Branch 14446: 1
Branch 14447: 1
Branch 14448: 1
Branch 14449: 1
Branch 14450: 1
Branch 14451: 1
Branch 14452: 1
Branch 14453: 1
Branch 14454: 1
Branch 14455: 1
Branch 14456: 1
Branch 14457: 1
Branch 14458: 1
Branch 14459: 1
Branch 14460: 1
Branch 14461: 1
Branch 14462: 1
Branch 14463: 1
Branch 14464: 1
Branch 14465: 1
Branch 14466: 1
Branch 14467: 1
Branch 14468: 1
Branch 14469: 1
Branch 14470: 1
Branch 14471: 1
Branch 14472: 1
Branch 14473: 1
Branch 14474: 1
Branch 14475: 1
Branch 14476: 1
Branch 14477: 1
Branch 14478: 1
Branch 14479: 1
Branch 14480: 1
Branch 14481: 1
Branch 14482: 1
Branch 14483: 1
Branch 14484: 1
Branch 14485: 1
Branch 14486: 1
Branch 14487: 1
Branch 14488: 1
Branch 14489: 1
Branch 14490: 1
Branch 14491: 1
Branch 14492: 1
Branch 14493: 1
Branch 14494: 1
Branch 14495: 1
Branch 14496: 1
Branch 14497: 1
Branch 14498: 1
Branch 14499: 1
Branch 14500: 1
Branch 14501: 1
Branch 14502: 1
Branch 14503: 1
Branch 14504: 1
Branch 14505: 1
Branch 14506: 1
Branch 14507: 1
Branch 14508: 1
Branch 14509: 1
Branch 14510: 1
Branch 14511: 1
Branch 14512: 1
Branch 14513: 1
Branch 14514: 1
Branch 14515: 1
Branch 14516: 1
Branch 14517: 1
Branch 14518: 1
Branch 14519: 1
Branch 14520: 1
Branch 14521: 1
Branch 14522: 1
Branch 14523: 1
Branch 14524: 1
Branch 14525: 1
Branch 14526: 1
Branch 14527: 1
Branch 14528: 1
Branch 14529: 1
Branch 14530: 1
Branch 14531: 1
Branch 14532: 1
Branch 14533: 1
Branch 14534: 1
Branch 14535: 1
Branch 14536: 1
Branch 14537: 1
Branch 14538: 1
Branch 14539: 1
Branch 14540: 1
Branch 14541: 1
Branch 14542: 1
Branch 14543: 1
Branch 14544: 1
Branch 14545: 1
Branch 14546: 1
Branch 14547: 1
Branch 14548: 1
Branch 14549: 1
Branch 14550: 1
Branch 14551: 1
Branch 14552: 1
Branch 14553: 1
Branch 14554: 1
Branch 14555: 1
Branch 14556: 1
Branch 14557: 1
Branch 14558: 1
Branch 14559: 1
Branch 14560: 1
Branch 14561: 1
Branch 14562: 1
Branch 14563: 1
Branch 14564: 1
Branch 14565: 1
Branch 14566: 1
Branch 14567: 1
Branch 14568: 1
Branch 14569: 1
Branch 14570: 1
Branch 14571: 1
Branch 14572: 1
Branch 14573: 1
Branch 14574: 1
Branch 14575: 1
Branch 14576: 1
Branch 14577: 1
Branch 14578: 1
Branch 14579: 1
Branch 14580: 1
Branch 14581: 1
Branch 14582: 1
Branch 14583: 1
Branch 14584: 1
Branch 14585: 1
Branch 14586: 1
Branch 14587: 1
Branch 14588: 1
Branch 14589: 1
Branch 14590: 1
Branch 14591: 1
Branch 14592: 1
Branch 14593: 1
Branch 14594: 1
Branch 14595: 1
Branch 14596: 1
Branch 14597: 1
Branch 14598: 1
Branch 14599: 1
Branch 14600: 1
Branch 14601: 1
Branch 14602: 1
Branch 14603: 1
Branch 14604: 1
Branch 14605: 1
Branch 14606: 1
Branch 14607: 1
Branch 14608: 1
Branch 14609: 1
Branch 14610: 1
Branch 14611: 1
Branch 14612: 1
Branch 14613: 1
Branch 14614: 1
Branch 14615: 1
Branch 14616: 1
Branch 14617: 1
Branch 14618: 1
Branch 14619: 1
Branch 14620: 1
Branch 14621: 1
Branch 14622: 1
Branch 14623: 1
Branch 14624: 1
Branch 14625: 1
Branch 14626: 1
Branch 14627: 1
Branch 14628: 1
Branch 14629: 1
Branch 14630: 1
Branch 14631: 1
Branch 14632: 1
Branch 14633: 1
Branch 14634: 1
Branch 14635: 1
Branch 14636: 1
Branch 14637: 1
Branch 14638: 1
Branch 14639: 1
Branch 14640: 1
Branch 14641: 1
Branch 14642: 1
Branch 14643: 1
Branch 14644: 1
Branch 14645: 1
Branch 14646: 1
Branch 14647: 1
Branch 14648: 1
Branch 14649: 1
Branch 14650: 1
Branch 14651: 1
Branch 14652: 1
Branch 14653: 1
Branch 14654: 1
Branch 14655: 1
Branch 14656: 1
Branch 14657: 1
Branch 14658: 1
Branch 14659: 1
Branch 14660: 1
Branch 14661: 1
Branch 14662: 1
Branch 14663: 1
Branch 14664: 1
Branch 14665: 1
Branch 14666: 1
Branch 14667: 1
Branch 14668: 1
Branch 14669: 1
Branch 14670: 1
Branch 14671: 1
Branch 14672: 1
Branch 14673: 1
Branch 14674: 1
Branch 14675: 1
Branch 14676: 1
Branch 14677: 1
Branch 14678: 1
Branch 14679: 1
Branch 14680: 1
Branch 14681: 1
Branch 14682: 1
Branch 14683: 1
Branch 14684: 1
Branch 14685: 1
Branch 14686: 1
Branch 14687: 1
Branch 14688: 1
Branch 14689: 1
Branch 14690: 1
Branch 14691: 1
Branch 14692: 1
Branch 14693: 1
Branch 14694: 1
Branch 14695: 1
Branch 14696: 1
Branch 14697: 1
Branch 14698: 1
Branch 14699: 1
Branch 14700: 1
Branch 14701: 1
Branch 14702: 1
Branch 14703: 1
Branch 14704: 1
Branch 14705: 1
Branch 14706: 1
Branch 14707: 1
Branch 14708: 1
Branch 14709: 1
Branch 14710: 1
Branch 14711: 1
Branch 14712: 1
Branch 14713: 1
Branch 14714: 1
Branch 14715: 1
Branch 14716: 1
Branch 14717: 1
Branch 14718: 1
Branch 14719: 1
Branch 14720: 1
Branch 14721: 1
Branch 14722: 1
Branch 14723: 1
Branch 14724: 1
Branch 14725: 1
Branch 14726: 1
Branch 14727: 1
Branch 14728: 1
Branch 14729: 1
Branch 14730: 1
Branch 14731: 1
Branch 14732: 1
Branch 14733: 1
Branch 14734: 1
Branch 14735: 1
Branch 14736: 1
Branch 14737: 1
Branch 14738: 1
Branch 14739: 1
Branch 14740: 1
Branch 14741: 1
Branch 14742: 1
Branch 14743: 1
Branch 14744: 1
Branch 14745: 1
Branch 14746: 1
Branch 14747: 1
Branch 14748: 1
Branch 14749: 1
Branch 14750: 1
Branch 14751: 1
Branch 14752: 1
Branch 14753: 1
Branch 14754: 1
Branch 14755: 1
Branch 14756: 1
Branch 14757: 1
Branch 14758: 1
Branch 14759: 1
Branch 14760: 1
Branch 14761: 1
Branch 14762: 1
Branch 14763: 1
Branch 14764: 1
Branch 14765: 1
Branch 14766: 1
Branch 14767: 1
Branch 14768: 1
Branch 14769: 1
Branch 14770: 1
Branch 14771: 1
Branch 14772: 1
Branch 14773: 1
Branch 14774: 1
Branch 14775: 1
Branch 14776: 1
Branch 14777: 1
Branch 14778: 1
Branch 14779: 1
Branch 14780: 1
Branch 14781: 1
Branch 14782: 1
Branch 14783: 1
Branch 14784: 1
Branch 14785: 1
Branch 14786: 1
Branch 14787: 1
Branch 14788: 1
Branch 14789: 1
Branch 14790: 1
Branch 14791: 1
Branch 14792: 1
Branch 14793: 1
Branch 14794: 1
Branch 14795: 1
Branch 14796: 1
Branch 14797: 1
Branch 14798: 1
Branch 14799: 1
Branch 14800: 1
Branch 14801: 1
Branch 14802: 1
Branch 14803: 1
Branch 14804: 1
Branch 14805: 1
Branch 14806: 1
Branch 14807: 1
Branch 14808: 1
Branch 14809: 1
Branch 14810: 1
Branch 14811: 1
Branch 14812: 1
Branch 14813: 1
Branch 14814: 1
Branch 14815: 1
Branch 14816: 1
Branch 14817: 1
Branch 14818: 1
Branch 14819: 1
Branch 14820: 1
Branch 14821: 1
Branch 14822: 1
Branch 14823: 1
Branch 14824: 1
Branch 14825: 1
Branch 14826: 1
Branch 14827: 1
Branch 14828: 1
Branch 14829: 1
Branch 14830: 1
Branch 14831: 1
Branch 14832: 1
Branch 14833: 1
Branch 14834: 1
Branch 14835: 1
Branch 14836: 1
Branch 14837: 1
Branch 14838: 1
Branch 14839: 1
Branch 14840: 1
Branch 14841: 1
Branch 14842: 1
Branch 14843: 1
Branch 14844: 1
Branch 14845: 1
Branch 14846: 1
Branch 14847: 1
Branch 14848: 1
Branch 14849: 1
Branch 14850: 1
Branch 14851: 1
Branch 14852: 1
Branch 14853: 1
Branch 14854: 1
Branch 14855: 1
Branch 14856: 1
Branch 14857: 1
Branch 14858: 1
Branch 14859: 1
Branch 14860: 1
Branch 14861: 1
Branch 14862: 1
Branch 14863: 1
Branch 14864: 1
Branch 14865: 1
Branch 14866: 1
Branch 14867: 1
Branch 14868: 1
Branch 14869: 1
Branch 14870: 1
Branch 14871: 1
Branch 14872: 1
Branch 14873: 1
Branch 14874: 1
Branch 14875: 1
Branch 14876: 1
Branch 14877: 1
Branch 14878: 1
Branch 14879: 1
Branch 14880: 1
Branch 14881: 1
Branch 14882: 1
Branch 14883: 1
Branch 14884: 1
Branch 14885: 1
Branch 14886: 1
Branch 14887: 1
Branch 14888: 1
Branch 14889: 1
Branch 14890: 1
Branch 14891: 1
Branch 14892: 1
Branch 14893: 1
Branch 14894: 1
Branch 14895: 1
Branch 14896: 1
Branch 14897: 1
Branch 14898: 1
Branch 14899: 1
Branch 14900: 1
Branch 14901: 1
Branch 14902: 1
Branch 14903: 1
Branch 14904: 1
Branch 14905: 1
Branch 14906: 1
Branch 14907: 1
Branch 14908: 1
Branch 14909: 1
Branch 14910: 1
Branch 14911: 1
Branch 14912: 1
Branch 14913: 1
Branch 14914: 1
Branch 14915: 1
Branch 14916: 1
Branch 14917: 1
Branch 14918: 1
Branch 14919: 1
Branch 14920: 1
Branch 14921: 1
Branch 14922: 1
Branch 14923: 1
Branch 14924: 1
Branch 14925: 1
Branch 14926: 1
Branch 14927: 1
Branch 14928: 1
Branch 14929: 1
Branch 14930: 1
Branch 14931: 1
Branch 14932: 1
Branch 14933: 1
Branch 14934: 1
Branch 14935: 1
Branch 14936: 1
Branch 14937: 1
Branch 14938: 1
Branch 14939: 1
Branch 14940: 1
Branch 14941: 1
Branch 14942: 1
Branch 14943: 1
Branch 14944: 1
Branch 14945: 1
Branch 14946: 1
Branch 14947: 1
Branch 14948: 1
Branch 14949: 1
Branch 14950: 1
Branch 14951: 1
Branch 14952: 1
Branch 14953: 1
Branch 14954: 1
Branch 14955: 1
Branch 14956: 1
Branch 14957: 1
Branch 14958: 1
Branch 14959: 1
Branch 14960: 1
Branch 14961: 1
Branch 14962: 1
Branch 14963: 1
Branch 14964: 1
Branch 14965: 1
Branch 14966: 1
Branch 14967: 1
Branch 14968: 1
Branch 14969: 1
Branch 14970: 1
Branch 14971: 1
Branch 14972: 1
Branch 14973: 1
Branch 14974: 1
Branch 14975: 1
Branch 14976: 1
Branch 14977: 1
Branch 14978: 1
Branch 14979: 1
Branch 14980: 1
Branch 14981: 1
Branch 14982: 1
Branch 14983: 1
Branch 14984: 1
Branch 14985: 1
Branch 14986: 1
Branch 14987: 1
Branch 14988: 1
Branch 14989: 1
Branch 14990: 1
Branch 14991: 1
Branch 14992: 1
Branch 14993: 1
Branch 14994: 1
Branch 14995: 1
Branch 14996: 1
Branch 14997: 1
Branch 14998: 1
Branch 14999: 1
Branch 15000: 1
Branch 15001: 1
Branch 15002: 1
Branch 15003: 1
Branch 15004: 1
Branch 15005: 1
Branch 15006: 1
Branch 15007: 1
Branch 15008: 1
Branch 15009: 1
Branch 15010: 1
Branch 15011: 1
Branch 15012: 1
Branch 15013: 1
Branch 15014: 1
Branch 15015: 1
Branch 15016: 1
Branch 15017: 1
Branch 15018: 1
Branch 15019: 1
Branch 15020: 1
Branch 15021: 1
Branch 15022: 1
Branch 15023: 1
Branch 15024: 1
Branch 15025: 1
Branch 15026: 1
Branch 15027: 1
Branch 15028: 1
Branch 15029: 1
Branch 15030: 1
Branch 15031: 1
Branch 15032: 1
Branch 15033: 1
Branch 15034: 1
Branch 15035: 1
Branch 15036: 1
Branch 15037: 1
Branch 15038: 1
Branch 15039: 1
Branch 15040: 1
Branch 15041: 1
Branch 15042: 1
Branch 15043: 1
Branch 15044: 1
Branch 15045: 1
Branch 15046: 1
Branch 15047: 1
Branch 15048: 1
Branch 15049: 1
Branch 15050: 1
Branch 15051: 1
Branch 15052: 1
Branch 15053: 1
Branch 15054: 1
Branch 15055: 1
Branch 15056: 1
Branch 15057: 1
Branch 15058: 1
Branch 15059: 1
Branch 15060: 1
Branch 15061: 1
Branch 15062: 1
Branch 15063: 1
Branch 15064: 1
Branch 15065: 1
Branch 15066: 1
Branch 15067: 1
Branch 15068: 1
Branch 15069: 1
Branch 15070: 1
Branch 15071: 1
Branch 15072: 1
Branch 15073: 1
Branch 15074: 1
Branch 15075: 1
Branch 15076: 1
Branch 15077: 1
Branch 15078: 1
Branch 15079: 1
Branch 15080: 1
Branch 15081: 1
Branch 15082: 1
Branch 15083: 1
Branch 15084: 1
Branch 15085: 1
Branch 15086: 1
Branch 15087: 1
Branch 15088: 1
Branch 15089: 1
Branch 15090: 1
Branch 15091: 1
Branch 15092: 1
Branch 15093: 1
Branch 15094: 1
Branch 15095: 1
Branch 15096: 1
Branch 15097: 1
Branch 15098: 1
Branch 15099: 1
Branch 15100: 1
Branch 15101: 1
Branch 15102: 1
Branch 15103: 1
Branch 15104: 1
Branch 15105: 1
Branch 15106: 1
Branch 15107: 1
Branch 15108: 1
Branch 15109: 1
Branch 15110: 1
Branch 15111: 1
Branch 15112: 1
Branch 15113: 1
Branch 15114: 1
Branch 15115: 1
Branch 15116: 1
Branch 15117: 1
Branch 15118: 1
Branch 15119: 1
Branch 15120: 1
Branch 15121: 1
Branch 15122: 1
Branch 15123: 1
Branch 15124: 1
Branch 15125: 1
Branch 15126: 1
Branch 15127: 1
Branch 15128: 1
Branch 15129: 1
Branch 15130: 1
Branch 15131: 1
Branch 15132: 1
Branch 15133: 1
Branch 15134: 1
Branch 15135: 1
Branch 15136: 1
Branch 15137: 1
Branch 15138: 1
Branch 15139: 1
Branch 15140: 1
Branch 15141: 1
Branch 15142: 1
Branch 15143: 1
Branch 15144: 1
Branch 15145: 1
Branch 15146: 1
Branch 15147: 1
Branch 15148: 1
Branch 15149: 1
Branch 15150: 1
Branch 15151: 1
Branch 15152: 1
Branch 15153: 1
Branch 15154: 1
Branch 15155: 1
Branch 15156: 1
Branch 15157: 1
Branch 15158: 1
Branch 15159: 1
Branch 15160: 1
Branch 15161: 1
Branch 15162: 1
Branch 15163: 1
Branch 15164: 1
Branch 15165: 1
Branch 15166: 1
Branch 15167: 1
Branch 15168: 1
Branch 15169: 1
Branch 15170: 1
Branch 15171: 1
Branch 15172: 1
Branch 15173: 1
Branch 15174: 1
Branch 15175: 1
Branch 15176: 1
Branch 15177: 1
Branch 15178: 1
Branch 15179: 1
Branch 15180: 1
Branch 15181: 1
Branch 15182: 1
Branch 15183: 1
Branch 15184: 1
Branch 15185: 1
Branch 15186: 1
Branch 15187: 1
Branch 15188: 1
Branch 15189: 1
Branch 15190: 1
Branch 15191: 1
Branch 15192: 1
Branch 15193: 1
Branch 15194: 1
Branch 15195: 1
Branch 15196: 1
Branch 15197: 1
Branch 15198: 1
Branch 15199: 1
Branch 15200: 1
Branch 15201: 1
Branch 15202: 1
Branch 15203: 1
Branch 15204: 1
Branch 15205: 1
Branch 15206: 1
Branch 15207: 1
Branch 15208: 1
Branch 15209: 1
Branch 15210: 1
Branch 15211: 1
Branch 15212: 1
Branch 15213: 1
Branch 15214: 1
Branch 15215: 1
Branch 15216: 1
Branch 15217: 1
Branch 15218: 1
Branch 15219: 1
Branch 15220: 1
Branch 15221: 1
Branch 15222: 1
Branch 15223: 1
Branch 15224: 1
Branch 15225: 1
Branch 15226: 1
Branch 15227: 1
Branch 15228: 1
Branch 15229: 1
Branch 15230: 1
Branch 15231: 1
Branch 15232: 1
Branch 15233: 1
Branch 15234: 1
Branch 15235: 1
Branch 15236: 1
Branch 15237: 1
Branch 15238: 1
Branch 15239: 1
Branch 15240: 1
Branch 15241: 1
Branch 15242: 1
Branch 15243: 1
Branch 15244: 1
Branch 15245: 1
Branch 15246: 1
Branch 15247: 1
Branch 15248: 1
Branch 15249: 1
Branch 15250: 1
Branch 15251: 1
Branch 15252: 1
Branch 15253: 1
Branch 15254: 1
Branch 15255: 1
Branch 15256: 1
Branch 15257: 1
Branch 15258: 1
Branch 15259: 1
Branch 15260: 1
Branch 15261: 1
Branch 15262: 1
Branch 15263: 1
Branch 15264: 1
Branch 15265: 1
Branch 15266: 1
Branch 15267: 1
Branch 15268: 1
Branch 15269: 1
Branch 15270: 1
Branch 15271: 1
Branch 15272: 1
Branch 15273: 1
Branch 15274: 1
Branch 15275: 1
Branch 15276: 1
Branch 15277: 1
Branch 15278: 1
Branch 15279: 1
Branch 15280: 1
Branch 15281: 1
Branch 15282: 1
Branch 15283: 1
Branch 15284: 1
Branch 15285: 1
Branch 15286: 1
Branch 15287: 1
Branch 15288: 1
Branch 15289: 1
Branch 15290: 1
Branch 15291: 1
Branch 15292: 1
Branch 15293: 1
Branch 15294: 1
Branch 15295: 1
Branch 15296: 1
Branch 15297: 1
Branch 15298: 1
Branch 15299: 1
Branch 15300: 1
Branch 15301: 1
Branch 15302: 1
Branch 15303: 1
Branch 15304: 1
Branch 15305: 1
Branch 15306: 1
Branch 15307: 1
Branch 15308: 1
Branch 15309: 1
Branch 15310: 1
Branch 15311: 1
Branch 15312: 1
Branch 15313: 1
Branch 15314: 1
Branch 15315: 1
Branch 15316: 1
Branch 15317: 1
Branch 15318: 1
Branch 15319: 1
Branch 15320: 1
Branch 15321: 1
Branch 15322: 1
Branch 15323: 1
Branch 15324: 1
Branch 15325: 1
Branch 15326: 1
Branch 15327: 1
Branch 15328: 1
Branch 15329: 1
Branch 15330: 1
Branch 15331: 1
Branch 15332: 1
Branch 15333: 1
Branch 15334: 1
Branch 15335: 1
Branch 15336: 1
Branch 15337: 1
Branch 15338: 1
Branch 15339: 1
Branch 15340: 1
Branch 15341: 1
Branch 15342: 1
Branch 15343: 1
Branch 15344: 1
Branch 15345: 1
Branch 15346: 1
Branch 15347: 1
Branch 15348: 1
Branch 15349: 1
Branch 15350: 1
Branch 15351: 1
Branch 15352: 1
Branch 15353: 1
Branch 15354: 1
Branch 15355: 1
Branch 15356: 1
Branch 15357: 1
Branch 15358: 1
Branch 15359: 1
Branch 15360: 1
Branch 15361: 1
Branch 15362: 1
Branch 15363: 1
Branch 15364: 1
Branch 15365: 1
Branch 15366: 1
Branch 15367: 1
Branch 15368: 1
Branch 15369: 1
Branch 15370: 1
Branch 15371: 1
Branch 15372: 1
Branch 15373: 1
Branch 15374: 1
Branch 15375: 1
Branch 15376: 1
Branch 15377: 1
Branch 15378: 1
Branch 15379: 1
Branch 15380: 1
Branch 15381: 1
Branch 15382: 1
Branch 15383: 1
Branch 15384: 1
Branch 15385: 1
Branch 15386: 1
Branch 15387: 1
Branch 15388: 1
Branch 15389: 1
Branch 15390: 1
Branch 15391: 1
Branch 15392: 1
Branch 15393: 1
Branch 15394: 1
Branch 15395: 1
Branch 15396: 1
Branch 15397: 1
Branch 15398: 1
Branch 15399: 1
Branch 15400: 1
Branch 15401: 1
Branch 15402: 1
Branch 15403: 1
Branch 15404: 1
Branch 15405: 1
Branch 15406: 1
Branch 15407: 1
Branch 15408: 1
Branch 15409: 1
Branch 15410: 1
Branch 15411: 1
Branch 15412: 1
Branch 15413: 1
Branch 15414: 1
Branch 15415: 1
Branch 15416: 1
Branch 15417: 1
Branch 15418: 1
Branch 15419: 1
Branch 15420: 1
Branch 15421: 1
Branch 15422: 1
Branch 15423: 1
Branch 15424: 1
Branch 15425: 1
Branch 15426: 1
Branch 15427: 1
Branch 15428: 1
Branch 15429: 1
Branch 15430: 1
Branch 15431: 1
Branch 15432: 1
Branch 15433: 1
Branch 15434: 1
Branch 15435: 1
Branch 15436: 1
Branch 15437: 1
Branch 15438: 1
Branch 15439: 1
Branch 15440: 1
Branch 15441: 1
Branch 15442: 1
Branch 15443: 1
Branch 15444: 1
Branch 15445: 1
Branch 15446: 1
Branch 15447: 1
Branch 15448: 1
Branch 15449: 1
Branch 15450: 1
Branch 15451: 1
Branch 15452: 1
Branch 15453: 1
Branch 15454: 1
Branch 15455: 1
Branch 15456: 1
Branch 15457: 1
Branch 15458: 1
Branch 15459: 1
Branch 15460: 1
Branch 15461: 1
Branch 15462: 1
Branch 15463: 1
Branch 15464: 1
Branch 15465: 1
Branch 15466: 1
Branch 15467: 1
Branch 15468: 1
Branch 15469: 1
Branch 15470: 1
Branch 15471: 1
Branch 15472: 1
Branch 15473: 1
Branch 15474: 1
Branch 15475: 1
Branch 15476: 1
Branch 15477: 1
Branch 15478: 1
Branch 15479: 1
Branch 15480: 1
Branch 15481: 1
Branch 15482: 1
Branch 15483: 1
Branch 15484: 1
Branch 15485: 1
Branch 15486: 1
Branch 15487: 1
Branch 15488: 1
Branch 15489: 1
Branch 15490: 1
Branch 15491: 1
Branch 15492: 1
Branch 15493: 1
Branch 15494: 1
Branch 15495: 1
Branch 15496: 1
Branch 15497: 1
Branch 15498: 1
Branch 15499: 1
Branch 15500: 1
Branch 15501: 1
Branch 15502: 1
Branch 15503: 1
Branch 15504: 1
Branch 15505: 1
Branch 15506: 1
Branch 15507: 1
Branch 15508: 1
Branch 15509: 1
Branch 15510: 1
Branch 15511: 1
Branch 15512: 1
Branch 15513: 1
Branch 15514: 1
Branch 15515: 1
Branch 15516: 1
Branch 15517: 1
Branch 15518: 1
Branch 15519: 1
Branch 15520: 1
Branch 15521: 1
Branch 15522: 1
Branch 15523: 1
Branch 15524: 1
Branch 15525: 1
Branch 15526: 1
Branch 15527: 1
Branch 15528: 1
Branch 15529: 1
Branch 15530: 1
Branch 15531: 1
Branch 15532: 1
Branch 15533: 1
Branch 15534: 1
Branch 15535: 1
Branch 15536: 1
Branch 15537: 1
Branch 15538: 1
Branch 15539: 1
Branch 15540: 1
Branch 15541: 1
Branch 15542: 1
Branch 15543: 1
Branch 15544: 1
Branch 15545: 1
Branch 15546: 1
Branch 15547: 1
Branch 15548: 1
Branch 15549: 1
Branch 15550: 1
Branch 15551: 1
Branch 15552: 1
Branch 15553: 1
Branch 15554: 1
Branch 15555: 1
Branch 15556: 1
Branch 15557: 1
Branch 15558: 1
Branch 15559: 1
Branch 15560: 1
Branch 15561: 1
Branch 15562: 1
Branch 15563: 1
Branch 15564: 1
Branch 15565: 1
Branch 15566: 1
Branch 15567: 1
Branch 15568: 1
Branch 15569: 1
Branch 15570: 1
Branch 15571: 1
Branch 15572: 1
Branch 15573: 1
Branch 15574: 1
Branch 15575: 1
Branch 15576: 1
Branch 15577: 1
Branch 15578: 1
Branch 15579: 1
Branch 15580: 1
Branch 15581: 1
Branch 15582: 1
Branch 15583: 1
Branch 15584: 1
Branch 15585: 1
Branch 15586: 1
Branch 15587: 1
Branch 15588: 1
Branch 15589: 1
Branch 15590: 1
Branch 15591: 1
Branch 15592: 1
Branch 15593: 1
Branch 15594: 1
Branch 15595: 1
Branch 15596: 1
Branch 15597: 1
Branch 15598: 1
Branch 15599: 1
Branch 15600: 1
Branch 15601: 1
Branch 15602: 1
Branch 15603: 1
Branch 15604: 1
Branch 15605: 1
Branch 15606: 1
Branch 15607: 1
Branch 15608: 1
Branch 15609: 1
Branch 15610: 1
Branch 15611: 1
Branch 15612: 1
Branch 15613: 1
Branch 15614: 1
Branch 15615: 1
Branch 15616: 1
Branch 15617: 1
Branch 15618: 1
Branch 15619: 1
Branch 15620: 1
Branch 15621: 1
Branch 15622: 1
Branch 15623: 1
Branch 15624: 1
Branch 15625: 1
Branch 15626: 1
Branch 15627: 1
Branch 15628: 1
Branch 15629: 1
Branch 15630: 1
Branch 15631: 1
Branch 15632: 1
Branch 15633: 1
Branch 15634: 1
Branch 15635: 1
Branch 15636: 1
Branch 15637: 1
Branch 15638: 1
Branch 15639: 1
Branch 15640: 1
Branch 15641: 1
Branch 15642: 1
Branch 15643: 1
Branch 15644: 1
Branch 15645: 1
Branch 15646: 1
Branch 15647: 1
Branch 15648: 1
Branch 15649: 1
Branch 15650: 1
Branch 15651: 1
Branch 15652: 1
Branch 15653: 1
Branch 15654: 1
Branch 15655: 1
Branch 15656: 1
Branch 15657: 1
Branch 15658: 1
Branch 15659: 1
Branch 15660: 1
Branch 15661: 1
Branch 15662: 1
Branch 15663: 1
Branch 15664: 1
Branch 15665: 1
Branch 15666: 1
Branch 15667: 1
Branch 15668: 1
Branch 15669: 1
Branch 15670: 1
Branch 15671: 1
Branch 15672: 1
Branch 15673: 1
Branch 15674: 1
Branch 15675: 1
Branch 15676: 1
Branch 15677: 1
Branch 15678: 1
Branch 15679: 1
Branch 15680: 1
Branch 15681: 1
Branch 15682: 1
Branch 15683: 1
Branch 15684: 1
Branch 15685: 1
Branch 15686: 1
Branch 15687: 1
Branch 15688: 1
Branch 15689: 1
Branch 15690: 1
Branch 15691: 1
Branch 15692: 1
Branch 15693: 1
Branch 15694: 1
Branch 15695: 1
Branch 15696: 1
Branch 15697: 1
Branch 15698: 1
Branch 15699: 1
Branch 15700: 1
Branch 15701: 1
Branch 15702: 1
Branch 15703: 1
Branch 15704: 1
Branch 15705: 1
Branch 15706: 1
Branch 15707: 1
Branch 15708: 1
Branch 15709: 1
Branch 15710: 1
Branch 15711: 1
Branch 15712: 1
Branch 15713: 1
Branch 15714: 1
Branch 15715: 1
Branch 15716: 1
Branch 15717: 1
Branch 15718: 1
Branch 15719: 1
Branch 15720: 1
Branch 15721: 1
Branch 15722: 1
Branch 15723: 1
Branch 15724: 1
Branch 15725: 1
Branch 15726: 1
Branch 15727: 1
Branch 15728: 1
Branch 15729: 1
Branch 15730: 1
Branch 15731: 1
Branch 15732: 1
Branch 15733: 1
Branch 15734: 1
Branch 15735: 1
Branch 15736: 1
Branch 15737: 1
Branch 15738: 1
Branch 15739: 1
Branch 15740: 1
Branch 15741: 1
Branch 15742: 1
Branch 15743: 1
Branch 15744: 1
Branch 15745: 1
Branch 15746: 1
Branch 15747: 1
Branch 15748: 1
Branch 15749: 1
Branch 15750: 1
Branch 15751: 1
Branch 15752: 1
Branch 15753: 1
Branch 15754: 1
Branch 15755: 1
Branch 15756: 1
Branch 15757: 1
Branch 15758: 1
Branch 15759: 1
Branch 15760: 1
Branch 15761: 1
Branch 15762: 1
Branch 15763: 1
Branch 15764: 1
Branch 15765: 1
Branch 15766: 1
Branch 15767: 1
Branch 15768: 1
Branch 15769: 1
Branch 15770: 1
Branch 15771: 1
Branch 15772: 1
Branch 15773: 1
Branch 15774: 1
Branch 15775: 1
Branch 15776: 1
Branch 15777: 1
Branch 15778: 1
Branch 15779: 1
Branch 15780: 1
Branch 15781: 1
Branch 15782: 1
Branch 15783: 1
Branch 15784: 1
Branch 15785: 1
Branch 15786: 1
Branch 15787: 1
Branch 15788: 1
Branch 15789: 1
Branch 15790: 1
Branch 15791: 1
Branch 15792: 1
Branch 15793: 1
Branch 15794: 1
Branch 15795: 1
Branch 15796: 1
Branch 15797: 1
Branch 15798: 1
Branch 15799: 1
Branch 15800: 1
Branch 15801: 1
Branch 15802: 1
Branch 15803: 1
Branch 15804: 1
Branch 15805: 1
Branch 15806: 1
Branch 15807: 1
Branch 15808: 1
Branch 15809: 1
Branch 15810: 1
Branch 15811: 1
Branch 15812: 1
Branch 15813: 1
Branch 15814: 1
Branch 15815: 1
Branch 15816: 1
Branch 15817: 1
Branch 15818: 1
Branch 15819: 1
Branch 15820: 1
Branch 15821: 1
Branch 15822: 1
Branch 15823: 1
Branch 15824: 1
Branch 15825: 1
Branch 15826: 1
Branch 15827: 1
Branch 15828: 1
Branch 15829: 1
Branch 15830: 1
Branch 15831: 1
Branch 15832: 1
Branch 15833: 1
Branch 15834: 1
Branch 15835: 1
Branch 15836: 1
Branch 15837: 1
Branch 15838: 1
Branch 15839: 1
Branch 15840: 1
Branch 15841: 1
Branch 15842: 1
Branch 15843: 1
Branch 15844: 1
Branch 15845: 1
Branch 15846: 1
Branch 15847: 1
Branch 15848: 1
Branch 15849: 1
Branch 15850: 1
Branch 15851: 1
Branch 15852: 1
Branch 15853: 1
Branch 15854: 1
Branch 15855: 1
Branch 15856: 1
Branch 15857: 1
Branch 15858: 1
Branch 15859: 1
Branch 15860: 1
Branch 15861: 1
Branch 15862: 1
Branch 15863: 1
Branch 15864: 1
Branch 15865: 1
Branch 15866: 1
Branch 15867: 1
Branch 15868: 1
Branch 15869: 1
Branch 15870: 1
Branch 15871: 1
Branch 15872: 1
Branch 15873: 1
Branch 15874: 1
Branch 15875: 1
Branch 15876: 1
Branch 15877: 1
Branch 15878: 1
Branch 15879: 1
Branch 15880: 1
Branch 15881: 1
Branch 15882: 1
Branch 15883: 1
Branch 15884: 1
Branch 15885: 1
Branch 15886: 1
Branch 15887: 1
Branch 15888: 1
Branch 15889: 1
Branch 15890: 1
Branch 15891: 1
Branch 15892: 1
Branch 15893: 1
Branch 15894: 1
Branch 15895: 1
Branch 15896: 1
Branch 15897: 1
Branch 15898: 1
Branch 15899: 1
Branch 15900: 1
Branch 15901: 1
Branch 15902: 1
Branch 15903: 1
Branch 15904: 1
Branch 15905: 1
Branch 15906: 1
Branch 15907: 1
Branch 15908: 1
Branch 15909: 1
Branch 15910: 1
Branch 15911: 1
Branch 15912: 1
Branch 15913: 1
Branch 15914: 1
Branch 15915: 1
Branch 15916: 1
Branch 15917: 1
Branch 15918: 1
Branch 15919: 1
Branch 15920: 1
Branch 15921: 1
Branch 15922: 1
Branch 15923: 1
Branch 15924: 1
Branch 15925: 1
Branch 15926: 1
Branch 15927: 1
Branch 15928: 1
Branch 15929: 1
Branch 15930: 1
Branch 15931: 1
Branch 15932: 1
Branch 15933: 1
Branch 15934: 1
Branch 15935: 1
Branch 15936: 1
Branch 15937: 1
Branch 15938: 1
Branch 15939: 1
Branch 15940: 1
Branch 15941: 1
Branch 15942: 1
Branch 15943: 1
Branch 15944: 1
Branch 15945: 1
Branch 15946: 1
Branch 15947: 1
Branch 15948: 1
Branch 15949: 1
Branch 15950: 1
Branch 15951: 1
Branch 15952: 1
Branch 15953: 1
Branch 15954: 1
Branch 15955: 1
Branch 15956: 1
Branch 15957: 1
Branch 15958: 1
Branch 15959: 1
Branch 15960: 1
Branch 15961: 1
Branch 15962: 1
Branch 15963: 1
Branch 15964: 1
Branch 15965: 1
Branch 15966: 1
Branch 15967: 1
Branch 15968: 1
Branch 15969: 1
Branch 15970: 1
Branch 15971: 1
Branch 15972: 1
Branch 15973: 1
Branch 15974: 1
Branch 15975: 1
Branch 15976: 1
Branch 15977: 1
Branch 15978: 1
Branch 15979: 1
Branch 15980: 1
Branch 15981: 1
Branch 15982: 1
Branch 15983: 1
Branch 15984: 1
Branch 15985: 1
Branch 15986: 1
Branch 15987: 1
Branch 15988: 1
Branch 15989: 1
Branch 15990: 1
Branch 15991: 1
Branch 15992: 1
Branch 15993: 1
Branch 15994: 1
Branch 15995: 1
Branch 15996: 1
Branch 15997: 1
Branch 15998: 1
Branch 15999: 1
Branch 16000: 1
Branch 16001: 1
Branch 16002: 1
Branch 16003: 1
Branch 16004: 1
Branch 16005: 1
Branch 16006: 1
Branch 16007: 1
Branch 16008: 1
Branch 16009: 1
Branch 16010: 1
Branch 16011: 1
Branch 16012: 1
Branch 16013: 1
Branch 16014: 1
Branch 16015: 1
Branch 16016: 1
Branch 16017: 1
Branch 16018: 1
Branch 16019: 1
Branch 16020: 1
Branch 16021: 1
Branch 16022: 1
Branch 16023: 1
Branch 16024: 1
Branch 16025: 1
Branch 16026: 1
Branch 16027: 1
Branch 16028: 1
Branch 16029: 1
Branch 16030: 1
Branch 16031: 1
Branch 16032: 1
Branch 16033: 1
Branch 16034: 1
Branch 16035: 1
Branch 16036: 1
Branch 16037: 1
Branch 16038: 1
Branch 16039: 1
Branch 16040: 1
Branch 16041: 1
Branch 16042: 1
Branch 16043: 1
Branch 16044: 1
Branch 16045: 1
Branch 16046: 1
Branch 16047: 1
Branch 16048: 1
Branch 16049: 1
Branch 16050: 1
Branch 16051: 1
Branch 16052: 1
Branch 16053: 1
Branch 16054: 1
Branch 16055: 1
Branch 16056: 1
Branch 16057: 1
Branch 16058: 1
Branch 16059: 1
Branch 16060: 1
Branch 16061: 1
Branch 16062: 1
Branch 16063: 1
Branch 16064: 1
Branch 16065: 1
Branch 16066: 1
Branch 16067: 1
Branch 16068: 1
Branch 16069: 1
Branch 16070: 1
Branch 16071: 1
Branch 16072: 1
Branch 16073: 1
Branch 16074: 1
Branch 16075: 1
Branch 16076: 1
Branch 16077: 1
Branch 16078: 1
Branch 16079: 1
Branch 16080: 1
Branch 16081: 1
Branch 16082: 1
Branch 16083: 1
Branch 16084: 1
Branch 16085: 1
Branch 16086: 1
Branch 16087: 1
Branch 16088: 1
Branch 16089: 1
Branch 16090: 1
Branch 16091: 1
Branch 16092: 1
Branch 16093: 1
Branch 16094: 1
Branch 16095: 1
Branch 16096: 1
Branch 16097: 1
Branch 16098: 1
Branch 16099: 1
Branch 16100: 1
Branch 16101: 1
Branch 16102: 1
Branch 16103: 1
Branch 16104: 1
Branch 16105: 1
Branch 16106: 1
Branch 16107: 1
Branch 16108: 1
Branch 16109: 1
Branch 16110: 1
Branch 16111: 1
Branch 16112: 1
Branch 16113: 1
Branch 16114: 1
Branch 16115: 1
Branch 16116: 1
Branch 16117: 1
Branch 16118: 1
Branch 16119: 1
Branch 16120: 1
Branch 16121: 1
Branch 16122: 1
Branch 16123: 1
Branch 16124: 1
Branch 16125: 1
Branch 16126: 1
Branch 16127: 1
Branch 16128: 1
Branch 16129: 1
Branch 16130: 1
Branch 16131: 1
Branch 16132: 1
Branch 16133: 1
Branch 16134: 1
Branch 16135: 1
Branch 16136: 1
Branch 16137: 1
Branch 16138: 1
Branch 16139: 1
Branch 16140: 1
Branch 16141: 1
Branch 16142: 1
Branch 16143: 1
Branch 16144: 1
Branch 16145: 1
Branch 16146: 1
Branch 16147: 1
Branch 16148: 1
Branch 16149: 1
Branch 16150: 1
Branch 16151: 1
Branch 16152: 1
Branch 16153: 1
Branch 16154: 1
Branch 16155: 1
Branch 16156: 1
Branch 16157: 1
Branch 16158: 1
Branch 16159: 1
Branch 16160: 1
Branch 16161: 1
Branch 16162: 1
Branch 16163: 1
Branch 16164: 1
Branch 16165: 1
Branch 16166: 1
Branch 16167: 1
Branch 16168: 1
Branch 16169: 1
Branch 16170: 1
Branch 16171: 1
Branch 16172: 1
Branch 16173: 1
Branch 16174: 1
Branch 16175: 1
Branch 16176: 1
Branch 16177: 1
Branch 16178: 1
Branch 16179: 1
Branch 16180: 1
Branch 16181: 1
Branch 16182: 1
Branch 16183: 1
Branch 16184: 1
Branch 16185: 1
Branch 16186: 1
Branch 16187: 1
Branch 16188: 1
Branch 16189: 1
Branch 16190: 1
Branch 16191: 1
Branch 16192: 1
Branch 16193: 1
Branch 16194: 1
Branch 16195: 1
Branch 16196: 1
Branch 16197: 1
Branch 16198: 1
Branch 16199: 1
Branch 16200: 1
Branch 16201: 1
Branch 16202: 1
Branch 16203: 1
Branch 16204: 1
Branch 16205: 1
Branch 16206: 1
Branch 16207: 1
Branch 16208: 1
Branch 16209: 1
Branch 16210: 1
Branch 16211: 1
Branch 16212: 1
Branch 16213: 1
Branch 16214: 1
Branch 16215: 1
Branch 16216: 1
Branch 16217: 1
Branch 16218: 1
Branch 16219: 1
Branch 16220: 1
Branch 16221: 1
Branch 16222: 1
Branch 16223: 1
Branch 16224: 1
Branch 16225: 1
Branch 16226: 1
Branch 16227: 1
Branch 16228: 1
Branch 16229: 1
Branch 16230: 1
Branch 16231: 1
Branch 16232: 1
Branch 16233: 1
Branch 16234: 1
Branch 16235: 1
Branch 16236: 1
Branch 16237: 1
Branch 16238: 1
Branch 16239: 1
Branch 16240: 1
Branch 16241: 1
Branch 16242: 1
Branch 16243: 1
Branch 16244: 1
Branch 16245: 1
Branch 16246: 1
Branch 16247: 1
Branch 16248: 1
Branch 16249: 1
Branch 16250: 1
Branch 16251: 1
Branch 16252: 1
Branch 16253: 1
Branch 16254: 1
Branch 16255: 1
Branch 16256: 1
Branch 16257: 1
Branch 16258: 1
Branch 16259: 1
Branch 16260: 1
Branch 16261: 1
Branch 16262: 1
Branch 16263: 1
Branch 16264: 1
Branch 16265: 1
Branch 16266: 1
Branch 16267: 1
Branch 16268: 1
Branch 16269: 1
Branch 16270: 1
Branch 16271: 1
Branch 16272: 1
Branch 16273: 1
Branch 16274: 1
Branch 16275: 1
Branch 16276: 1
Branch 16277: 1
Branch 16278: 1
Branch 16279: 1
Branch 16280: 1
Branch 16281: 1
Branch 16282: 1
Branch 16283: 1
Branch 16284: 1
Branch 16285: 1
Branch 16286: 1
Branch 16287: 1
Branch 16288: 1
Branch 16289: 1
Branch 16290: 1
Branch 16291: 1
Branch 16292: 1
Branch 16293: 1
Branch 16294: 1
Branch 16295: 1
Branch 16296: 1
Branch 16297: 1
Branch 16298: 1
Branch 16299: 1
Branch 16300: 1
Branch 16301: 1
Branch 16302: 1
Branch 16303: 1
Branch 16304: 1
Branch 16305: 1
Branch 16306: 1
Branch 16307: 1
Branch 16308: 1
Branch 16309: 1
Branch 16310: 1
Branch 16311: 1
Branch 16312: 1
Branch 16313: 1
Branch 16314: 1
Branch 16315: 1
Branch 16316: 1
Branch 16317: 1
Branch 16318: 1
Branch 16319: 1
Branch 16320: 1
Branch 16321: 1
Branch 16322: 1
Branch 16323: 1
Branch 16324: 1
Branch 16325: 1
Branch 16326: 1
Branch 16327: 1
Branch 16328: 1
Branch 16329: 1
Branch 16330: 1
Branch 16331: 1
Branch 16332: 1
Branch 16333: 1
Branch 16334: 1
Branch 16335: 1
Branch 16336: 1
Branch 16337: 1
Branch 16338: 1
Branch 16339: 1
Branch 16340: 1
Branch 16341: 1
Branch 16342: 1
Branch 16343: 1
Branch 16344: 1
Branch 16345: 1
Branch 16346: 1
Branch 16347: 1
Branch 16348: 1
Branch 16349: 1
Branch 16350: 1
Branch 16351: 1
Branch 16352: 1
Branch 16353: 1
Branch 16354: 1
Branch 16355: 1
Branch 16356: 1
Branch 16357: 1
Branch 16358: 1
Branch 16359: 1
Branch 16360: 1
Branch 16361: 1
Branch 16362: 1
Branch 16363: 1
Branch 16364: 1
Branch 16365: 1
Branch 16366: 1
Branch 16367: 1
Branch 16368: 1
Branch 16369: 1
Branch 16370: 1
Branch 16371: 1
Branch 16372: 1
Branch 16373: 1
Branch 16374: 1
Branch 16375: 1
Branch 16376: 1
Branch 16377: 1
Branch 16378: 1
Branch 16379: 1
Branch 16380: 1
Branch 16381: 1
Branch 16382: 1
Branch 16383: 1
Branch 16384: 1
Branch 16385: 1
Branch 16386: 1
Branch 16387: 1
Branch 16388: 1
Branch 16389: 1
Branch 16390: 1
Branch 16391: 1
Branch 16392: 1
Branch 16393: 1
Branch 16394: 1
Branch 16395: 1
Branch 16396: 1
Branch 16397: 1
Branch 16398: 1
Branch 16399: 1
Branch 16400: 1
Branch 16401: 1
Branch 16402: 1
Branch 16403: 1
Branch 16404: 1
Branch 16405: 1
Branch 16406: 1
Branch 16407: 1
Branch 16408: 1
Branch 16409: 1
Branch 16410: 1
Branch 16411: 1
Branch 16412: 1
Branch 16413: 1
Branch 16414: 1
Branch 16415: 1
Branch 16416: 1
Branch 16417: 1
Branch 16418: 1
Branch 16419: 1
Branch 16420: 1
Branch 16421: 1
Branch 16422: 1
Branch 16423: 1
Branch 16424: 1
Branch 16425: 1
Branch 16426: 1
Branch 16427: 1
Branch 16428: 1
Branch 16429: 1
Branch 16430: 1
Branch 16431: 1
Branch 16432: 1
Branch 16433: 1
Branch 16434: 1
Branch 16435: 1
Branch 16436: 1
Branch 16437: 1
Branch 16438: 1
Branch 16439: 1
Branch 16440: 1
Branch 16441: 1
Branch 16442: 1
Branch 16443: 1
Branch 16444: 1
Branch 16445: 1
Branch 16446: 1
Branch 16447: 1
Branch 16448: 1
Branch 16449: 1
Branch 16450: 1
Branch 16451: 1
Branch 16452: 1
Branch 16453: 1
Branch 16454: 1
Branch 16455: 1
Branch 16456: 1
Branch 16457: 1
Branch 16458: 1
Branch 16459: 1
Branch 16460: 1
Branch 16461: 1
Branch 16462: 1
Branch 16463: 1
Branch 16464: 1
Branch 16465: 1
Branch 16466: 1
Branch 16467: 1
Branch 16468: 1
Branch 16469: 1
Branch 16470: 1
Branch 16471: 1
Branch 16472: 1
Branch 16473: 1
Branch 16474: 1
Branch 16475: 1
Branch 16476: 1
Branch 16477: 1
Branch 16478: 1
Branch 16479: 1
Branch 16480: 1
Branch 16481: 1
Branch 16482: 1
Branch 16483: 1
Branch 16484: 1
Branch 16485: 1
Branch 16486: 1
Branch 16487: 1
Branch 16488: 1
Branch 16489: 1
Branch 16490: 1
Branch 16491: 1
Branch 16492: 1
Branch 16493: 1
Branch 16494: 1
Branch 16495: 1
Branch 16496: 1
Branch 16497: 1
Branch 16498: 1
Branch 16499: 1
Branch 16500: 1
Branch 16501: 1
Branch 16502: 1
Branch 16503: 1
Branch 16504: 1
Branch 16505: 1
Branch 16506: 1
Branch 16507: 1
Branch 16508: 1
Branch 16509: 1
Branch 16510: 1
Branch 16511: 1
Branch 16512: 1
Branch 16513: 1
Branch 16514: 1
Branch 16515: 1
Branch 16516: 1
Branch 16517: 1
Branch 16518: 1
Branch 16519: 1
Branch 16520: 1
Branch 16521: 1
Branch 16522: 1
Branch 16523: 1
Branch 16524: 1
Branch 16525: 1
Branch 16526: 1
Branch 16527: 1
Branch 16528: 1
Branch 16529: 1
Branch 16530: 1
Branch 16531: 1
Branch 16532: 1
Branch 16533: 1
Branch 16534: 1
Branch 16535: 1
Branch 16536: 1
Branch 16537: 1
Branch 16538: 1
Branch 16539: 1
Branch 16540: 1
Branch 16541: 1
Branch 16542: 1
Branch 16543: 1
Branch 16544: 1
Branch 16545: 1
Branch 16546: 1
Branch 16547: 1
Branch 16548: 1
Branch 16549: 1
Branch 16550: 1
Branch 16551: 1
Branch 16552: 1
Branch 16553: 1
Branch 16554: 1
Branch 16555: 1
Branch 16556: 1
Branch 16557: 1
Branch 16558: 1
Branch 16559: 1
Branch 16560: 1
Branch 16561: 1
Branch 16562: 1
Branch 16563: 1
Branch 16564: 1
Branch 16565: 1
Branch 16566: 1
Branch 16567: 1
Branch 16568: 1
Branch 16569: 1
Branch 16570: 1
Branch 16571: 1
Branch 16572: 1
Branch 16573: 1
Branch 16574: 1
Branch 16575: 1
Branch 16576: 1
Branch 16577: 1
Branch 16578: 1
Branch 16579: 1
Branch 16580: 1
Branch 16581: 1
Branch 16582: 1
Branch 16583: 1
Branch 16584: 1
Branch 16585: 1
Branch 16586: 1
Branch 16587: 1
Branch 16588: 1
Branch 16589: 1
Branch 16590: 1
Branch 16591: 1
Branch 16592: 1
Branch 16593: 1
Branch 16594: 1
Branch 16595: 1
Branch 16596: 1
Branch 16597: 1
Branch 16598: 1
Branch 16599: 1
Branch 16600: 1
Branch 16601: 1
Branch 16602: 1
Branch 16603: 1
Branch 16604: 1
Branch 16605: 1
Branch 16606: 1
Branch 16607: 1
Branch 16608: 1
Branch 16609: 1
Branch 16610: 1
Branch 16611: 1
Branch 16612: 1
Branch 16613: 1
Branch 16614: 1
Branch 16615: 1
Branch 16616: 1
Branch 16617: 1
Branch 16618: 1
Branch 16619: 1
Branch 16620: 1
Branch 16621: 1
Branch 16622: 1
Branch 16623: 1
Branch 16624: 1
Branch 16625: 1
Branch 16626: 1
Branch 16627: 1
Branch 16628: 1
Branch 16629: 1
Branch 16630: 1
Branch 16631: 1
Branch 16632: 1
Branch 16633: 1
Branch 16634: 1
Branch 16635: 1
Branch 16636: 1
Branch 16637: 1
Branch 16638: 1
Branch 16639: 1
Branch 16640: 1
Branch 16641: 1
Branch 16642: 1
Branch 16643: 1
Branch 16644: 1
Branch 16645: 1
Branch 16646: 1
Branch 16647: 1
Branch 16648: 1
Branch 16649: 1
Branch 16650: 1
Branch 16651: 1
Branch 16652: 1
Branch 16653: 1
Branch 16654: 1
Branch 16655: 1
Branch 16656: 1
Branch 16657: 1
Branch 16658: 1
Branch 16659: 1
Branch 16660: 1
Branch 16661: 1
Branch 16662: 1
Branch 16663: 1
Branch 16664: 1
Branch 16665: 1
Branch 16666: 1
Branch 16667: 1
Branch 16668: 1
Branch 16669: 1
Branch 16670: 1
Branch 16671: 1
Branch 16672: 1
Branch 16673: 1
Branch 16674: 1
Branch 16675: 1
Branch 16676: 1
Branch 16677: 1
Branch 16678: 1
Branch 16679: 1
Branch 16680: 1
Branch 16681: 1
Branch 16682: 1
Branch 16683: 1
Branch 16684: 1
Branch 16685: 1
Branch 16686: 1
Branch 16687: 1
Branch 16688: 1
Branch 16689: 1
Branch 16690: 1
Branch 16691: 1
Branch 16692: 1
Branch 16693: 1
Branch 16694: 1
Branch 16695: 1
Branch 16696: 1
Branch 16697: 1
Branch 16698: 1
Branch 16699: 1
Branch 16700: 1
Branch 16701: 1
Branch 16702: 1
Branch 16703: 1
Branch 16704: 1
Branch 16705: 1
Branch 16706: 1
Branch 16707: 1
Branch 16708: 1
Branch 16709: 1
Branch 16710: 1
Branch 16711: 1
Branch 16712: 1
Branch 16713: 1
Branch 16714: 1
Branch 16715: 1
Branch 16716: 1
Branch 16717: 1
Branch 16718: 1
Branch 16719: 1
Branch 16720: 1
Branch 16721: 1
Branch 16722: 1
Branch 16723: 1
Branch 16724: 1
Branch 16725: 1
Branch 16726: 1
Branch 16727: 1
Branch 16728: 1
Branch 16729: 1
Branch 16730: 1
Branch 16731: 1
Branch 16732: 1
Branch 16733: 1
Branch 16734: 1
Branch 16735: 1
Branch 16736: 1
Branch 16737: 1
Branch 16738: 1
Branch 16739: 1
Branch 16740: 1
Branch 16741: 1
Branch 16742: 1
Branch 16743: 1
Branch 16744: 1
Branch 16745: 1
Branch 16746: 1
Branch 16747: 1
Branch 16748: 1
Branch 16749: 1
Branch 16750: 1
Branch 16751: 1
Branch 16752: 1
Branch 16753: 1
Branch 16754: 1
Branch 16755: 1
Branch 16756: 1
Branch 16757: 1
Branch 16758: 1
Branch 16759: 1
Branch 16760: 1
Branch 16761: 1
Branch 16762: 1
Branch 16763: 1
Branch 16764: 1
Branch 16765: 1
Branch 16766: 1
Branch 16767: 1
Branch 16768: 1
Branch 16769: 1
Branch 16770: 1
Branch 16771: 1
Branch 16772: 1
Branch 16773: 1
Branch 16774: 1
Branch 16775: 1
Branch 16776: 1
Branch 16777: 1
Branch 16778: 1
Branch 16779: 1
Branch 16780: 1
Branch 16781: 1
Branch 16782: 1
Branch 16783: 1
Branch 16784: 1
Branch 16785: 1
Branch 16786: 1
Branch 16787: 1
Branch 16788: 1
Branch 16789: 1
Branch 16790: 1
Branch 16791: 1
Branch 16792: 1
Branch 16793: 1
Branch 16794: 1
Branch 16795: 1
Branch 16796: 1
Branch 16797: 1
Branch 16798: 1
Branch 16799: 1
Branch 16800: 1
Branch 16801: 1
Branch 16802: 1
Branch 16803: 1
Branch 16804: 1
Branch 16805: 1
Branch 16806: 1
Branch 16807: 1
Branch 16808: 1
Branch 16809: 1
Branch 16810: 1
Branch 16811: 1
Branch 16812: 1
Branch 16813: 1
Branch 16814: 1
Branch 16815: 1
Branch 16816: 1
Branch 16817: 1
Branch 16818: 1
Branch 16819: 1
Branch 16820: 1
Branch 16821: 1
Branch 16822: 1
Branch 16823: 1
Branch 16824: 1
Branch 16825: 1
Branch 16826: 1
Branch 16827: 1
Branch 16828: 1
Branch 16829: 1
Branch 16830: 1
Branch 16831: 1
Branch 16832: 1
Branch 16833: 1
Branch 16834: 1
Branch 16835: 1
Branch 16836: 1
Branch 16837: 1
Branch 16838: 1
Branch 16839: 1
Branch 16840: 1
Branch 16841: 1
Branch 16842: 1
Branch 16843: 1
Branch 16844: 1
Branch 16845: 1
Branch 16846: 1
Branch 16847: 1
Branch 16848: 1
Branch 16849: 1
Branch 16850: 1
Branch 16851: 1
Branch 16852: 1
Branch 16853: 1
Branch 16854: 1
Branch 16855: 1
Branch 16856: 1
Branch 16857: 1
Branch 16858: 1
Branch 16859: 1
Branch 16860: 1
Branch 16861: 1
Branch 16862: 1
Branch 16863: 1
Branch 16864: 1
Branch 16865: 1
Branch 16866: 1
Branch 16867: 1
Branch 16868: 1
Branch 16869: 1
Branch 16870: 1
Branch 16871: 1
Branch 16872: 1
Branch 16873: 1
Branch 16874: 1
Branch 16875: 1
Branch 16876: 1
Branch 16877: 1
Branch 16878: 1
Branch 16879: 1
Branch 16880: 1
Branch 16881: 1
Branch 16882: 1
Branch 16883: 1
Branch 16884: 1
Branch 16885: 1
Branch 16886: 1
Branch 16887: 1
Branch 16888: 1
Branch 16889: 1
Branch 16890: 1
Branch 16891: 1
Branch 16892: 1
Branch 16893: 1
Branch 16894: 1
Branch 16895: 1
Branch 16896: 1
Branch 16897: 1
Branch 16898: 1
Branch 16899: 1
Branch 16900: 1
Branch 16901: 1
Branch 16902: 1
Branch 16903: 1
Branch 16904: 1
Branch 16905: 1
Branch 16906: 1
Branch 16907: 1
Branch 16908: 1
Branch 16909: 1
Branch 16910: 1
Branch 16911: 1
Branch 16912: 1
Branch 16913: 1
Branch 16914: 1
Branch 16915: 1
Branch 16916: 1
Branch 16917: 1
Branch 16918: 1
Branch 16919: 1
Branch 16920: 1
Branch 16921: 1
Branch 16922: 1
Branch 16923: 1
Branch 16924: 1
Branch 16925: 1
Branch 16926: 1
Branch 16927: 1
Branch 16928: 1
Branch 16929: 1
Branch 16930: 1
Branch 16931: 1
Branch 16932: 1
Branch 16933: 1
Branch 16934: 1
Branch 16935: 1
Branch 16936: 1
Branch 16937: 1
Branch 16938: 1
Branch 16939: 1
Branch 16940: 1
Branch 16941: 1
Branch 16942: 1
Branch 16943: 1
Branch 16944: 1
Branch 16945: 1
Branch 16946: 1
Branch 16947: 1
Branch 16948: 1
Branch 16949: 1
Branch 16950: 1
Branch 16951: 1
Branch 16952: 1
Branch 16953: 1
Branch 16954: 1
Branch 16955: 1
Branch 16956: 1
Branch 16957: 1
Branch 16958: 1
Branch 16959: 1
Branch 16960: 1
Branch 16961: 1
Branch 16962: 1
Branch 16963: 1
Branch 16964: 1
Branch 16965: 1
Branch 16966: 1
Branch 16967: 1
Branch 16968: 1
Branch 16969: 1
Branch 16970: 1
Branch 16971: 1
Branch 16972: 1
Branch 16973: 1
Branch 16974: 1
Branch 16975: 1
Branch 16976: 1
Branch 16977: 1
Branch 16978: 1
Branch 16979: 1
Branch 16980: 1
Branch 16981: 1
Branch 16982: 1
Branch 16983: 1
Branch 16984: 1
Branch 16985: 1
Branch 16986: 1
Branch 16987: 1
Branch 16988: 1
Branch 16989: 1
Branch 16990: 1
Branch 16991: 1
Branch 16992: 1
Branch 16993: 1
Branch 16994: 1
Branch 16995: 1
Branch 16996: 1
Branch 16997: 1
Branch 16998: 1
Branch 16999: 1
Branch 17000: 1
Branch 17001: 1
Branch 17002: 1
Branch 17003: 1
Branch 17004: 1
Branch 17005: 1
Branch 17006: 1
Branch 17007: 1
Branch 17008: 1
Branch 17009: 1
Branch 17010: 1
Branch 17011: 1
Branch 17012: 1
Branch 17013: 1
Branch 17014: 1
Branch 17015: 1
Branch 17016: 1
Branch 17017: 1
Branch 17018: 1
Branch 17019: 1
Branch 17020: 1
Branch 17021: 1
Branch 17022: 1
Branch 17023: 1
Branch 17024: 1
Branch 17025: 1
Branch 17026: 1
Branch 17027: 1
Branch 17028: 1
Branch 17029: 1
Branch 17030: 1
Branch 17031: 1
Branch 17032: 1
Branch 17033: 1
Branch 17034: 1
Branch 17035: 1
Branch 17036: 1
Branch 17037: 1
Branch 17038: 1
Branch 17039: 1
Branch 17040: 1
Branch 17041: 1
Branch 17042: 1
Branch 17043: 1
Branch 17044: 1
Branch 17045: 1
Branch 17046: 1
Branch 17047: 1
Branch 17048: 1
Branch 17049: 1
Branch 17050: 1
Branch 17051: 1
Branch 17052: 1
Branch 17053: 1
Branch 17054: 1
Branch 17055: 1
Branch 17056: 1
Branch 17057: 1
Branch 17058: 1
Branch 17059: 1
Branch 17060: 1
Branch 17061: 1
Branch 17062: 1
Branch 17063: 1
Branch 17064: 1
Branch 17065: 1
Branch 17066: 1
Branch 17067: 1
Branch 17068: 1
Branch 17069: 1
Branch 17070: 1
Branch 17071: 1
Branch 17072: 1
Branch 17073: 1
Branch 17074: 1
Branch 17075: 1
Branch 17076: 1
Branch 17077: 1
Branch 17078: 1
Branch 17079: 1
Branch 17080: 1
Branch 17081: 1
Branch 17082: 1
Branch 17083: 1
Branch 17084: 1
Branch 17085: 1
Branch 17086: 1
Branch 17087: 1
Branch 17088: 1
Branch 17089: 1
Branch 17090: 1
Branch 17091: 1
Branch 17092: 1
Branch 17093: 1
Branch 17094: 1
Branch 17095: 1
Branch 17096: 1
Branch 17097: 1
Branch 17098: 1
Branch 17099: 1
Branch 17100: 1
Branch 17101: 1
Branch 17102: 1
Branch 17103: 1
Branch 17104: 1
Branch 17105: 1
Branch 17106: 1
Branch 17107: 1
Branch 17108: 1
Branch 17109: 1
Branch 17110: 1
Branch 17111: 1
Branch 17112: 1
Branch 17113: 1
Branch 17114: 1
Branch 17115: 1
Branch 17116: 1
Branch 17117: 1
Branch 17118: 1
Branch 17119: 1
Branch 17120: 1
Branch 17121: 1
Branch 17122: 1
Branch 17123: 1
Branch 17124: 1
Branch 17125: 1
Branch 17126: 1
Branch 17127: 1
Branch 17128: 1
Branch 17129: 1
Branch 17130: 1
Branch 17131: 1
Branch 17132: 1
Branch 17133: 1
Branch 17134: 1
Branch 17135: 1
Branch 17136: 1
Branch 17137: 1
Branch 17138: 1
Branch 17139: 1
Branch 17140: 1
Branch 17141: 1
Branch 17142: 1
Branch 17143: 1
Branch 17144: 1
Branch 17145: 1
Branch 17146: 1
Branch 17147: 1
Branch 17148: 1
Branch 17149: 1
Branch 17150: 1
Branch 17151: 1
Branch 17152: 1
Branch 17153: 1
Branch 17154: 1
Branch 17155: 1
Branch 17156: 1
Branch 17157: 1
Branch 17158: 1
Branch 17159: 1
Branch 17160: 1
Branch 17161: 1
Branch 17162: 1
Branch 17163: 1
Branch 17164: 1
Branch 17165: 1
Branch 17166: 1
Branch 17167: 1
Branch 17168: 1
Branch 17169: 1
Branch 17170: 1
Branch 17171: 1
Branch 17172: 1
Branch 17173: 1
Branch 17174: 1
Branch 17175: 1
Branch 17176: 1
Branch 17177: 1
Branch 17178: 1
Branch 17179: 1
Branch 17180: 1
Branch 17181: 1
Branch 17182: 1
Branch 17183: 1
Branch 17184: 1
Branch 17185: 1
Branch 17186: 1
Branch 17187: 1
Branch 17188: 1
Branch 17189: 1
Branch 17190: 1
Branch 17191: 1
Branch 17192: 1
Branch 17193: 1
Branch 17194: 1
Branch 17195: 1
Branch 17196: 1
Branch 17197: 1
Branch 17198: 1
Branch 17199: 1
Branch 17200: 1
Branch 17201: 1
Branch 17202: 1
Branch 17203: 1
Branch 17204: 1
Branch 17205: 1
Branch 17206: 1
Branch 17207: 1
Branch 17208: 1
Branch 17209: 1
Branch 17210: 1
Branch 17211: 1
Branch 17212: 1
Branch 17213: 1
Branch 17214: 1
Branch 17215: 1
Branch 17216: 1
Branch 17217: 1
Branch 17218: 1
Branch 17219: 1
Branch 17220: 1
Branch 17221: 1
Branch 17222: 1
Branch 17223: 1
Branch 17224: 1
Branch 17225: 1
Branch 17226: 1
Branch 17227: 1
Branch 17228: 1
Branch 17229: 1
Branch 17230: 1
Branch 17231: 1
Branch 17232: 1
Branch 17233: 1
Branch 17234: 1
Branch 17235: 1
Branch 17236: 1
Branch 17237: 1
Branch 17238: 1
Branch 17239: 1
Branch 17240: 1
Branch 17241: 1
Branch 17242: 1
Branch 17243: 1
Branch 17244: 1
Branch 17245: 1
Branch 17246: 1
Branch 17247: 1
Branch 17248: 1
Branch 17249: 1
Branch 17250: 1
Branch 17251: 1
Branch 17252: 1
Branch 17253: 1
Branch 17254: 1
Branch 17255: 1
Branch 17256: 1
Branch 17257: 1
Branch 17258: 1
Branch 17259: 1
Branch 17260: 1
Branch 17261: 1
Branch 17262: 1
Branch 17263: 1
Branch 17264: 1
Branch 17265: 1
Branch 17266: 1
Branch 17267: 1
Branch 17268: 1
Branch 17269: 1
Branch 17270: 1
Branch 17271: 1
Branch 17272: 1
Branch 17273: 1
Branch 17274: 1
Branch 17275: 1
Branch 17276: 1
Branch 17277: 1
Branch 17278: 1
Branch 17279: 1
Branch 17280: 1
Branch 17281: 1
Branch 17282: 1
Branch 17283: 1
Branch 17284: 1
Branch 17285: 1
Branch 17286: 1
Branch 17287: 1
Branch 17288: 1
Branch 17289: 1
Branch 17290: 1
Branch 17291: 1
Branch 17292: 1
Branch 17293: 1
Branch 17294: 1
Branch 17295: 1
Branch 17296: 1
Branch 17297: 1
Branch 17298: 1
Branch 17299: 1
Branch 17300: 1
Branch 17301: 1
Branch 17302: 1
Branch 17303: 1
Branch 17304: 1
Branch 17305: 1
Branch 17306: 1
Branch 17307: 1
Branch 17308: 1
Branch 17309: 1
Branch 17310: 1
Branch 17311: 1
Branch 17312: 1
Branch 17313: 1
Branch 17314: 1
Branch 17315: 1
Branch 17316: 1
Branch 17317: 1
Branch 17318: 1
Branch 17319: 1
Branch 17320: 1
Branch 17321: 1
Branch 17322: 1
Branch 17323: 1
Branch 17324: 1
Branch 17325: 1
Branch 17326: 1
Branch 17327: 1
Branch 17328: 1
Branch 17329: 1
Branch 17330: 1
Branch 17331: 1
Branch 17332: 1
Branch 17333: 1
Branch 17334: 1
Branch 17335: 1
Branch 17336: 1
Branch 17337: 1
Branch 17338: 1
Branch 17339: 1
Branch 17340: 1
Branch 17341: 1
Branch 17342: 1
Branch 17343: 1
Branch 17344: 1
Branch 17345: 1
Branch 17346: 1
Branch 17347: 1
Branch 17348: 1
Branch 17349: 1
Branch 17350: 1
Branch 17351: 1
Branch 17352: 1
Branch 17353: 1
Branch 17354: 1
Branch 17355: 1
Branch 17356: 1
Branch 17357: 1
Branch 17358: 1
Branch 17359: 1
Branch 17360: 1
Branch 17361: 1
Branch 17362: 1
Branch 17363: 1
Branch 17364: 1
Branch 17365: 1
Branch 17366: 1
Branch 17367: 1
Branch 17368: 1
Branch 17369: 1
Branch 17370: 1
Branch 17371: 1
Branch 17372: 1
Branch 17373: 1
Branch 17374: 1
Branch 17375: 1
Branch 17376: 1
Branch 17377: 1
Branch 17378: 1
Branch 17379: 1
Branch 17380: 1
Branch 17381: 1
Branch 17382: 1
Branch 17383: 1
Branch 17384: 1
Branch 17385: 1
Branch 17386: 1
Branch 17387: 1
Branch 17388: 1
Branch 17389: 1
Branch 17390: 1
Branch 17391: 1
Branch 17392: 1
Branch 17393: 1
Branch 17394: 1
Branch 17395: 1
Branch 17396: 1
Branch 17397: 1
Branch 17398: 1
Branch 17399: 1
Branch 17400: 1
Branch 17401: 1
Branch 17402: 1
Branch 17403: 1
Branch 17404: 1
Branch 17405: 1
Branch 17406: 1
Branch 17407: 1
Branch 17408: 1
Branch 17409: 1
Branch 17410: 1
Branch 17411: 1
Branch 17412: 1
Branch 17413: 1
Branch 17414: 1
Branch 17415: 1
Branch 17416: 1
Branch 17417: 1
Branch 17418: 1
Branch 17419: 1
Branch 17420: 1
Branch 17421: 1
Branch 17422: 1
Branch 17423: 1
Branch 17424: 1
Branch 17425: 1
Branch 17426: 1
Branch 17427: 1
Branch 17428: 1
Branch 17429: 1
Branch 17430: 1
Branch 17431: 1
Branch 17432: 1
Branch 17433: 1
Branch 17434: 1
Branch 17435: 1
Branch 17436: 1
Branch 17437: 1
Branch 17438: 1
Branch 17439: 1
Branch 17440: 1
Branch 17441: 1
Branch 17442: 1
Branch 17443: 1
Branch 17444: 1
Branch 17445: 1
Branch 17446: 1
Branch 17447: 1
Branch 17448: 1
Branch 17449: 1
Branch 17450: 1
Branch 17451: 1
Branch 17452: 1
Branch 17453: 1
Branch 17454: 1
Branch 17455: 1
Branch 17456: 1
Branch 17457: 1
Branch 17458: 1
Branch 17459: 1
Branch 17460: 1
Branch 17461: 1
Branch 17462: 1
Branch 17463: 1
Branch 17464: 1
Branch 17465: 1
Branch 17466: 1
Branch 17467: 1
Branch 17468: 1
Branch 17469: 1
Branch 17470: 1
Branch 17471: 1
Branch 17472: 1
Branch 17473: 1
Branch 17474: 1
Branch 17475: 1
Branch 17476: 1
Branch 17477: 1
Branch 17478: 1
Branch 17479: 1
Branch 17480: 1
Branch 17481: 1
Branch 17482: 1
Branch 17483: 1
Branch 17484: 1
Branch 17485: 1
Branch 17486: 1
Branch 17487: 1
Branch 17488: 1
Branch 17489: 1
Branch 17490: 1
Branch 17491: 1
Branch 17492: 1
Branch 17493: 1
Branch 17494: 1
Branch 17495: 1
Branch 17496: 1
Branch 17497: 1
Branch 17498: 1
Branch 17499: 1
Branch 17500: 1
Branch 17501: 1
Branch 17502: 1
Branch 17503: 1
Branch 17504: 1
Branch 17505: 1
Branch 17506: 1
Branch 17507: 1
Branch 17508: 1
Branch 17509: 1
Branch 17510: 1
Branch 17511: 1
Branch 17512: 1
Branch 17513: 1
Branch 17514: 1
Branch 17515: 1
Branch 17516: 1
Branch 17517: 1
Branch 17518: 1
Branch 17519: 1
Branch 17520: 1
Branch 17521: 1
Branch 17522: 1
Branch 17523: 1
Branch 17524: 1
Branch 17525: 1
Branch 17526: 1
Branch 17527: 1
Branch 17528: 1
Branch 17529: 1
Branch 17530: 1
Branch 17531: 1
Branch 17532: 1
Branch 17533: 1
Branch 17534: 1
Branch 17535: 1
Branch 17536: 1
Branch 17537: 1
Branch 17538: 1
Branch 17539: 1
Branch 17540: 1
Branch 17541: 1
Branch 17542: 1
Branch 17543: 1
Branch 17544: 1
Branch 17545: 1
Branch 17546: 1
Branch 17547: 1
Branch 17548: 1
Branch 17549: 1
Branch 17550: 1
Branch 17551: 1
Branch 17552: 1
Branch 17553: 1
Branch 17554: 1
Branch 17555: 1
Branch 17556: 1
Branch 17557: 1
Branch 17558: 1
Branch 17559: 1
Branch 17560: 1
Branch 17561: 1
Branch 17562: 1
Branch 17563: 1
Branch 17564: 1
Branch 17565: 1
Branch 17566: 1
Branch 17567: 1
Branch 17568: 1
Branch 17569: 1
Branch 17570: 1
Branch 17571: 1
Branch 17572: 1
Branch 17573: 1
Branch 17574: 1
Branch 17575: 1
Branch 17576: 1
Branch 17577: 1
Branch 17578: 1
Branch 17579: 1
Branch 17580: 1
Branch 17581: 1
Branch 17582: 1
Branch 17583: 1
Branch 17584: 1
Branch 17585: 1
Branch 17586: 1
Branch 17587: 1
Branch 17588: 1
Branch 17589: 1
Branch 17590: 1
Branch 17591: 1
Branch 17592: 1
Branch 17593: 1
Branch 17594: 1
Branch 17595: 1
Branch 17596: 1
Branch 17597: 1
Branch 17598: 1
Branch 17599: 1
Branch 17600: 1
Branch 17601: 1
Branch 17602: 1
Branch 17603: 1
Branch 17604: 1
Branch 17605: 1
Branch 17606: 1
Branch 17607: 1
Branch 17608: 1
Branch 17609: 1
Branch 17610: 1
Branch 17611: 1
Branch 17612: 1
Branch 17613: 1
Branch 17614: 1
Branch 17615: 1
Branch 17616: 1
Branch 17617: 1
Branch 17618: 1
Branch 17619: 1
Branch 17620: 1
Branch 17621: 1
Branch 17622: 1
Branch 17623: 1
Branch 17624: 1
Branch 17625: 1
Branch 17626: 1
Branch 17627: 1
Branch 17628: 1
Branch 17629: 1
Branch 17630: 1
Branch 17631: 1
Branch 17632: 1
Branch 17633: 1
Branch 17634: 1
Branch 17635: 1
Branch 17636: 1
Branch 17637: 1
Branch 17638: 1
Branch 17639: 1
Branch 17640: 1
Branch 17641: 1
Branch 17642: 1
Branch 17643: 1
Branch 17644: 1
Branch 17645: 1
Branch 17646: 1
Branch 17647: 1
Branch 17648: 1
Branch 17649: 1
Branch 17650: 1
Branch 17651: 1
Branch 17652: 1
Branch 17653: 1
Branch 17654: 1
Branch 17655: 1
Branch 17656: 1
Branch 17657: 1
Branch 17658: 1
Branch 17659: 1
Branch 17660: 1
Branch 17661: 1
Branch 17662: 1
Branch 17663: 1
Branch 17664: 1
Branch 17665: 1
Branch 17666: 1
Branch 17667: 1
Branch 17668: 1
Branch 17669: 1
Branch 17670: 1
Branch 17671: 1
Branch 17672: 1
Branch 17673: 1
Branch 17674: 1
Branch 17675: 1
Branch 17676: 1
Branch 17677: 1
Branch 17678: 1
Branch 17679: 1
Branch 17680: 1
Branch 17681: 1
Branch 17682: 1
Branch 17683: 1
Branch 17684: 1
Branch 17685: 1
Branch 17686: 1
Branch 17687: 1
Branch 17688: 1
Branch 17689: 1
Branch 17690: 1
Branch 17691: 1
Branch 17692: 1
Branch 17693: 1
Branch 17694: 1
Branch 17695: 1
Branch 17696: 1
Branch 17697: 1
Branch 17698: 1
Branch 17699: 1
Branch 17700: 1
Branch 17701: 1
Branch 17702: 1
Branch 17703: 1
Branch 17704: 1
Branch 17705: 1
Branch 17706: 1
Branch 17707: 1
Branch 17708: 1
Branch 17709: 1
Branch 17710: 1
Branch 17711: 1
Branch 17712: 1
Branch 17713: 1
Branch 17714: 1
Branch 17715: 1
Branch 17716: 1
Branch 17717: 1
Branch 17718: 1
Branch 17719: 1
Branch 17720: 1
Branch 17721: 1
Branch 17722: 1
Branch 17723: 1
Branch 17724: 1
Branch 17725: 1
Branch 17726: 1
Branch 17727: 1
Branch 17728: 1
Branch 17729: 1
Branch 17730: 1
Branch 17731: 1
Branch 17732: 1
Branch 17733: 1
Branch 17734: 1
Branch 17735: 1
Branch 17736: 1
Branch 17737: 1
Branch 17738: 1
Branch 17739: 1
Branch 17740: 1
Branch 17741: 1
Branch 17742: 1
Branch 17743: 1
Branch 17744: 1
Branch 17745: 1
Branch 17746: 1
Branch 17747: 1
Branch 17748: 1
Branch 17749: 1
Branch 17750: 1
Branch 17751: 1
Branch 17752: 1
Branch 17753: 1
Branch 17754: 1
Branch 17755: 1
Branch 17756: 1
Branch 17757: 1
Branch 17758: 1
Branch 17759: 1
Branch 17760: 1
Branch 17761: 1
Branch 17762: 1
Branch 17763: 1
Branch 17764: 1
Branch 17765: 1
Branch 17766: 1
Branch 17767: 1
Branch 17768: 1
Branch 17769: 1
Branch 17770: 1
Branch 17771: 1
Branch 17772: 1
Branch 17773: 1
Branch 17774: 1
Branch 17775: 1
Branch 17776: 1
Branch 17777: 1
Branch 17778: 1
Branch 17779: 1
Branch 17780: 1
Branch 17781: 1
Branch 17782: 1
Branch 17783: 1
Branch 17784: 1
Branch 17785: 1
Branch 17786: 1
Branch 17787: 1
Branch 17788: 1
Branch 17789: 1
Branch 17790: 1
Branch 17791: 1
Branch 17792: 1
Branch 17793: 1
Branch 17794: 1
Branch 17795: 1
Branch 17796: 1
Branch 17797: 1
Branch 17798: 1
Branch 17799: 1
Branch 17800: 1
Branch 17801: 1
Branch 17802: 1
Branch 17803: 1
Branch 17804: 1
Branch 17805: 1
Branch 17806: 1
Branch 17807: 1
Branch 17808: 1
Branch 17809: 1
Branch 17810: 1
Branch 17811: 1
Branch 17812: 1
Branch 17813: 1
Branch 17814: 1
Branch 17815: 1
Branch 17816: 1
Branch 17817: 1
Branch 17818: 1
Branch 17819: 1
Branch 17820: 1
Branch 17821: 1
Branch 17822: 1
Branch 17823: 1
Branch 17824: 1
Branch 17825: 1
Branch 17826: 1
Branch 17827: 1
Branch 17828: 1
Branch 17829: 1
Branch 17830: 1
Branch 17831: 1
Branch 17832: 1
Branch 17833: 1
Branch 17834: 1
Branch 17835: 1
Branch 17836: 1
Branch 17837: 1
Branch 17838: 1
Branch 17839: 1
Branch 17840: 1
Branch 17841: 1
Branch 17842: 1
Branch 17843: 1
Branch 17844: 1
Branch 17845: 1
Branch 17846: 1
Branch 17847: 1
Branch 17848: 1
Branch 17849: 1
Branch 17850: 1
Branch 17851: 1
Branch 17852: 1
Branch 17853: 1
Branch 17854: 1
Branch 17855: 1
Branch 17856: 1
Branch 17857: 1
Branch 17858: 1
Branch 17859: 1
Branch 17860: 1
Branch 17861: 1
Branch 17862: 1
Branch 17863: 1
Branch 17864: 1
Branch 17865: 1
Branch 17866: 1
Branch 17867: 1
Branch 17868: 1
Branch 17869: 1
Branch 17870: 1
Branch 17871: 1
Branch 17872: 1
Branch 17873: 1
Branch 17874: 1
Branch 17875: 1
Branch 17876: 1
Branch 17877: 1
Branch 17878: 1
Branch 17879: 1
Branch 17880: 1
Branch 17881: 1
Branch 17882: 1
Branch 17883: 1
Branch 17884: 1
Branch 17885: 1
Branch 17886: 1
Branch 17887: 1
Branch 17888: 1
Branch 17889: 1
Branch 17890: 1
Branch 17891: 1
Branch 17892: 1
Branch 17893: 1
Branch 17894: 1
Branch 17895: 1
Branch 17896: 1
Branch 17897: 1
Branch 17898: 1
Branch 17899: 1
Branch 17900: 1
Branch 17901: 1
Branch 17902: 1
Branch 17903: 1
Branch 17904: 1
Branch 17905: 1
Branch 17906: 1
Branch 17907: 1
Branch 17908: 1
Branch 17909: 1
Branch 17910: 1
Branch 17911: 1
Branch 17912: 1
Branch 17913: 1
Branch 17914: 1
Branch 17915: 1
Branch 17916: 1
Branch 17917: 1
Branch 17918: 1
Branch 17919: 1
Branch 17920: 1
Branch 17921: 1
Branch 17922: 1
Branch 17923: 1
Branch 17924: 1
Branch 17925: 1
Branch 17926: 1
Branch 17927: 1
Branch 17928: 1
Branch 17929: 1
Branch 17930: 1
Branch 17931: 1
Branch 17932: 1
Branch 17933: 1
Branch 17934: 1
Branch 17935: 1
Branch 17936: 1
Branch 17937: 1
Branch 17938: 1
Branch 17939: 1
Branch 17940: 1
Branch 17941: 1
Branch 17942: 1
Branch 17943: 1
Branch 17944: 1
Branch 17945: 1
Branch 17946: 1
Branch 17947: 1
Branch 17948: 1
Branch 17949: 1
Branch 17950: 1
Branch 17951: 1
Branch 17952: 1
Branch 17953: 1
Branch 17954: 1
Branch 17955: 1
Branch 17956: 1
Branch 17957: 1
Branch 17958: 1
Branch 17959: 1
Branch 17960: 1
Branch 17961: 1
Branch 17962: 1
Branch 17963: 1
Branch 17964: 1
Branch 17965: 1
Branch 17966: 1
Branch 17967: 1
Branch 17968: 1
Branch 17969: 1
Branch 17970: 1
Branch 17971: 1
Branch 17972: 1
Branch 17973: 1
Branch 17974: 1
Branch 17975: 1
Branch 17976: 1
Branch 17977: 1
Branch 17978: 1
Branch 17979: 1
Branch 17980: 1
Branch 17981: 1
Branch 17982: 1
Branch 17983: 1
Branch 17984: 1
Branch 17985: 1
Branch 17986: 1
Branch 17987: 1
Branch 17988: 1
Branch 17989: 1
Branch 17990: 1
Branch 17991: 1
Branch 17992: 1
Branch 17993: 1
Branch 17994: 1
Branch 17995: 1
Branch 17996: 1
Branch 17997: 1
Branch 17998: 1
Branch 17999: 1
Branch 18000: 1
Branch 18001: 1
Branch 18002: 1
Branch 18003: 1
Branch 18004: 1
Branch 18005: 1
Branch 18006: 1
Branch 18007: 1
Branch 18008: 1
Branch 18009: 1
Branch 18010: 1
Branch 18011: 1
Branch 18012: 1
Branch 18013: 1
Branch 18014: 1
Branch 18015: 1
Branch 18016: 1
Branch 18017: 1
Branch 18018: 1
Branch 18019: 1
Branch 18020: 1
Branch 18021: 1
Branch 18022: 1
Branch 18023: 1
Branch 18024: 1
Branch 18025: 1
Branch 18026: 1
Branch 18027: 1
Branch 18028: 1
Branch 18029: 1
Branch 18030: 1
Branch 18031: 1
Branch 18032: 1
Branch 18033: 1
Branch 18034: 1
Branch 18035: 1
Branch 18036: 1
Branch 18037: 1
Branch 18038: 1
Branch 18039: 1
Branch 18040: 1
Branch 18041: 1
Branch 18042: 1
Branch 18043: 1
Branch 18044: 1
Branch 18045: 1
Branch 18046: 1
Branch 18047: 1
Branch 18048: 1
Branch 18049: 1
Branch 18050: 1
Branch 18051: 1
Branch 18052: 1
Branch 18053: 1
Branch 18054: 1
Branch 18055: 1
Branch 18056: 1
Branch 18057: 1
Branch 18058: 1
Branch 18059: 1
Branch 18060: 1
Branch 18061: 1
Branch 18062: 1
Branch 18063: 1
Branch 18064: 1
Branch 18065: 1
Branch 18066: 1
Branch 18067: 1
Branch 18068: 1
Branch 18069: 1
Branch 18070: 1
Branch 18071: 1
Branch 18072: 1
Branch 18073: 1
Branch 18074: 1
Branch 18075: 1
Branch 18076: 1
Branch 18077: 1
Branch 18078: 1
Branch 18079: 1
Branch 18080: 1
Branch 18081: 1
Branch 18082: 1
Branch 18083: 1
Branch 18084: 1
Branch 18085: 1
Branch 18086: 1
Branch 18087: 1
Branch 18088: 1
Branch 18089: 1
Branch 18090: 1
Branch 18091: 1
Branch 18092: 1
Branch 18093: 1
Branch 18094: 1
Branch 18095: 1
Branch 18096: 1
Branch 18097: 1
Branch 18098: 1
Branch 18099: 1
Branch 18100: 1
Branch 18101: 1
Branch 18102: 1
Branch 18103: 1
Branch 18104: 1
Branch 18105: 1
Branch 18106: 1
Branch 18107: 1
Branch 18108: 1
Branch 18109: 1
Branch 18110: 1
Branch 18111: 1
Branch 18112: 1
Branch 18113: 1
Branch 18114: 1
Branch 18115: 1
Branch 18116: 1
Branch 18117: 1
Branch 18118: 1
Branch 18119: 1
Branch 18120: 1
Branch 18121: 1
Branch 18122: 1
Branch 18123: 1
Branch 18124: 1
Branch 18125: 1
Branch 18126: 1
Branch 18127: 1
Branch 18128: 1
Branch 18129: 1
Branch 18130: 1
Branch 18131: 1
Branch 18132: 1
Branch 18133: 1
Branch 18134: 1
Branch 18135: 1
Branch 18136: 1
Branch 18137: 1
Branch 18138: 1
Branch 18139: 1
Branch 18140: 1
Branch 18141: 1
Branch 18142: 1
Branch 18143: 1
Branch 18144: 1
Branch 18145: 1
Branch 18146: 1
Branch 18147: 1
Branch 18148: 1
Branch 18149: 1
Branch 18150: 1
Branch 18151: 1
Branch 18152: 1
Branch 18153: 1
Branch 18154: 1
Branch 18155: 1
Branch 18156: 1
Branch 18157: 1
Branch 18158: 1
Branch 18159: 1
Branch 18160: 1
Branch 18161: 1
Branch 18162: 1
Branch 18163: 1
Branch 18164: 1
Branch 18165: 1
Branch 18166: 1
Branch 18167: 1
Branch 18168: 1
Branch 18169: 1
Branch 18170: 1
Branch 18171: 1
Branch 18172: 1
Branch 18173: 1
Branch 18174: 1
Branch 18175: 1
Branch 18176: 1
Branch 18177: 1
Branch 18178: 1
Branch 18179: 1
Branch 18180: 1
Branch 18181: 1
Branch 18182: 1
Branch 18183: 1
Branch 18184: 1
Branch 18185: 1
Branch 18186: 1
Branch 18187: 1
Branch 18188: 1
Branch 18189: 1
Branch 18190: 1
Branch 18191: 1
Branch 18192: 1
Branch 18193: 1
Branch 18194: 1
Branch 18195: 1
Branch 18196: 1
Branch 18197: 1
Branch 18198: 1
Branch 18199: 1
Branch 18200: 1
Branch 18201: 1
Branch 18202: 1
Branch 18203: 1
Branch 18204: 1
Branch 18205: 1
Branch 18206: 1
Branch 18207: 1
Branch 18208: 1
Branch 18209: 1
Branch 18210: 1
Branch 18211: 1
Branch 18212: 1
Branch 18213: 1
Branch 18214: 1
Branch 18215: 1
Branch 18216: 1
Branch 18217: 1
Branch 18218: 1
Branch 18219: 1
Branch 18220: 1
Branch 18221: 1
Branch 18222: 1
Branch 18223: 1
Branch 18224: 1
Branch 18225: 1
Branch 18226: 1
Branch 18227: 1
Branch 18228: 1
Branch 18229: 1
Branch 18230: 1
Branch 18231: 1
Branch 18232: 1
Branch 18233: 1
Branch 18234: 1
Branch 18235: 1
Branch 18236: 1
Branch 18237: 1
Branch 18238: 1
Branch 18239: 1
Branch 18240: 1
Branch 18241: 1
Branch 18242: 1
Branch 18243: 1
Branch 18244: 1
Branch 18245: 1
Branch 18246: 1
Branch 18247: 1
Branch 18248: 1
Branch 18249: 1
Branch 18250: 1
Branch 18251: 1
Branch 18252: 1
Branch 18253: 1
Branch 18254: 1
Branch 18255: 1
Branch 18256: 1
Branch 18257: 1
Branch 18258: 1
Branch 18259: 1
Branch 18260: 1
Branch 18261: 1
Branch 18262: 1
Branch 18263: 1
Branch 18264: 1
Branch 18265: 1
Branch 18266: 1
Branch 18267: 1
Branch 18268: 1
Branch 18269: 1
Branch 18270: 1
Branch 18271: 1
Branch 18272: 1
Branch 18273: 1
Branch 18274: 1
Branch 18275: 1
Branch 18276: 1
Branch 18277: 1
Branch 18278: 1
Branch 18279: 1
Branch 18280: 1
Branch 18281: 1
Branch 18282: 1
Branch 18283: 1
Branch 18284: 1
Branch 18285: 1
Branch 18286: 1
Branch 18287: 1
Branch 18288: 1
Branch 18289: 1
Branch 18290: 1
Branch 18291: 1
Branch 18292: 1
Branch 18293: 1
Branch 18294: 1
Branch 18295: 1
Branch 18296: 1
Branch 18297: 1
Branch 18298: 1
Branch 18299: 1
Branch 18300: 1
Branch 18301: 1
Branch 18302: 1
Branch 18303: 1
Branch 18304: 1
Branch 18305: 1
Branch 18306: 1
Branch 18307: 1
Branch 18308: 1
Branch 18309: 1
Branch 18310: 1
Branch 18311: 1
Branch 18312: 1
Branch 18313: 1
Branch 18314: 1
Branch 18315: 1
Branch 18316: 1
Branch 18317: 1
Branch 18318: 1
Branch 18319: 1
Branch 18320: 1
Branch 18321: 1
Branch 18322: 1
Branch 18323: 1
Branch 18324: 1
Branch 18325: 1
Branch 18326: 1
Branch 18327: 1
Branch 18328: 1
Branch 18329: 1
Branch 18330: 1
Branch 18331: 1
Branch 18332: 1
Branch 18333: 1
Branch 18334: 1
Branch 18335: 1
Branch 18336: 1
Branch 18337: 1
Branch 18338: 1
Branch 18339: 1
Branch 18340: 1
Branch 18341: 1
Branch 18342: 1
Branch 18343: 1
Branch 18344: 1
Branch 18345: 1
Branch 18346: 1
Branch 18347: 1
Branch 18348: 1
Branch 18349: 1
Branch 18350: 1
Branch 18351: 1
Branch 18352: 1
Branch 18353: 1
Branch 18354: 1
Branch 18355: 1
Branch 18356: 1
Branch 18357: 1
Branch 18358: 1
Branch 18359: 1
Branch 18360: 1
Branch 18361: 1
Branch 18362: 1
Branch 18363: 1
Branch 18364: 1
Branch 18365: 1
Branch 18366: 1
Branch 18367: 1
Branch 18368: 1
Branch 18369: 1
Branch 18370: 1
Branch 18371: 1
Branch 18372: 1
Branch 18373: 1
Branch 18374: 1
Branch 18375: 1
Branch 18376: 1
Branch 18377: 1
Branch 18378: 1
Branch 18379: 1
Branch 18380: 1
Branch 18381: 1
Branch 18382: 1
Branch 18383: 1
Branch 18384: 1
Branch 18385: 1
Branch 18386: 1
Branch 18387: 1
Branch 18388: 1
Branch 18389: 1
Branch 18390: 1
Branch 18391: 1
Branch 18392: 1
Branch 18393: 1
Branch 18394: 1
Branch 18395: 1
Branch 18396: 1
Branch 18397: 1
Branch 18398: 1
Branch 18399: 1
Branch 18400: 1
Branch 18401: 1
Branch 18402: 1
Branch 18403: 1
Branch 18404: 1
Branch 18405: 1
Branch 18406: 1
Branch 18407: 1
Branch 18408: 1
Branch 18409: 1
Branch 18410: 1
Branch 18411: 1
Branch 18412: 1
Branch 18413: 1
Branch 18414: 1
Branch 18415: 1
Branch 18416: 1
Branch 18417: 1
Branch 18418: 1
Branch 18419: 1
Branch 18420: 1
Branch 18421: 1
Branch 18422: 1
Branch 18423: 1
Branch 18424: 1
Branch 18425: 1
Branch 18426: 1
Branch 18427: 1
Branch 18428: 1
Branch 18429: 1
Branch 18430: 1
Branch 18431: 1
Branch 18432: 1
Branch 18433: 1
Branch 18434: 1
Branch 18435: 1
Branch 18436: 1
Branch 18437: 1
Branch 18438: 1
Branch 18439: 1
Branch 18440: 1
Branch 18441: 1
Branch 18442: 1
Branch 18443: 1
Branch 18444: 1
Branch 18445: 1
Branch 18446: 1
Branch 18447: 1
Branch 18448: 1
Branch 18449: 1
Branch 18450: 1
Branch 18451: 1
Branch 18452: 1
Branch 18453: 1
Branch 18454: 1
Branch 18455: 1
Branch 18456: 1
Branch 18457: 1
Branch 18458: 1
Branch 18459: 1
Branch 18460: 1
Branch 18461: 1
Branch 18462: 1
Branch 18463: 1
Branch 18464: 1
Branch 18465: 1
Branch 18466: 1
Branch 18467: 1
Branch 18468: 1
Branch 18469: 1
Branch 18470: 1
Branch 18471: 1
Branch 18472: 1
Branch 18473: 1
Branch 18474: 1
Branch 18475: 1
Branch 18476: 1
Branch 18477: 1
Branch 18478: 1
Branch 18479: 1
Branch 18480: 1
Branch 18481: 1
Branch 18482: 1
Branch 18483: 1
Branch 18484: 1
Branch 18485: 1
Branch 18486: 1
Branch 18487: 1
Branch 18488: 1
Branch 18489: 1
Branch 18490: 1
Branch 18491: 1
Branch 18492: 1
Branch 18493: 1
Branch 18494: 1
Branch 18495: 1
Branch 18496: 1
Branch 18497: 1
Branch 18498: 1
Branch 18499: 1
Branch 18500: 1
Branch 18501: 1
Branch 18502: 1
Branch 18503: 1
Branch 18504: 1
Branch 18505: 1
Branch 18506: 1
Branch 18507: 1
Branch 18508: 1
Branch 18509: 1
Branch 18510: 1
Branch 18511: 1
Branch 18512: 1
Branch 18513: 1
Branch 18514: 1
Branch 18515: 1
Branch 18516: 1
Branch 18517: 1
Branch 18518: 1
Branch 18519: 1
Branch 18520: 1
Branch 18521: 1
Branch 18522: 1
Branch 18523: 1
Branch 18524: 1
Branch 18525: 1
Branch 18526: 1
Branch 18527: 1
Branch 18528: 1
Branch 18529: 1
Branch 18530: 1
Branch 18531: 1
Branch 18532: 1
Branch 18533: 1
Branch 18534: 1
Branch 18535: 1
Branch 18536: 1
Branch 18537: 1
Branch 18538: 1
Branch 18539: 1
Branch 18540: 1
Branch 18541: 1
Branch 18542: 1
Branch 18543: 1
Branch 18544: 1
Branch 18545: 1
Branch 18546: 1
Branch 18547: 1
Branch 18548: 1
Branch 18549: 1
Branch 18550: 1
Branch 18551: 1
Branch 18552: 1
Branch 18553: 1
Branch 18554: 1
Branch 18555: 1
Branch 18556: 1
Branch 18557: 1
Branch 18558: 1
Branch 18559: 1
Branch 18560: 1
Branch 18561: 1
Branch 18562: 1
Branch 18563: 1
Branch 18564: 1
Branch 18565: 1
Branch 18566: 1
Branch 18567: 1
Branch 18568: 1
Branch 18569: 1
Branch 18570: 1
Branch 18571: 1
Branch 18572: 1
Branch 18573: 1
Branch 18574: 1
Branch 18575: 1
Branch 18576: 1
Branch 18577: 1
Branch 18578: 1
Branch 18579: 1
Branch 18580: 1
Branch 18581: 1
Branch 18582: 1
Branch 18583: 1
Branch 18584: 1
Branch 18585: 1
Branch 18586: 1
Branch 18587: 1
Branch 18588: 1
Branch 18589: 1
Branch 18590: 1
Branch 18591: 1
Branch 18592: 1
Branch 18593: 1
Branch 18594: 1
Branch 18595: 1
Branch 18596: 1
Branch 18597: 1
Branch 18598: 1
Branch 18599: 1
Branch 18600: 1
Branch 18601: 1
Branch 18602: 1
Branch 18603: 1
Branch 18604: 1
Branch 18605: 1
Branch 18606: 1
Branch 18607: 1
Branch 18608: 1
Branch 18609: 1
Branch 18610: 1
Branch 18611: 1
Branch 18612: 1
Branch 18613: 1
Branch 18614: 1
Branch 18615: 1
Branch 18616: 1
Branch 18617: 1
Branch 18618: 1
Branch 18619: 1
Branch 18620: 1
Branch 18621: 1
Branch 18622: 1
Branch 18623: 1
Branch 18624: 1
Branch 18625: 1
Branch 18626: 1
Branch 18627: 1
Branch 18628: 1
Branch 18629: 1
Branch 18630: 1
Branch 18631: 1
Branch 18632: 1
Branch 18633: 1
Branch 18634: 1
Branch 18635: 1
Branch 18636: 1
Branch 18637: 1
Branch 18638: 1
Branch 18639: 1
Branch 18640: 1
Branch 18641: 1
Branch 18642: 1
Branch 18643: 1
Branch 18644: 1
Branch 18645: 1
Branch 18646: 1
Branch 18647: 1
Branch 18648: 1
Branch 18649: 1
Branch 18650: 1
Branch 18651: 1
Branch 18652: 1
Branch 18653: 1
Branch 18654: 1
Branch 18655: 1
Branch 18656: 1
Branch 18657: 1
Branch 18658: 1
Branch 18659: 1
Branch 18660: 1
Branch 18661: 1
Branch 18662: 1
Branch 18663: 1
Branch 18664: 1
Branch 18665: 1
Branch 18666: 1
Branch 18667: 1
Branch 18668: 1
Branch 18669: 1
Branch 18670: 1
Branch 18671: 1
Branch 18672: 1
Branch 18673: 1
Branch 18674: 1
Branch 18675: 1
Branch 18676: 1
Branch 18677: 1
Branch 18678: 1
Branch 18679: 1
Branch 18680: 1
Branch 18681: 1
Branch 18682: 1
Branch 18683: 1
Branch 18684: 1
Branch 18685: 1
Branch 18686: 1
Branch 18687: 1
Branch 18688: 1
Branch 18689: 1
Branch 18690: 1
Branch 18691: 1
Branch 18692: 1
Branch 18693: 1
Branch 18694: 1
Branch 18695: 1
Branch 18696: 1
Branch 18697: 1
Branch 18698: 1
Branch 18699: 1
Branch 18700: 1
Branch 18701: 1
Branch 18702: 1
Branch 18703: 1
Branch 18704: 1
Branch 18705: 1
Branch 18706: 1
Branch 18707: 1
Branch 18708: 1
Branch 18709: 1
Branch 18710: 1
Branch 18711: 1
Branch 18712: 1
Branch 18713: 1
Branch 18714: 1
Branch 18715: 1
Branch 18716: 1
Branch 18717: 1
Branch 18718: 1
Branch 18719: 1
Branch 18720: 1
Branch 18721: 1
Branch 18722: 1
Branch 18723: 1
Branch 18724: 1
Branch 18725: 1
Branch 18726: 1
Branch 18727: 1
Branch 18728: 1
Branch 18729: 1
Branch 18730: 1
Branch 18731: 1
Branch 18732: 1
Branch 18733: 1
Branch 18734: 1
Branch 18735: 1
Branch 18736: 1
Branch 18737: 1
Branch 18738: 1
Branch 18739: 1
Branch 18740: 1
Branch 18741: 1
Branch 18742: 1
Branch 18743: 1
Branch 18744: 1
Branch 18745: 1
Branch 18746: 1
Branch 18747: 1
Branch 18748: 1
Branch 18749: 1
Branch 18750: 1
Branch 18751: 1
Branch 18752: 1
Branch 18753: 1
Branch 18754: 1
Branch 18755: 1
Branch 18756: 1
Branch 18757: 1
Branch 18758: 1
Branch 18759: 1
Branch 18760: 1
Branch 18761: 1
Branch 18762: 1
Branch 18763: 1
Branch 18764: 1
Branch 18765: 1
Branch 18766: 1
Branch 18767: 1
Branch 18768: 1
Branch 18769: 1
Branch 18770: 1
Branch 18771: 1
Branch 18772: 1
Branch 18773: 1
Branch 18774: 1
Branch 18775: 1
Branch 18776: 1
Branch 18777: 1
Branch 18778: 1
Branch 18779: 1
Branch 18780: 1
Branch 18781: 1
Branch 18782: 1
Branch 18783: 1
Branch 18784: 1
Branch 18785: 1
Branch 18786: 1
Branch 18787: 1
Branch 18788: 1
Branch 18789: 1
Branch 18790: 1
Branch 18791: 1
Branch 18792: 1
Branch 18793: 1
Branch 18794: 1
Branch 18795: 1
Branch 18796: 1
Branch 18797: 1
Branch 18798: 1
Branch 18799: 1
Branch 18800: 1
Branch 18801: 1
Branch 18802: 1
Branch 18803: 1
Branch 18804: 1
Branch 18805: 1
Branch 18806: 1
Branch 18807: 1
Branch 18808: 1
Branch 18809: 1
Branch 18810: 1
Branch 18811: 1
Branch 18812: 1
Branch 18813: 1
Branch 18814: 1
Branch 18815: 1
Branch 18816: 1
Branch 18817: 1
Branch 18818: 1
Branch 18819: 1
Branch 18820: 1
Branch 18821: 1
Branch 18822: 1
Branch 18823: 1
Branch 18824: 1
Branch 18825: 1
Branch 18826: 1
Branch 18827: 1
Branch 18828: 1
Branch 18829: 1
Branch 18830: 1
Branch 18831: 1
Branch 18832: 1
Branch 18833: 1
Branch 18834: 1
Branch 18835: 1
Branch 18836: 1
Branch 18837: 1
Branch 18838: 1
Branch 18839: 1
Branch 18840: 1
Branch 18841: 1
Branch 18842: 1
Branch 18843: 1
Branch 18844: 1
Branch 18845: 1
Branch 18846: 1
Branch 18847: 1
Branch 18848: 1
Branch 18849: 1
Branch 18850: 1
Branch 18851: 1
Branch 18852: 1
Branch 18853: 1
Branch 18854: 1
Branch 18855: 1
Branch 18856: 1
Branch 18857: 1
Branch 18858: 1
Branch 18859: 1
Branch 18860: 1
Branch 18861: 1
Branch 18862: 1
Branch 18863: 1
Branch 18864: 1
Branch 18865: 1
Branch 18866: 1
Branch 18867: 1
Branch 18868: 1
Branch 18869: 1
Branch 18870: 1
Branch 18871: 1
Branch 18872: 1
Branch 18873: 1
Branch 18874: 1
Branch 18875: 1
Branch 18876: 1
Branch 18877: 1
Branch 18878: 1
Branch 18879: 1
Branch 18880: 1
Branch 18881: 1
Branch 18882: 1
Branch 18883: 1
Branch 18884: 1
Branch 18885: 1
Branch 18886: 1
Branch 18887: 1
Branch 18888: 1
Branch 18889: 1
Branch 18890: 1
Branch 18891: 1
Branch 18892: 1
Branch 18893: 1
Branch 18894: 1
Branch 18895: 1
Branch 18896: 1
Branch 18897: 1
Branch 18898: 1
Branch 18899: 1
Branch 18900: 1
Branch 18901: 1
Branch 18902: 1
Branch 18903: 1
Branch 18904: 1
Branch 18905: 1
Branch 18906: 1
Branch 18907: 1
Branch 18908: 1
Branch 18909: 1
Branch 18910: 1
Branch 18911: 1
Branch 18912: 1
Branch 18913: 1
Branch 18914: 1
Branch 18915: 1
Branch 18916: 1
Branch 18917: 1
Branch 18918: 1
Branch 18919: 1
Branch 18920: 1
Branch 18921: 1
Branch 18922: 1
Branch 18923: 1
Branch 18924: 1
Branch 18925: 1
Branch 18926: 1
Branch 18927: 1
Branch 18928: 1
Branch 18929: 1
Branch 18930: 1
Branch 18931: 1
Branch 18932: 1
Branch 18933: 1
Branch 18934: 1
Branch 18935: 1
Branch 18936: 1
Branch 18937: 1
Branch 18938: 1
Branch 18939: 1
Branch 18940: 1
Branch 18941: 1
Branch 18942: 1
Branch 18943: 1
Branch 18944: 1
Branch 18945: 1
Branch 18946: 1
Branch 18947: 1
Branch 18948: 1
Branch 18949: 1
Branch 18950: 1
Branch 18951: 1
Branch 18952: 1
Branch 18953: 1
Branch 18954: 1
Branch 18955: 1
Branch 18956: 1
Branch 18957: 1
Branch 18958: 1
Branch 18959: 1
Branch 18960: 1
Branch 18961: 1
Branch 18962: 1
Branch 18963: 1
Branch 18964: 1
Branch 18965: 1
Branch 18966: 1
Branch 18967: 1
Branch 18968: 1
Branch 18969: 1
Branch 18970: 1
Branch 18971: 1
Branch 18972: 1
Branch 18973: 1
Branch 18974: 1
Branch 18975: 1
Branch 18976: 1
Branch 18977: 1
Branch 18978: 1
Branch 18979: 1
Branch 18980: 1
Branch 18981: 1
Branch 18982: 1
Branch 18983: 1
Branch 18984: 1
Branch 18985: 1
Branch 18986: 1
Branch 18987: 1
Branch 18988: 1
Branch 18989: 1
Branch 18990: 1
Branch 18991: 1
Branch 18992: 1
Branch 18993: 1
Branch 18994: 1
Branch 18995: 1
Branch 18996: 1
Branch 18997: 1
Branch 18998: 1
Branch 18999: 1
Branch 19000: 1
Branch 19001: 1
Branch 19002: 1
Branch 19003: 1
Branch 19004: 1
Branch 19005: 1
Branch 19006: 1
Branch 19007: 1
Branch 19008: 1
Branch 19009: 1
Branch 19010: 1
Branch 19011: 1
Branch 19012: 1
Branch 19013: 1
Branch 19014: 1
Branch 19015: 1
Branch 19016: 1
Branch 19017: 1
Branch 19018: 1
Branch 19019: 1
Branch 19020: 1
Branch 19021: 1
Branch 19022: 1
Branch 19023: 1
Branch 19024: 1
Branch 19025: 1
Branch 19026: 1
Branch 19027: 1
Branch 19028: 1
Branch 19029: 1
Branch 19030: 1
Branch 19031: 1
Branch 19032: 1
Branch 19033: 1
Branch 19034: 1
Branch 19035: 1
Branch 19036: 1
Branch 19037: 1
Branch 19038: 1
Branch 19039: 1
Branch 19040: 1
Branch 19041: 1
Branch 19042: 1
Branch 19043: 1
Branch 19044: 1
Branch 19045: 1
Branch 19046: 1
Branch 19047: 1
Branch 19048: 1
Branch 19049: 1
Branch 19050: 1
Branch 19051: 1
Branch 19052: 1
Branch 19053: 1
Branch 19054: 1
Branch 19055: 1
Branch 19056: 1
Branch 19057: 1
Branch 19058: 1
Branch 19059: 1
Branch 19060: 1
Branch 19061: 1
Branch 19062: 1
Branch 19063: 1
Branch 19064: 1
Branch 19065: 1
Branch 19066: 1
Branch 19067: 1
Branch 19068: 1
Branch 19069: 1
Branch 19070: 1
Branch 19071: 1
Branch 19072: 1
Branch 19073: 1
Branch 19074: 1
Branch 19075: 1
Branch 19076: 1
Branch 19077: 1
Branch 19078: 1
Branch 19079: 1
Branch 19080: 1
Branch 19081: 1
Branch 19082: 1
Branch 19083: 1
Branch 19084: 1
Branch 19085: 1
Branch 19086: 1
Branch 19087: 1
Branch 19088: 1
Branch 19089: 1
Branch 19090: 1
Branch 19091: 1
Branch 19092: 1
Branch 19093: 1
Branch 19094: 1
Branch 19095: 1
Branch 19096: 1
Branch 19097: 1
Branch 19098: 1
Branch 19099: 1
Branch 19100: 1
Branch 19101: 1
Branch 19102: 1
Branch 19103: 1
Branch 19104: 1
Branch 19105: 1
Branch 19106: 1
Branch 19107: 1
Branch 19108: 1
Branch 19109: 1
Branch 19110: 1
Branch 19111: 1
Branch 19112: 1
Branch 19113: 1
Branch 19114: 1
Branch 19115: 1
Branch 19116: 1
Branch 19117: 1
Branch 19118: 1
Branch 19119: 1
Branch 19120: 1
Branch 19121: 1
Branch 19122: 1
Branch 19123: 1
Branch 19124: 1
Branch 19125: 1
Branch 19126: 1
Branch 19127: 1
Branch 19128: 1
Branch 19129: 1
Branch 19130: 1
Branch 19131: 1
Branch 19132: 1
Branch 19133: 1
Branch 19134: 1
Branch 19135: 1
Branch 19136: 1
Branch 19137: 1
Branch 19138: 1
Branch 19139: 1
Branch 19140: 1
Branch 19141: 1
Branch 19142: 1
Branch 19143: 1
Branch 19144: 1
Branch 19145: 1
Branch 19146: 1
Branch 19147: 1
Branch 19148: 1
Branch 19149: 1
Branch 19150: 1
Branch 19151: 1
Branch 19152: 1
Branch 19153: 1
Branch 19154: 1
Branch 19155: 1
Branch 19156: 1
Branch 19157: 1
Branch 19158: 1
Branch 19159: 1
Branch 19160: 1
Branch 19161: 1
Branch 19162: 1
Branch 19163: 1
Branch 19164: 1
Branch 19165: 1
Branch 19166: 1
Branch 19167: 1
Branch 19168: 1
Branch 19169: 1
Branch 19170: 1
Branch 19171: 1
Branch 19172: 1
Branch 19173: 1
Branch 19174: 1
Branch 19175: 1
Branch 19176: 1
Branch 19177: 1
Branch 19178: 1
Branch 19179: 1
Branch 19180: 1
Branch 19181: 1
Branch 19182: 1
Branch 19183: 1
Branch 19184: 1
Branch 19185: 1
Branch 19186: 1
Branch 19187: 1
Branch 19188: 1
Branch 19189: 1
Branch 19190: 1
Branch 19191: 1
Branch 19192: 1
Branch 19193: 1
Branch 19194: 1
Branch 19195: 1
Branch 19196: 1
Branch 19197: 1
Branch 19198: 1
Branch 19199: 1
Branch 19200: 1
Branch 19201: 1
Branch 19202: 1
Branch 19203: 1
Branch 19204: 1
Branch 19205: 1
Branch 19206: 1
Branch 19207: 1
Branch 19208: 1
Branch 19209: 1
Branch 19210: 1
Branch 19211: 1
Branch 19212: 1
Branch 19213: 1
Branch 19214: 1
Branch 19215: 1
Branch 19216: 1
Branch 19217: 1
Branch 19218: 1
Branch 19219: 1
Branch 19220: 1
Branch 19221: 1
Branch 19222: 1
Branch 19223: 1
Branch 19224: 1
Branch 19225: 1
Branch 19226: 1
Branch 19227: 1
Branch 19228: 1
Branch 19229: 1
Branch 19230: 1
Branch 19231: 1
Branch 19232: 1
Branch 19233: 1
Branch 19234: 1
Branch 19235: 1
Branch 19236: 1
Branch 19237: 1
Branch 19238: 1
Branch 19239: 1
Branch 19240: 1
Branch 19241: 1
Branch 19242: 1
Branch 19243: 1
Branch 19244: 1
Branch 19245: 1
Branch 19246: 1
Branch 19247: 1
Branch 19248: 1
Branch 19249: 1
Branch 19250: 1
Branch 19251: 1
Branch 19252: 1
Branch 19253: 1
Branch 19254: 1
Branch 19255: 1
Branch 19256: 1
Branch 19257: 1
Branch 19258: 1
Branch 19259: 1
Branch 19260: 1
Branch 19261: 1
Branch 19262: 1
Branch 19263: 1
Branch 19264: 1
Branch 19265: 1
Branch 19266: 1
Branch 19267: 1
Branch 19268: 1
Branch 19269: 1
Branch 19270: 1
Branch 19271: 1
Branch 19272: 1
Branch 19273: 1
Branch 19274: 1
Branch 19275: 1
Branch 19276: 1
Branch 19277: 1
Branch 19278: 1
Branch 19279: 1
Branch 19280: 1
Branch 19281: 1
Branch 19282: 1
Branch 19283: 1
Branch 19284: 1
Branch 19285: 1
Branch 19286: 1
Branch 19287: 1
Branch 19288: 1
Branch 19289: 1
Branch 19290: 1
Branch 19291: 1
Branch 19292: 1
Branch 19293: 1
Branch 19294: 1
Branch 19295: 1
Branch 19296: 1
Branch 19297: 1
Branch 19298: 1
Branch 19299: 1
Branch 19300: 1
Branch 19301: 1
Branch 19302: 1
Branch 19303: 1
Branch 19304: 1
Branch 19305: 1
Branch 19306: 1
Branch 19307: 1
Branch 19308: 1
Branch 19309: 1
Branch 19310: 1
Branch 19311: 1
Branch 19312: 1
Branch 19313: 1
Branch 19314: 1
Branch 19315: 1
Branch 19316: 1
Branch 19317: 1
Branch 19318: 1
Branch 19319: 1
Branch 19320: 1
Branch 19321: 1
Branch 19322: 1
Branch 19323: 1
Branch 19324: 1
Branch 19325: 1
Branch 19326: 1
Branch 19327: 1
Branch 19328: 1
Branch 19329: 1
Branch 19330: 1
Branch 19331: 1
Branch 19332: 1
Branch 19333: 1
Branch 19334: 1
Branch 19335: 1
Branch 19336: 1
Branch 19337: 1
Branch 19338: 1
Branch 19339: 1
Branch 19340: 1
Branch 19341: 1
Branch 19342: 1
Branch 19343: 1
Branch 19344: 1
Branch 19345: 1
Branch 19346: 1
Branch 19347: 1
Branch 19348: 1
Branch 19349: 1
Branch 19350: 1
Branch 19351: 1
Branch 19352: 1
Branch 19353: 1
Branch 19354: 1
Branch 19355: 1
Branch 19356: 1
Branch 19357: 1
Branch 19358: 1
Branch 19359: 1
Branch 19360: 1
Branch 19361: 1
Branch 19362: 1
Branch 19363: 1
Branch 19364: 1
Branch 19365: 1
Branch 19366: 1
Branch 19367: 1
Branch 19368: 1
Branch 19369: 1
Branch 19370: 1
Branch 19371: 1
Branch 19372: 1
Branch 19373: 1
Branch 19374: 1
Branch 19375: 1
Branch 19376: 1
Branch 19377: 1
Branch 19378: 1
Branch 19379: 1
Branch 19380: 1
Branch 19381: 1
Branch 19382: 1
Branch 19383: 1
Branch 19384: 1
Branch 19385: 1
Branch 19386: 1
Branch 19387: 1
Branch 19388: 1
Branch 19389: 1
Branch 19390: 1
Branch 19391: 1
Branch 19392: 1
Branch 19393: 1
Branch 19394: 1
Branch 19395: 1
Branch 19396: 1
Branch 19397: 1
Branch 19398: 1
Branch 19399: 1
Branch 19400: 1
Branch 19401: 1
Branch 19402: 1
Branch 19403: 1
Branch 19404: 1
Branch 19405: 1
Branch 19406: 1
Branch 19407: 1
Branch 19408: 1
Branch 19409: 1
Branch 19410: 1
Branch 19411: 1
Branch 19412: 1
Branch 19413: 1
Branch 19414: 1
Branch 19415: 1
Branch 19416: 1
Branch 19417: 1
Branch 19418: 1
Branch 19419: 1
Branch 19420: 1
Branch 19421: 1
Branch 19422: 1
Branch 19423: 1
Branch 19424: 1
Branch 19425: 1
Branch 19426: 1
Branch 19427: 1
Branch 19428: 1
Branch 19429: 1
Branch 19430: 1
Branch 19431: 1
Branch 19432: 1
Branch 19433: 1
Branch 19434: 1
Branch 19435: 1
Branch 19436: 1
Branch 19437: 1
Branch 19438: 1
Branch 19439: 1
Branch 19440: 1
Branch 19441: 1
Branch 19442: 1
Branch 19443: 1
Branch 19444: 1
Branch 19445: 1
Branch 19446: 1
Branch 19447: 1
Branch 19448: 1
Branch 19449: 1
Branch 19450: 1
Branch 19451: 1
Branch 19452: 1
Branch 19453: 1
Branch 19454: 1
Branch 19455: 1
Branch 19456: 1
Branch 19457: 1
Branch 19458: 1
Branch 19459: 1
Branch 19460: 1
Branch 19461: 1
Branch 19462: 1
Branch 19463: 1
Branch 19464: 1
Branch 19465: 1
Branch 19466: 1
Branch 19467: 1
Branch 19468: 1
Branch 19469: 1
Branch 19470: 1
Branch 19471: 1
Branch 19472: 1
Branch 19473: 1
Branch 19474: 1
Branch 19475: 1
Branch 19476: 1
Branch 19477: 1
Branch 19478: 1
Branch 19479: 1
Branch 19480: 1
Branch 19481: 1
Branch 19482: 1
Branch 19483: 1
Branch 19484: 1
Branch 19485: 1
Branch 19486: 1
Branch 19487: 1
Branch 19488: 1
Branch 19489: 1
Branch 19490: 1
Branch 19491: 1
Branch 19492: 1
Branch 19493: 1
Branch 19494: 1
Branch 19495: 1
Branch 19496: 1
Branch 19497: 1
Branch 19498: 1
Branch 19499: 1
Branch 19500: 1
Branch 19501: 1
Branch 19502: 1
Branch 19503: 1
Branch 19504: 1
Branch 19505: 1
Branch 19506: 1
Branch 19507: 1
Branch 19508: 1
Branch 19509: 1
Branch 19510: 1
Branch 19511: 1
Branch 19512: 1
Branch 19513: 1
Branch 19514: 1
Branch 19515: 1
Branch 19516: 1
Branch 19517: 1
Branch 19518: 1
Branch 19519: 1
Branch 19520: 1
Branch 19521: 1
Branch 19522: 1
Branch 19523: 1
Branch 19524: 1
Branch 19525: 1
Branch 19526: 1
Branch 19527: 1
Branch 19528: 1
Branch 19529: 1
Branch 19530: 1
Branch 19531: 1
Branch 19532: 1
Branch 19533: 1
Branch 19534: 1
Branch 19535: 1
Branch 19536: 1
Branch 19537: 1
Branch 19538: 1
Branch 19539: 1
Branch 19540: 1
Branch 19541: 1
Branch 19542: 1
Branch 19543: 1
Branch 19544: 1
Branch 19545: 1
Branch 19546: 1
Branch 19547: 1
Branch 19548: 1
Branch 19549: 1
Branch 19550: 1
Branch 19551: 1
Branch 19552: 1
Branch 19553: 1
Branch 19554: 1
Branch 19555: 1
Branch 19556: 1
Branch 19557: 1
Branch 19558: 1
Branch 19559: 1
Branch 19560: 1
Branch 19561: 1
Branch 19562: 1
Branch 19563: 1
Branch 19564: 1
Branch 19565: 1
Branch 19566: 1
Branch 19567: 1
Branch 19568: 1
Branch 19569: 1
Branch 19570: 1
Branch 19571: 1
Branch 19572: 1
Branch 19573: 1
Branch 19574: 1
Branch 19575: 1
Branch 19576: 1
Branch 19577: 1
Branch 19578: 1
Branch 19579: 1
Branch 19580: 1
Branch 19581: 1
Branch 19582: 1
Branch 19583: 1
Branch 19584: 1
Branch 19585: 1
Branch 19586: 1
Branch 19587: 1
Branch 19588: 1
Branch 19589: 1
Branch 19590: 1
Branch 19591: 1
Branch 19592: 1
Branch 19593: 1
Branch 19594: 1
Branch 19595: 1
Branch 19596: 1
Branch 19597: 1
Branch 19598: 1
Branch 19599: 1
Branch 19600: 1
Branch 19601: 1
Branch 19602: 1
Branch 19603: 1
Branch 19604: 1
Branch 19605: 1
Branch 19606: 1
Branch 19607: 1
Branch 19608: 1
Branch 19609: 1
Branch 19610: 1
Branch 19611: 1
Branch 19612: 1
Branch 19613: 1
Branch 19614: 1
Branch 19615: 1
Branch 19616: 1
Branch 19617: 1
Branch 19618: 1
Branch 19619: 1
Branch 19620: 1
Branch 19621: 1
Branch 19622: 1
Branch 19623: 1
Branch 19624: 1
Branch 19625: 1
Branch 19626: 1
Branch 19627: 1
Branch 19628: 1
Branch 19629: 1
Branch 19630: 1
Branch 19631: 1
Branch 19632: 1
Branch 19633: 1
Branch 19634: 1
Branch 19635: 1
Branch 19636: 1
Branch 19637: 1
Branch 19638: 1
Branch 19639: 1
Branch 19640: 1
Branch 19641: 1
Branch 19642: 1
Branch 19643: 1
Branch 19644: 1
Branch 19645: 1
Branch 19646: 1
Branch 19647: 1
Branch 19648: 1
Branch 19649: 1
Branch 19650: 1
Branch 19651: 1
Branch 19652: 1
Branch 19653: 1
Branch 19654: 1
Branch 19655: 1
Branch 19656: 1
Branch 19657: 1
Branch 19658: 1
Branch 19659: 1
Branch 19660: 1
Branch 19661: 1
Branch 19662: 1
Branch 19663: 1
Branch 19664: 1
Branch 19665: 1
Branch 19666: 1
Branch 19667: 1
Branch 19668: 1
Branch 19669: 1
Branch 19670: 1
Branch 19671: 1
Branch 19672: 1
Branch 19673: 1
Branch 19674: 1
Branch 19675: 1
Branch 19676: 1
Branch 19677: 1
Branch 19678: 1
Branch 19679: 1
Branch 19680: 1
Branch 19681: 1
Branch 19682: 1
Branch 19683: 1
Branch 19684: 1
Branch 19685: 1
Branch 19686: 1
Branch 19687: 1
Branch 19688: 1
Branch 19689: 1
Branch 19690: 1
Branch 19691: 1
Branch 19692: 1
Branch 19693: 1
Branch 19694: 1
Branch 19695: 1
Branch 19696: 1
Branch 19697: 1
Branch 19698: 1
Branch 19699: 1
Branch 19700: 1
Branch 19701: 1
Branch 19702: 1
Branch 19703: 1
Branch 19704: 1
Branch 19705: 1
Branch 19706: 1
Branch 19707: 1
Branch 19708: 1
Branch 19709: 1
Branch 19710: 1
Branch 19711: 1
Branch 19712: 1
Branch 19713: 1
Branch 19714: 1
Branch 19715: 1
Branch 19716: 1
Branch 19717: 1
Branch 19718: 1
Branch 19719: 1
Branch 19720: 1
Branch 19721: 1
Branch 19722: 1
Branch 19723: 1
Branch 19724: 1
Branch 19725: 1
Branch 19726: 1
Branch 19727: 1
Branch 19728: 1
Branch 19729: 1
Branch 19730: 1
Branch 19731: 1
Branch 19732: 1
Branch 19733: 1
Branch 19734: 1
Branch 19735: 1
Branch 19736: 1
Branch 19737: 1
Branch 19738: 1
Branch 19739: 1
Branch 19740: 1
Branch 19741: 1
Branch 19742: 1
Branch 19743: 1
Branch 19744: 1
Branch 19745: 1
Branch 19746: 1
Branch 19747: 1
Branch 19748: 1
Branch 19749: 1
Branch 19750: 1
Branch 19751: 1
Branch 19752: 1
Branch 19753: 1
Branch 19754: 1
Branch 19755: 1
Branch 19756: 1
Branch 19757: 1
Branch 19758: 1
Branch 19759: 1
Branch 19760: 1
Branch 19761: 1
Branch 19762: 1
Branch 19763: 1
Branch 19764: 1
Branch 19765: 1
Branch 19766: 1
Branch 19767: 1
Branch 19768: 1
Branch 19769: 1
Branch 19770: 1
Branch 19771: 1
Branch 19772: 1
Branch 19773: 1
Branch 19774: 1
Branch 19775: 1
Branch 19776: 1
Branch 19777: 1
Branch 19778: 1
Branch 19779: 1
Branch 19780: 1
Branch 19781: 1
Branch 19782: 1
Branch 19783: 1
Branch 19784: 1
Branch 19785: 1
Branch 19786: 1
Branch 19787: 1
Branch 19788: 1
Branch 19789: 1
Branch 19790: 1
Branch 19791: 1
Branch 19792: 1
Branch 19793: 1
Branch 19794: 1
Branch 19795: 1
Branch 19796: 1
Branch 19797: 1
Branch 19798: 1
Branch 19799: 1
Branch 19800: 1
Branch 19801: 1
Branch 19802: 1
Branch 19803: 1
Branch 19804: 1
Branch 19805: 1
Branch 19806: 1
Branch 19807: 1
Branch 19808: 1
Branch 19809: 1
Branch 19810: 1
Branch 19811: 1
Branch 19812: 1
Branch 19813: 1
Branch 19814: 1
Branch 19815: 1
Branch 19816: 1
Branch 19817: 1
Branch 19818: 1
Branch 19819: 1
Branch 19820: 1
Branch 19821: 1
Branch 19822: 1
Branch 19823: 1
Branch 19824: 1
Branch 19825: 1
Branch 19826: 1
Branch 19827: 1
Branch 19828: 1
Branch 19829: 1
Branch 19830: 1
Branch 19831: 1
Branch 19832: 1
Branch 19833: 1
Branch 19834: 1
Branch 19835: 1
Branch 19836: 1
Branch 19837: 1
Branch 19838: 1
Branch 19839: 1
Branch 19840: 1
Branch 19841: 1
Branch 19842: 1
Branch 19843: 1
Branch 19844: 1
Branch 19845: 1
Branch 19846: 1
Branch 19847: 1
Branch 19848: 1
Branch 19849: 1
Branch 19850: 1
Branch 19851: 1
Branch 19852: 1
Branch 19853: 1
Branch 19854: 1
Branch 19855: 1
Branch 19856: 1
Branch 19857: 1
Branch 19858: 1
Branch 19859: 1
Branch 19860: 1
Branch 19861: 1
Branch 19862: 1
Branch 19863: 1
Branch 19864: 1
Branch 19865: 1
Branch 19866: 1
Branch 19867: 1
Branch 19868: 1
Branch 19869: 1
Branch 19870: 1
Branch 19871: 1
Branch 19872: 1
Branch 19873: 1
Branch 19874: 1
Branch 19875: 1
Branch 19876: 1
Branch 19877: 1
Branch 19878: 1
Branch 19879: 1
Branch 19880: 1
Branch 19881: 1
Branch 19882: 1
Branch 19883: 1
Branch 19884: 1
Branch 19885: 1
Branch 19886: 1
Branch 19887: 1
Branch 19888: 1
Branch 19889: 1
Branch 19890: 1
Branch 19891: 1
Branch 19892: 1
Branch 19893: 1
Branch 19894: 1
Branch 19895: 1
Branch 19896: 1
Branch 19897: 1
Branch 19898: 1
Branch 19899: 1
Branch 19900: 1
Branch 19901: 1
Branch 19902: 1
Branch 19903: 1
Branch 19904: 1
Branch 19905: 1
Branch 19906: 1
Branch 19907: 1
Branch 19908: 1
Branch 19909: 1
Branch 19910: 1
Branch 19911: 1
Branch 19912: 1
Branch 19913: 1
Branch 19914: 1
Branch 19915: 1
Branch 19916: 1
Branch 19917: 1
Branch 19918: 1
Branch 19919: 1
Branch 19920: 1
Branch 19921: 1
Branch 19922: 1
Branch 19923: 1
Branch 19924: 1
Branch 19925: 1
Branch 19926: 1
Branch 19927: 1
Branch 19928: 1
Branch 19929: 1
Branch 19930: 1
Branch 19931: 1
Branch 19932: 1
Branch 19933: 1
Branch 19934: 1
Branch 19935: 1
Branch 19936: 1
Branch 19937: 1
Branch 19938: 1
Branch 19939: 1
Branch 19940: 1
Branch 19941: 1
Branch 19942: 1
Branch 19943: 1
Branch 19944: 1
Branch 19945: 1
Branch 19946: 1
Branch 19947: 1
Branch 19948: 1
Branch 19949: 1
Branch 19950: 1
Branch 19951: 1
Branch 19952: 1
Branch 19953: 1
Branch 19954: 1
Branch 19955: 1
Branch 19956: 1
Branch 19957: 1
Branch 19958: 1
Branch 19959: 1
Branch 19960: 1
Branch 19961: 1
Branch 19962: 1
Branch 19963: 1
Branch 19964: 1
Branch 19965: 1
Branch 19966: 1
Branch 19967: 1
Branch 19968: 1
Branch 19969: 1
Branch 19970: 1
Branch 19971: 1
Branch 19972: 1
Branch 19973: 1
Branch 19974: 1
Branch 19975: 1
Branch 19976: 1
Branch 19977: 1
Branch 19978: 1
Branch 19979: 1
Branch 19980: 1
Branch 19981: 1
Branch 19982: 1
Branch 19983: 1
Branch 19984: 1
Branch 19985: 1
Branch 19986: 1
Branch 19987: 1
Branch 19988: 1
Branch 19989: 1
Branch 19990: 1
Branch 19991: 1
Branch 19992: 1
Branch 19993: 1
Branch 19994: 1
Branch 19995: 1
Branch 19996: 1
Branch 19997: 1
Branch 19998: 1
Branch 19999: 1
Branch 20000: 1
Branch 20001: 1
Branch 20002: 1
Branch 20003: 1
Branch 20004: 1
Branch 20005: 1
Branch 20006: 1
Branch 20007: 1
Branch 20008: 1
Branch 20009: 1
Branch 20010: 1
Branch 20011: 1
Branch 20012: 1
Branch 20013: 1
Branch 20014: 1
Branch 20015: 1
Branch 20016: 1
Branch 20017: 1
Branch 20018: 1
Branch 20019: 1
Branch 20020: 1
Branch 20021: 1
Branch 20022: 1
Branch 20023: 1
Branch 20024: 1
Branch 20025: 1
Branch 20026: 1
Branch 20027: 1
Branch 20028: 1
Branch 20029: 1
Branch 20030: 1
Branch 20031: 1
Branch 20032: 1
Branch 20033: 1
Branch 20034: 1
Branch 20035: 1
Branch 20036: 1
Branch 20037: 1
Branch 20038: 1
Branch 20039: 1
Branch 20040: 1
Branch 20041: 1
Branch 20042: 1
Branch 20043: 1
Branch 20044: 1
Branch 20045: 1
Branch 20046: 1
Branch 20047: 1
Branch 20048: 1
Branch 20049: 1
Branch 20050: 1
Branch 20051: 1
Branch 20052: 1
Branch 20053: 1
Branch 20054: 1
Branch 20055: 1
Branch 20056: 1
Branch 20057: 1
Branch 20058: 1
Branch 20059: 1
Branch 20060: 1
Branch 20061: 1
Branch 20062: 1
Branch 20063: 1
Branch 20064: 1
Branch 20065: 1
Branch 20066: 1
Branch 20067: 1
Branch 20068: 1
Branch 20069: 1
Branch 20070: 1
Branch 20071: 1
Branch 20072: 1
Branch 20073: 1
Branch 20074: 1
Branch 20075: 1
Branch 20076: 1
Branch 20077: 1
Branch 20078: 1
Branch 20079: 1
Branch 20080: 1
Branch 20081: 1
Branch 20082: 1
Branch 20083: 1
Branch 20084: 1
Branch 20085: 1
Branch 20086: 1
Branch 20087: 1
Branch 20088: 1
Branch 20089: 1
Branch 20090: 1
Branch 20091: 1
Branch 20092: 1
Branch 20093: 1
Branch 20094: 1
Branch 20095: 1
Branch 20096: 1
Branch 20097: 1
Branch 20098: 1
Branch 20099: 1
Branch 20100: 1
Branch 20101: 1
Branch 20102: 1
Branch 20103: 1
Branch 20104: 1
Branch 20105: 1
Branch 20106: 1
Branch 20107: 1
Branch 20108: 1
Branch 20109: 1
Branch 20110: 1
Branch 20111: 1
Branch 20112: 1
Branch 20113: 1
Branch 20114: 1
Branch 20115: 1
Branch 20116: 1
Branch 20117: 1
Branch 20118: 1
Branch 20119: 1
Branch 20120: 1
Branch 20121: 1
Branch 20122: 1
Branch 20123: 1
Branch 20124: 1
Branch 20125: 1
Branch 20126: 1
Branch 20127: 1
Branch 20128: 1
Branch 20129: 1
Branch 20130: 1
Branch 20131: 1
Branch 20132: 1
Branch 20133: 1
Branch 20134: 1
Branch 20135: 1
Branch 20136: 1
Branch 20137: 1
Branch 20138: 1
Branch 20139: 1
Branch 20140: 1
Branch 20141: 1
Branch 20142: 1
Branch 20143: 1
Branch 20144: 1
Branch 20145: 1
Branch 20146: 1
Branch 20147: 1
Branch 20148: 1
Branch 20149: 1
Branch 20150: 1
Branch 20151: 1
Branch 20152: 1
Branch 20153: 1
Branch 20154: 1
Branch 20155: 1
Branch 20156: 1
Branch 20157: 1
Branch 20158: 1
Branch 20159: 1
Branch 20160: 1
Branch 20161: 1
Branch 20162: 1
Branch 20163: 1
Branch 20164: 1
Branch 20165: 1
Branch 20166: 1
Branch 20167: 1
Branch 20168: 1
Branch 20169: 1
Branch 20170: 1
Branch 20171: 1
Branch 20172: 1
Branch 20173: 1
Branch 20174: 1
Branch 20175: 1
Branch 20176: 1
Branch 20177: 1
Branch 20178: 1
Branch 20179: 1
Branch 20180: 1
Branch 20181: 1
Branch 20182: 1
Branch 20183: 1
Branch 20184: 1
Branch 20185: 1
Branch 20186: 1
Branch 20187: 1
Branch 20188: 1
Branch 20189: 1
Branch 20190: 1
Branch 20191: 1
Branch 20192: 1
Branch 20193: 1
Branch 20194: 1
Branch 20195: 1
Branch 20196: 1
Branch 20197: 1
Branch 20198: 1
Branch 20199: 1
Branch 20200: 1
Branch 20201: 1
Branch 20202: 1
Branch 20203: 1
Branch 20204: 1
Branch 20205: 1
Branch 20206: 1
Branch 20207: 1
Branch 20208: 1
Branch 20209: 1
Branch 20210: 1
Branch 20211: 1
Branch 20212: 1
Branch 20213: 1
Branch 20214: 1
Branch 20215: 1
Branch 20216: 1
Branch 20217: 1
Branch 20218: 1
Branch 20219: 1
Branch 20220: 1
Branch 20221: 1
Branch 20222: 1
Branch 20223: 1
Branch 20224: 1
Branch 20225: 1
Branch 20226: 1
Branch 20227: 1
Branch 20228: 1
Branch 20229: 1
Branch 20230: 1
Branch 20231: 1
Branch 20232: 1
Branch 20233: 1
Branch 20234: 1
Branch 20235: 1
Branch 20236: 1
Branch 20237: 1
Branch 20238: 1
Branch 20239: 1
Branch 20240: 1
Branch 20241: 1
Branch 20242: 1
Branch 20243: 1
Branch 20244: 1
Branch 20245: 1
Branch 20246: 1
Branch 20247: 1
Branch 20248: 1
Branch 20249: 1
Branch 20250: 1
Branch 20251: 1
Branch 20252: 1
Branch 20253: 1
Branch 20254: 1
Branch 20255: 1
Branch 20256: 1
Branch 20257: 1
Branch 20258: 1
Branch 20259: 1
Branch 20260: 1
Branch 20261: 1
Branch 20262: 1
Branch 20263: 1
Branch 20264: 1
Branch 20265: 1
Branch 20266: 1
Branch 20267: 1
Branch 20268: 1
Branch 20269: 1
Branch 20270: 1
Branch 20271: 1
Branch 20272: 1
Branch 20273: 1
Branch 20274: 1
Branch 20275: 1
Branch 20276: 1
Branch 20277: 1
Branch 20278: 1
Branch 20279: 1
Branch 20280: 1
Branch 20281: 1
Branch 20282: 1
Branch 20283: 1
Branch 20284: 1
Branch 20285: 1
Branch 20286: 1
Branch 20287: 1
Branch 20288: 1
Branch 20289: 1
Branch 20290: 1
Branch 20291: 1
Branch 20292: 1
Branch 20293: 1
Branch 20294: 1
Branch 20295: 1
Branch 20296: 1
Branch 20297: 1
Branch 20298: 1
Branch 20299: 1
Branch 20300: 1
Branch 20301: 1
Branch 20302: 1
Branch 20303: 1
Branch 20304: 1
Branch 20305: 1
Branch 20306: 1
Branch 20307: 1
Branch 20308: 1
Branch 20309: 1
Branch 20310: 1
Branch 20311: 1
Branch 20312: 1
Branch 20313: 1
Branch 20314: 1
Branch 20315: 1
Branch 20316: 1
Branch 20317: 1
Branch 20318: 1
Branch 20319: 1
Branch 20320: 1
Branch 20321: 1
Branch 20322: 1
Branch 20323: 1
Branch 20324: 1
Branch 20325: 1
Branch 20326: 1
Branch 20327: 1
Branch 20328: 1
Branch 20329: 1
Branch 20330: 1
Branch 20331: 1
Branch 20332: 1
Branch 20333: 1
Branch 20334: 1
Branch 20335: 1
Branch 20336: 1
Branch 20337: 1
Branch 20338: 1
Branch 20339: 1
Branch 20340: 1
Branch 20341: 1
Branch 20342: 1
Branch 20343: 1
Branch 20344: 1
Branch 20345: 1
Branch 20346: 1
Branch 20347: 1
Branch 20348: 1
Branch 20349: 1
Branch 20350: 1
Branch 20351: 1
Branch 20352: 1
Branch 20353: 1
Branch 20354: 1
Branch 20355: 1
Branch 20356: 1
Branch 20357: 1
Branch 20358: 1
Branch 20359: 1
Branch 20360: 1
Branch 20361: 1
Branch 20362: 1
Branch 20363: 1
Branch 20364: 1
Branch 20365: 1
Branch 20366: 1
Branch 20367: 1
Branch 20368: 1
Branch 20369: 1
Branch 20370: 1
Branch 20371: 1
Branch 20372: 1
Branch 20373: 1
Branch 20374: 1
Branch 20375: 1
Branch 20376: 1
Branch 20377: 1
Branch 20378: 1
Branch 20379: 1
Branch 20380: 1
Branch 20381: 1
Branch 20382: 1
Branch 20383: 1
Branch 20384: 1
Branch 20385: 1
Branch 20386: 1
Branch 20387: 1
Branch 20388: 1
Branch 20389: 1
Branch 20390: 1
Branch 20391: 1
Branch 20392: 1
Branch 20393: 1
Branch 20394: 1
Branch 20395: 1
Branch 20396: 1
Branch 20397: 1
Branch 20398: 1
Branch 20399: 1
Branch 20400: 1
Branch 20401: 1
Branch 20402: 1
Branch 20403: 1
Branch 20404: 1
Branch 20405: 1
Branch 20406: 1
Branch 20407: 1
Branch 20408: 1
Branch 20409: 1
Branch 20410: 1
Branch 20411: 1
Branch 20412: 1
Branch 20413: 1
Branch 20414: 1
Branch 20415: 1
Branch 20416: 1
Branch 20417: 1
Branch 20418: 1
Branch 20419: 1
Branch 20420: 1
Branch 20421: 1
Branch 20422: 1
Branch 20423: 1
Branch 20424: 1
Branch 20425: 1
Branch 20426: 1
Branch 20427: 1
Branch 20428: 1
Branch 20429: 1
Branch 20430: 1
Branch 20431: 1
Branch 20432: 1
Branch 20433: 1
Branch 20434: 1
Branch 20435: 1
Branch 20436: 1
Branch 20437: 1
Branch 20438: 1
Branch 20439: 1
Branch 20440: 1
Branch 20441: 1
Branch 20442: 1
Branch 20443: 1
Branch 20444: 1
Branch 20445: 1
Branch 20446: 1
Branch 20447: 1
Branch 20448: 1
Branch 20449: 1
Branch 20450: 1
Branch 20451: 1
Branch 20452: 1
Branch 20453: 1
Branch 20454: 1
Branch 20455: 1
Branch 20456: 1
Branch 20457: 1
Branch 20458: 1
Branch 20459: 1
Branch 20460: 1
Branch 20461: 1
Branch 20462: 1
Branch 20463: 1
Branch 20464: 1
Branch 20465: 1
Branch 20466: 1
Branch 20467: 1
Branch 20468: 1
Branch 20469: 1
Branch 20470: 1
Branch 20471: 1
Branch 20472: 1
Branch 20473: 1
Branch 20474: 1
Branch 20475: 1
Branch 20476: 1
Branch 20477: 1
Branch 20478: 1
Branch 20479: 1
Branch 20480: 1
Branch 20481: 1
Branch 20482: 1
Branch 20483: 1
Branch 20484: 1
Branch 20485: 1
Branch 20486: 1
Branch 20487: 1
Branch 20488: 1
Branch 20489: 1
Branch 20490: 1
Branch 20491: 1
Branch 20492: 1
Branch 20493: 1
Branch 20494: 1
Branch 20495: 1
Branch 20496: 1
Branch 20497: 1
Branch 20498: 1
Branch 20499: 1
Branch 20500: 1
Branch 20501: 1
Branch 20502: 1
Branch 20503: 1
Branch 20504: 1
Branch 20505: 1
Branch 20506: 1
Branch 20507: 1
Branch 20508: 1
Branch 20509: 1
Branch 20510: 1
Branch 20511: 1
Branch 20512: 1
Branch 20513: 1
Branch 20514: 1
Branch 20515: 1
Branch 20516: 1
Branch 20517: 1
Branch 20518: 1
Branch 20519: 1
Branch 20520: 1
Branch 20521: 1
Branch 20522: 1
Branch 20523: 1
Branch 20524: 1
Branch 20525: 1
Branch 20526: 1
Branch 20527: 1
Branch 20528: 1
Branch 20529: 1
Branch 20530: 1
Branch 20531: 1
Branch 20532: 1
Branch 20533: 1
Branch 20534: 1
Branch 20535: 1
Branch 20536: 1
Branch 20537: 1
Branch 20538: 1
Branch 20539: 1
Branch 20540: 1
Branch 20541: 1
Branch 20542: 1
Branch 20543: 1
Branch 20544: 1
Branch 20545: 1
Branch 20546: 1
Branch 20547: 1
Branch 20548: 1
Branch 20549: 1
Branch 20550: 1
Branch 20551: 1
Branch 20552: 1
Branch 20553: 1
Branch 20554: 1
Branch 20555: 1
Branch 20556: 1
Branch 20557: 1
Branch 20558: 1
Branch 20559: 1
Branch 20560: 1
Branch 20561: 1
Branch 20562: 1
Branch 20563: 1
Branch 20564: 1
Branch 20565: 1
Branch 20566: 1
Branch 20567: 1
Branch 20568: 1
Branch 20569: 1
Branch 20570: 1
Branch 20571: 1
Branch 20572: 1
Branch 20573: 1
Branch 20574: 1
Branch 20575: 1
Branch 20576: 1
Branch 20577: 1
Branch 20578: 1
Branch 20579: 1
Branch 20580: 1
Branch 20581: 1
Branch 20582: 1
Branch 20583: 1
Branch 20584: 1
Branch 20585: 1
Branch 20586: 1
Branch 20587: 1
Branch 20588: 1
Branch 20589: 1
Branch 20590: 1
Branch 20591: 1
Branch 20592: 1
Branch 20593: 1
Branch 20594: 1
Branch 20595: 1
Branch 20596: 1
Branch 20597: 1
Branch 20598: 1
Branch 20599: 1
Branch 20600: 1
Branch 20601: 1
Branch 20602: 1
Branch 20603: 1
Branch 20604: 1
Branch 20605: 1
Branch 20606: 1
Branch 20607: 1
Branch 20608: 1
Branch 20609: 1
Branch 20610: 1
Branch 20611: 1
Branch 20612: 1
Branch 20613: 1
Branch 20614: 1
Branch 20615: 1
Branch 20616: 1
Branch 20617: 1
Branch 20618: 1
Branch 20619: 1
Branch 20620: 1
Branch 20621: 1
Branch 20622: 1
Branch 20623: 1
Branch 20624: 1
Branch 20625: 1
Branch 20626: 1
Branch 20627: 1
Branch 20628: 1
Branch 20629: 1
Branch 20630: 1
Branch 20631: 1
Branch 20632: 1
Branch 20633: 1
Branch 20634: 1
Branch 20635: 1
Branch 20636: 1
Branch 20637: 1
Branch 20638: 1
Branch 20639: 1
Branch 20640: 1
Branch 20641: 1
Branch 20642: 1
Branch 20643: 1
Branch 20644: 1
Branch 20645: 1
Branch 20646: 1
Branch 20647: 1
Branch 20648: 1
Branch 20649: 1
Branch 20650: 1
Branch 20651: 1
Branch 20652: 1
Branch 20653: 1
Branch 20654: 1
Branch 20655: 1
Branch 20656: 1
Branch 20657: 1
Branch 20658: 1
Branch 20659: 1
Branch 20660: 1
Branch 20661: 1
Branch 20662: 1
Branch 20663: 1
Branch 20664: 1
Branch 20665: 1
Branch 20666: 1
Branch 20667: 1
Branch 20668: 1
Branch 20669: 1
Branch 20670: 1
Branch 20671: 1
Branch 20672: 1
Branch 20673: 1
Branch 20674: 1
Branch 20675: 1
Branch 20676: 1
Branch 20677: 1
Branch 20678: 1
Branch 20679: 1
Branch 20680: 1
Branch 20681: 1
Branch 20682: 1
Branch 20683: 1
Branch 20684: 1
Branch 20685: 1
Branch 20686: 1
Branch 20687: 1
Branch 20688: 1
Branch 20689: 1
Branch 20690: 1
Branch 20691: 1
Branch 20692: 1
Branch 20693: 1
Branch 20694: 1
Branch 20695: 1
Branch 20696: 1
Branch 20697: 1
Branch 20698: 1
Branch 20699: 1
Branch 20700: 1
Branch 20701: 1
Branch 20702: 1
Branch 20703: 1
Branch 20704: 1
Branch 20705: 1
Branch 20706: 1
Branch 20707: 1
Branch 20708: 1
Branch 20709: 1
Branch 20710: 1
Branch 20711: 1
Branch 20712: 1
Branch 20713: 1
Branch 20714: 1
Branch 20715: 1
Branch 20716: 1
Branch 20717: 1
Branch 20718: 1
Branch 20719: 1
Branch 20720: 1
Branch 20721: 1
Branch 20722: 1
Branch 20723: 1
Branch 20724: 1
Branch 20725: 1
Branch 20726: 1
Branch 20727: 1
Branch 20728: 1
Branch 20729: 1
Branch 20730: 1
Branch 20731: 1
Branch 20732: 1
Branch 20733: 1
Branch 20734: 1
Branch 20735: 1
Branch 20736: 1
Branch 20737: 1
Branch 20738: 1
Branch 20739: 1
Branch 20740: 1
Branch 20741: 1
Branch 20742: 1
Branch 20743: 1
Branch 20744: 1
Branch 20745: 1
Branch 20746: 1
Branch 20747: 1
Branch 20748: 1
Branch 20749: 1
Branch 20750: 1
Branch 20751: 1
Branch 20752: 1
Branch 20753: 1
Branch 20754: 1
Branch 20755: 1
Branch 20756: 1
Branch 20757: 1
Branch 20758: 1
Branch 20759: 1
Branch 20760: 1
Branch 20761: 1
Branch 20762: 1
Branch 20763: 1
Branch 20764: 1
Branch 20765: 1
Branch 20766: 1
Branch 20767: 1
Branch 20768: 1
Branch 20769: 1
Branch 20770: 1
Branch 20771: 1
Branch 20772: 1
Branch 20773: 1
Branch 20774: 1
Branch 20775: 1
Branch 20776: 1
Branch 20777: 1
Branch 20778: 1
Branch 20779: 1
Branch 20780: 1
Branch 20781: 1
Branch 20782: 1
Branch 20783: 1
Branch 20784: 1
Branch 20785: 1
Branch 20786: 1
Branch 20787: 1
Branch 20788: 1
Branch 20789: 1
Branch 20790: 1
Branch 20791: 1
Branch 20792: 1
Branch 20793: 1
Branch 20794: 1
Branch 20795: 1
Branch 20796: 1
Branch 20797: 1
Branch 20798: 1
Branch 20799: 1
Branch 20800: 1
Branch 20801: 1
Branch 20802: 1
Branch 20803: 1
Branch 20804: 1
Branch 20805: 1
Branch 20806: 1
Branch 20807: 1
Branch 20808: 1
Branch 20809: 1
Branch 20810: 1
Branch 20811: 1
Branch 20812: 1
Branch 20813: 1
Branch 20814: 1
Branch 20815: 1
Branch 20816: 1
Branch 20817: 1
Branch 20818: 1
Branch 20819: 1
Branch 20820: 1
Branch 20821: 1
Branch 20822: 1
Branch 20823: 1
Branch 20824: 1
Branch 20825: 1
Branch 20826: 1
Branch 20827: 1
Branch 20828: 1
Branch 20829: 1
Branch 20830: 1
Branch 20831: 1
Branch 20832: 1
Branch 20833: 1
Branch 20834: 1
Branch 20835: 1
Branch 20836: 1
Branch 20837: 1
Branch 20838: 1
Branch 20839: 1
Branch 20840: 1
Branch 20841: 1
Branch 20842: 1
Branch 20843: 1
Branch 20844: 1
Branch 20845: 1
Branch 20846: 1
Branch 20847: 1
Branch 20848: 1
Branch 20849: 1
Branch 20850: 1
Branch 20851: 1
Branch 20852: 1
Branch 20853: 1
Branch 20854: 1
Branch 20855: 1
Branch 20856: 1
Branch 20857: 1
Branch 20858: 1
Branch 20859: 1
Branch 20860: 1
Branch 20861: 1
Branch 20862: 1
Branch 20863: 1
Branch 20864: 1
Branch 20865: 1
Branch 20866: 1
Branch 20867: 1
Branch 20868: 1
Branch 20869: 1
Branch 20870: 1
Branch 20871: 1
Branch 20872: 1
Branch 20873: 1
Branch 20874: 1
Branch 20875: 1
Branch 20876: 1
Branch 20877: 1
Branch 20878: 1
Branch 20879: 1
Branch 20880: 1
Branch 20881: 1
Branch 20882: 1
Branch 20883: 1
Branch 20884: 1
Branch 20885: 1
Branch 20886: 1
Branch 20887: 1
Branch 20888: 1
Branch 20889: 1
Branch 20890: 1
Branch 20891: 1
Branch 20892: 1
Branch 20893: 1
Branch 20894: 1
Branch 20895: 1
Branch 20896: 1
Branch 20897: 1
Branch 20898: 1
Branch 20899: 1
Branch 20900: 1
Branch 20901: 1
Branch 20902: 1
Branch 20903: 1
Branch 20904: 1
Branch 20905: 1
Branch 20906: 1
Branch 20907: 1
Branch 20908: 1
Branch 20909: 1
Branch 20910: 1
Branch 20911: 1
Branch 20912: 1
Branch 20913: 1
Branch 20914: 1
Branch 20915: 1
Branch 20916: 1
Branch 20917: 1
Branch 20918: 1
Branch 20919: 1
Branch 20920: 1
Branch 20921: 1
Branch 20922: 1
Branch 20923: 1
Branch 20924: 1
Branch 20925: 1
Branch 20926: 1
Branch 20927: 1
Branch 20928: 1
Branch 20929: 1
Branch 20930: 1
Branch 20931: 1
Branch 20932: 1
Branch 20933: 1
Branch 20934: 1
Branch 20935: 1
Branch 20936: 1
Branch 20937: 1
Branch 20938: 1
Branch 20939: 1
Branch 20940: 1
Branch 20941: 1
Branch 20942: 1
Branch 20943: 1
Branch 20944: 1
Branch 20945: 1
Branch 20946: 1
Branch 20947: 1
Branch 20948: 1
Branch 20949: 1
Branch 20950: 1
Branch 20951: 1
Branch 20952: 1
Branch 20953: 1
Branch 20954: 1
Branch 20955: 1
Branch 20956: 1
Branch 20957: 1
Branch 20958: 1
Branch 20959: 1
Branch 20960: 1
Branch 20961: 1
Branch 20962: 1
Branch 20963: 1
Branch 20964: 1
Branch 20965: 1
Branch 20966: 1
Branch 20967: 1
Branch 20968: 1
Branch 20969: 1
Branch 20970: 1
Branch 20971: 1
Branch 20972: 1
Branch 20973: 1
Branch 20974: 1
Branch 20975: 1
Branch 20976: 1
Branch 20977: 1
Branch 20978: 1
Branch 20979: 1
Branch 20980: 1
Branch 20981: 1
Branch 20982: 1
Branch 20983: 1
Branch 20984: 1
Branch 20985: 1
Branch 20986: 1
Branch 20987: 1
Branch 20988: 1
Branch 20989: 1
Branch 20990: 1
Branch 20991: 1
Branch 20992: 1
Branch 20993: 1
Branch 20994: 1
Branch 20995: 1
Branch 20996: 1
Branch 20997: 1
Branch 20998: 1
Branch 20999: 1
Branch 21000: 1
Branch 21001: 1
Branch 21002: 1
Branch 21003: 1
Branch 21004: 1
Branch 21005: 1
Branch 21006: 1
Branch 21007: 1
Branch 21008: 1
Branch 21009: 1
Branch 21010: 1
Branch 21011: 1
Branch 21012: 1
Branch 21013: 1
Branch 21014: 1
Branch 21015: 1
Branch 21016: 1
Branch 21017: 1
Branch 21018: 1
Branch 21019: 1
Branch 21020: 1
Branch 21021: 1
Branch 21022: 1
Branch 21023: 1
Branch 21024: 1
Branch 21025: 1
Branch 21026: 1
Branch 21027: 1
Branch 21028: 1
Branch 21029: 1
Branch 21030: 1
Branch 21031: 1
Branch 21032: 1
Branch 21033: 1
Branch 21034: 1
Branch 21035: 1
Branch 21036: 1
Branch 21037: 1
Branch 21038: 1
Branch 21039: 1
Branch 21040: 1
Branch 21041: 1
Branch 21042: 1
Branch 21043: 1
Branch 21044: 1
Branch 21045: 1
Branch 21046: 1
Branch 21047: 1
Branch 21048: 1
Branch 21049: 1
Branch 21050: 1
Branch 21051: 1
Branch 21052: 1
Branch 21053: 1
Branch 21054: 1
Branch 21055: 1
Branch 21056: 1
Branch 21057: 1
Branch 21058: 1
Branch 21059: 1
Branch 21060: 1
Branch 21061: 1
Branch 21062: 1
Branch 21063: 1
Branch 21064: 1
Branch 21065: 1
Branch 21066: 1
Branch 21067: 1
Branch 21068: 1
Branch 21069: 1
Branch 21070: 1
Branch 21071: 1
Branch 21072: 1
Branch 21073: 1
Branch 21074: 1
Branch 21075: 1
Branch 21076: 1
Branch 21077: 1
Branch 21078: 1
Branch 21079: 1
Branch 21080: 1
Branch 21081: 1
Branch 21082: 1
Branch 21083: 1
Branch 21084: 1
Branch 21085: 1
Branch 21086: 1
Branch 21087: 1
Branch 21088: 1
Branch 21089: 1
Branch 21090: 1
Branch 21091: 1
Branch 21092: 1
Branch 21093: 1
Branch 21094: 1
Branch 21095: 1
Branch 21096: 1
Branch 21097: 1
Branch 21098: 1
Branch 21099: 1
Branch 21100: 1
Branch 21101: 1
Branch 21102: 1
Branch 21103: 1
Branch 21104: 1
Branch 21105: 1
Branch 21106: 1
Branch 21107: 1
Branch 21108: 1
Branch 21109: 1
Branch 21110: 1
Branch 21111: 1
Branch 21112: 1
Branch 21113: 1
Branch 21114: 1
Branch 21115: 1
Branch 21116: 1
Branch 21117: 1
Branch 21118: 1
Branch 21119: 1
Branch 21120: 1
Branch 21121: 1
Branch 21122: 1
Branch 21123: 1
Branch 21124: 1
Branch 21125: 1
Branch 21126: 1
Branch 21127: 1
Branch 21128: 1
Branch 21129: 1
Branch 21130: 1
Branch 21131: 1
Branch 21132: 1
Branch 21133: 1
Branch 21134: 1
Branch 21135: 1
Branch 21136: 1
Branch 21137: 1
Branch 21138: 1
Branch 21139: 1
Branch 21140: 1
Branch 21141: 1
Branch 21142: 1
Branch 21143: 1
Branch 21144: 1
Branch 21145: 1
Branch 21146: 1
Branch 21147: 1
Branch 21148: 1
Branch 21149: 1
Branch 21150: 1
Branch 21151: 1
Branch 21152: 1
Branch 21153: 1
Branch 21154: 1
Branch 21155: 1
Branch 21156: 1
Branch 21157: 1
Branch 21158: 1
Branch 21159: 1
Branch 21160: 1
Branch 21161: 1
Branch 21162: 1
Branch 21163: 1
Branch 21164: 1
Branch 21165: 1
Branch 21166: 1
Branch 21167: 1
Branch 21168: 1
Branch 21169: 1
Branch 21170: 1
Branch 21171: 1
Branch 21172: 1
Branch 21173: 1
Branch 21174: 1
Branch 21175: 1
Branch 21176: 1
Branch 21177: 1
Branch 21178: 1
Branch 21179: 1
Branch 21180: 1
Branch 21181: 1
Branch 21182: 1
Branch 21183: 1
Branch 21184: 1
Branch 21185: 1
Branch 21186: 1
Branch 21187: 1
Branch 21188: 1
Branch 21189: 1
Branch 21190: 1
Branch 21191: 1
Branch 21192: 1
Branch 21193: 1
Branch 21194: 1
Branch 21195: 1
Branch 21196: 1
Branch 21197: 1
Branch 21198: 1
Branch 21199: 1
Branch 21200: 1
Branch 21201: 1
Branch 21202: 1
Branch 21203: 1
Branch 21204: 1
Branch 21205: 1
Branch 21206: 1
Branch 21207: 1
Branch 21208: 1
Branch 21209: 1
Branch 21210: 1
Branch 21211: 1
Branch 21212: 1
Branch 21213: 1
Branch 21214: 1
Branch 21215: 1
Branch 21216: 1
Branch 21217: 1
Branch 21218: 1
Branch 21219: 1
Branch 21220: 1
Branch 21221: 1
Branch 21222: 1
Branch 21223: 1
Branch 21224: 1
Branch 21225: 1
Branch 21226: 1
Branch 21227: 1
Branch 21228: 1
Branch 21229: 1
Branch 21230: 1
Branch 21231: 1
Branch 21232: 1
Branch 21233: 1
Branch 21234: 1
Branch 21235: 1
Branch 21236: 1
Branch 21237: 1
Branch 21238: 1
Branch 21239: 1
Branch 21240: 1
Branch 21241: 1
Branch 21242: 1
Branch 21243: 1
Branch 21244: 1
Branch 21245: 1
Branch 21246: 1
Branch 21247: 1
Branch 21248: 1
Branch 21249: 1
Branch 21250: 1
Branch 21251: 1
Branch 21252: 1
Branch 21253: 1
Branch 21254: 1
Branch 21255: 1
Branch 21256: 1
Branch 21257: 1
Branch 21258: 1
Branch 21259: 1
Branch 21260: 1
Branch 21261: 1
Branch 21262: 1
Branch 21263: 1
Branch 21264: 1
Branch 21265: 1
Branch 21266: 1
Branch 21267: 1
Branch 21268: 1
Branch 21269: 1
Branch 21270: 1
Branch 21271: 1
Branch 21272: 1
Branch 21273: 1
Branch 21274: 1
Branch 21275: 1
Branch 21276: 1
Branch 21277: 1
Branch 21278: 1
Branch 21279: 1
Branch 21280: 1
Branch 21281: 1
Branch 21282: 1
Branch 21283: 1
Branch 21284: 1
Branch 21285: 1
Branch 21286: 1
Branch 21287: 1
Branch 21288: 1
Branch 21289: 1
Branch 21290: 1
Branch 21291: 1
Branch 21292: 1
Branch 21293: 1
Branch 21294: 1
Branch 21295: 1
Branch 21296: 1
Branch 21297: 1
Branch 21298: 1
Branch 21299: 1
Branch 21300: 1
Branch 21301: 1
Branch 21302: 1
Branch 21303: 1
Branch 21304: 1
Branch 21305: 1
Branch 21306: 1
Branch 21307: 1
Branch 21308: 1
Branch 21309: 1
Branch 21310: 1
Branch 21311: 1
Branch 21312: 1
Branch 21313: 1
Branch 21314: 1
Branch 21315: 1
Branch 21316: 1
Branch 21317: 1
Branch 21318: 1
Branch 21319: 1
Branch 21320: 1
Branch 21321: 1
Branch 21322: 1
Branch 21323: 1
Branch 21324: 1
Branch 21325: 1
Branch 21326: 1
Branch 21327: 1
Branch 21328: 1
Branch 21329: 1
Branch 21330: 1
Branch 21331: 1
Branch 21332: 1
Branch 21333: 1
Branch 21334: 1
Branch 21335: 1
Branch 21336: 1
Branch 21337: 1
Branch 21338: 1
Branch 21339: 1
Branch 21340: 1
Branch 21341: 1
Branch 21342: 1
Branch 21343: 1
Branch 21344: 1
Branch 21345: 1
Branch 21346: 1
Branch 21347: 1
Branch 21348: 1
Branch 21349: 1
Branch 21350: 1
Branch 21351: 1
Branch 21352: 1
Branch 21353: 1
Branch 21354: 1
Branch 21355: 1
Branch 21356: 1
Branch 21357: 1
Branch 21358: 1
Branch 21359: 1
Branch 21360: 1
Branch 21361: 1
Branch 21362: 1
Branch 21363: 1
Branch 21364: 1
Branch 21365: 1
Branch 21366: 1
Branch 21367: 1
Branch 21368: 1
Branch 21369: 1
Branch 21370: 1
Branch 21371: 1
Branch 21372: 1
Branch 21373: 1
Branch 21374: 1
Branch 21375: 1
Branch 21376: 1
Branch 21377: 1
Branch 21378: 1
Branch 21379: 1
Branch 21380: 1
Branch 21381: 1
Branch 21382: 1
Branch 21383: 1
Branch 21384: 1
Branch 21385: 1
Branch 21386: 1
Branch 21387: 1
Branch 21388: 1
Branch 21389: 1
Branch 21390: 1
Branch 21391: 1
Branch 21392: 1
Branch 21393: 1
Branch 21394: 1
Branch 21395: 1
Branch 21396: 1
Branch 21397: 1
Branch 21398: 1
Branch 21399: 1
Branch 21400: 1
Branch 21401: 1
Branch 21402: 1
Branch 21403: 1
Branch 21404: 1
Branch 21405: 1
Branch 21406: 1
Branch 21407: 1
Branch 21408: 1
Branch 21409: 1
Branch 21410: 1
Branch 21411: 1
Branch 21412: 1
Branch 21413: 1
Branch 21414: 1
Branch 21415: 1
Branch 21416: 1
Branch 21417: 1
Branch 21418: 1
Branch 21419: 1
Branch 21420: 1
Branch 21421: 1
Branch 21422: 1
Branch 21423: 1
Branch 21424: 1
Branch 21425: 1
Branch 21426: 1
Branch 21427: 1
Branch 21428: 1
Branch 21429: 1
Branch 21430: 1
Branch 21431: 1
Branch 21432: 1
Branch 21433: 1
Branch 21434: 1
Branch 21435: 1
Branch 21436: 1
Branch 21437: 1
Branch 21438: 1
Branch 21439: 1
Branch 21440: 1
Branch 21441: 1
Branch 21442: 1
Branch 21443: 1
Branch 21444: 1
Branch 21445: 1
Branch 21446: 1
Branch 21447: 1
Branch 21448: 1
Branch 21449: 1
Branch 21450: 1
Branch 21451: 1
Branch 21452: 1
Branch 21453: 1
Branch 21454: 1
Branch 21455: 1
Branch 21456: 1
Branch 21457: 1
Branch 21458: 1
Branch 21459: 1
Branch 21460: 1
Branch 21461: 1
Branch 21462: 1
Branch 21463: 1
Branch 21464: 1
Branch 21465: 1
Branch 21466: 1
Branch 21467: 1
Branch 21468: 1
Branch 21469: 1
Branch 21470: 1
Branch 21471: 1
Branch 21472: 1
Branch 21473: 1
Branch 21474: 1
Branch 21475: 1
Branch 21476: 1
Branch 21477: 1
Branch 21478: 1
Branch 21479: 1
Branch 21480: 1
Branch 21481: 1
Branch 21482: 1
Branch 21483: 1
Branch 21484: 1
Branch 21485: 1
Branch 21486: 1
Branch 21487: 1
Branch 21488: 1
Branch 21489: 1
Branch 21490: 1
Branch 21491: 1
Branch 21492: 1
Branch 21493: 1
Branch 21494: 1
Branch 21495: 1
Branch 21496: 1
Branch 21497: 1
Branch 21498: 1
Branch 21499: 1
Branch 21500: 1
Branch 21501: 1
Branch 21502: 1
Branch 21503: 1
Branch 21504: 1
Branch 21505: 1
Branch 21506: 1
Branch 21507: 1
Branch 21508: 1
Branch 21509: 1
Branch 21510: 1
Branch 21511: 1
Branch 21512: 1
Branch 21513: 1
Branch 21514: 1
Branch 21515: 1
Branch 21516: 1
Branch 21517: 1
Branch 21518: 1
Branch 21519: 1
Branch 21520: 1
Branch 21521: 1
Branch 21522: 1
Branch 21523: 1
Branch 21524: 1
Branch 21525: 1
Branch 21526: 1
Branch 21527: 1
Branch 21528: 1
Branch 21529: 1
Branch 21530: 1
Branch 21531: 1
Branch 21532: 1
Branch 21533: 1
Branch 21534: 1
Branch 21535: 1
Branch 21536: 1
Branch 21537: 1
Branch 21538: 1
Branch 21539: 1
Branch 21540: 1
Branch 21541: 1
Branch 21542: 1
Branch 21543: 1
Branch 21544: 1
Branch 21545: 1
Branch 21546: 1
Branch 21547: 1
Branch 21548: 1
Branch 21549: 1
Branch 21550: 1
Branch 21551: 1
Branch 21552: 1
Branch 21553: 1
Branch 21554: 1
Branch 21555: 1
Branch 21556: 1
Branch 21557: 1
Branch 21558: 1
Branch 21559: 1
Branch 21560: 1
Branch 21561: 1
Branch 21562: 1
Branch 21563: 1
Branch 21564: 1
Branch 21565: 1
Branch 21566: 1
Branch 21567: 1
Branch 21568: 1
Branch 21569: 1
Branch 21570: 1
Branch 21571: 1
Branch 21572: 1
Branch 21573: 1
Branch 21574: 1
Branch 21575: 1
Branch 21576: 1
Branch 21577: 1
Branch 21578: 1
Branch 21579: 1
Branch 21580: 1
Branch 21581: 1
Branch 21582: 1
Branch 21583: 1
Branch 21584: 1
Branch 21585: 1
Branch 21586: 1
Branch 21587: 1
Branch 21588: 1
Branch 21589: 1
Branch 21590: 1
Branch 21591: 1
Branch 21592: 1
Branch 21593: 1
Branch 21594: 1
Branch 21595: 1
Branch 21596: 1
Branch 21597: 1
Branch 21598: 1
Branch 21599: 1
Branch 21600: 1
Branch 21601: 1
Branch 21602: 1
Branch 21603: 1
Branch 21604: 1
Branch 21605: 1
Branch 21606: 1
Branch 21607: 1
Branch 21608: 1
Branch 21609: 1
Branch 21610: 1
Branch 21611: 1
Branch 21612: 1
Branch 21613: 1
Branch 21614: 1
Branch 21615: 1
Branch 21616: 1
Branch 21617: 1
Branch 21618: 1
Branch 21619: 1
Branch 21620: 1
Branch 21621: 1
Branch 21622: 1
Branch 21623: 1
Branch 21624: 1
Branch 21625: 1
Branch 21626: 1
Branch 21627: 1
Branch 21628: 1
Branch 21629: 1
Branch 21630: 1
Branch 21631: 1
Branch 21632: 1
Branch 21633: 1
Branch 21634: 1
Branch 21635: 1
Branch 21636: 1
Branch 21637: 1
Branch 21638: 1
Branch 21639: 1
Branch 21640: 1
Branch 21641: 1
Branch 21642: 1
Branch 21643: 1
Branch 21644: 1
Branch 21645: 1
Branch 21646: 1
Branch 21647: 1
Branch 21648: 1
Branch 21649: 1
Branch 21650: 1
Branch 21651: 1
Branch 21652: 1
Branch 21653: 1
Branch 21654: 1
Branch 21655: 1
Branch 21656: 1
Branch 21657: 1
Branch 21658: 1
Branch 21659: 1
Branch 21660: 1
Branch 21661: 1
Branch 21662: 1
Branch 21663: 1
Branch 21664: 1
Branch 21665: 1
Branch 21666: 1
Branch 21667: 1
Branch 21668: 1
Branch 21669: 1
Branch 21670: 1
Branch 21671: 1
Branch 21672: 1
Branch 21673: 1
Branch 21674: 1
Branch 21675: 1
Branch 21676: 1
Branch 21677: 1
Branch 21678: 1
Branch 21679: 1
Branch 21680: 1
Branch 21681: 1
Branch 21682: 1
Branch 21683: 1
Branch 21684: 1
Branch 21685: 1
Branch 21686: 1
Branch 21687: 1
Branch 21688: 1
Branch 21689: 1
Branch 21690: 1
Branch 21691: 1
Branch 21692: 1
Branch 21693: 1
Branch 21694: 1
Branch 21695: 1
Branch 21696: 1
Branch 21697: 1
Branch 21698: 1
Branch 21699: 1
Branch 21700: 1
Branch 21701: 1
Branch 21702: 1
Branch 21703: 1
Branch 21704: 1
Branch 21705: 1
Branch 21706: 1
Branch 21707: 1
Branch 21708: 1
Branch 21709: 1
Branch 21710: 1
Branch 21711: 1
Branch 21712: 1
Branch 21713: 1
Branch 21714: 1
Branch 21715: 1
Branch 21716: 1
Branch 21717: 1
Branch 21718: 1
Branch 21719: 1
Branch 21720: 1
Branch 21721: 1
Branch 21722: 1
Branch 21723: 1
Branch 21724: 1
Branch 21725: 1
Branch 21726: 1
Branch 21727: 1
Branch 21728: 1
Branch 21729: 1
Branch 21730: 1
Branch 21731: 1
Branch 21732: 1
Branch 21733: 1
Branch 21734: 1
Branch 21735: 1
Branch 21736: 1
Branch 21737: 1
Branch 21738: 1
Branch 21739: 1
Branch 21740: 1
Branch 21741: 1
Branch 21742: 1
Branch 21743: 1
Branch 21744: 1
Branch 21745: 1
Branch 21746: 1
Branch 21747: 1
Branch 21748: 1
Branch 21749: 1
Branch 21750: 1
Branch 21751: 1
Branch 21752: 1
Branch 21753: 1
Branch 21754: 1
Branch 21755: 1
Branch 21756: 1
Branch 21757: 1
Branch 21758: 1
Branch 21759: 1
Branch 21760: 1
Branch 21761: 1
Branch 21762: 1
Branch 21763: 1
Branch 21764: 1
Branch 21765: 1
Branch 21766: 1
Branch 21767: 1
Branch 21768: 1
Branch 21769: 1
Branch 21770: 1
Branch 21771: 1
Branch 21772: 1
Branch 21773: 1
Branch 21774: 1
Branch 21775: 1
Branch 21776: 1
Branch 21777: 1
Branch 21778: 1
Branch 21779: 1
Branch 21780: 1
Branch 21781: 1
Branch 21782: 1
Branch 21783: 1
Branch 21784: 1
Branch 21785: 1
Branch 21786: 1
Branch 21787: 1
Branch 21788: 1
Branch 21789: 1
Branch 21790: 1
Branch 21791: 1
Branch 21792: 1
Branch 21793: 1
Branch 21794: 1
Branch 21795: 1
Branch 21796: 1
Branch 21797: 1
Branch 21798: 1
Branch 21799: 1
Branch 21800: 1
Branch 21801: 1
Branch 21802: 1
Branch 21803: 1
Branch 21804: 1
Branch 21805: 1
Branch 21806: 1
Branch 21807: 1
Branch 21808: 1
Branch 21809: 1
Branch 21810: 1
Branch 21811: 1
Branch 21812: 1
Branch 21813: 1
Branch 21814: 1
Branch 21815: 1
Branch 21816: 1
Branch 21817: 1
Branch 21818: 1
Branch 21819: 1
Branch 21820: 1
Branch 21821: 1
Branch 21822: 1
Branch 21823: 1
Branch 21824: 1
Branch 21825: 1
Branch 21826: 1
Branch 21827: 1
Branch 21828: 1
Branch 21829: 1
Branch 21830: 1
Branch 21831: 1
Branch 21832: 1
Branch 21833: 1
Branch 21834: 1
Branch 21835: 1
Branch 21836: 1
Branch 21837: 1
Branch 21838: 1
Branch 21839: 1
Branch 21840: 1
Branch 21841: 1
Branch 21842: 1
Branch 21843: 1
Branch 21844: 1
Branch 21845: 1
Branch 21846: 1
Branch 21847: 1
Branch 21848: 1
Branch 21849: 1
Branch 21850: 1
Branch 21851: 1
Branch 21852: 1
Branch 21853: 1
Branch 21854: 1
Branch 21855: 1
Branch 21856: 1
Branch 21857: 1
Branch 21858: 1
Branch 21859: 1
Branch 21860: 1
Branch 21861: 1
Branch 21862: 1
Branch 21863: 1
Branch 21864: 1
Branch 21865: 1
Branch 21866: 1
Branch 21867: 1
Branch 21868: 1
Branch 21869: 1
Branch 21870: 1
Branch 21871: 1
Branch 21872: 1
Branch 21873: 1
Branch 21874: 1
Branch 21875: 1
Branch 21876: 1
Branch 21877: 1
Branch 21878: 1
Branch 21879: 1
Branch 21880: 1
Branch 21881: 1
Branch 21882: 1
Branch 21883: 1
Branch 21884: 1
Branch 21885: 1
Branch 21886: 1
Branch 21887: 1
Branch 21888: 1
Branch 21889: 1
Branch 21890: 1
Branch 21891: 1
Branch 21892: 1
Branch 21893: 1
Branch 21894: 1
Branch 21895: 1
Branch 21896: 1
Branch 21897: 1
Branch 21898: 1
Branch 21899: 1
Branch 21900: 1
Branch 21901: 1
Branch 21902: 1
Branch 21903: 1
Branch 21904: 1
Branch 21905: 1
Branch 21906: 1
Branch 21907: 1
Branch 21908: 1
Branch 21909: 1
Branch 21910: 1
Branch 21911: 1
Branch 21912: 1
Branch 21913: 1
Branch 21914: 1
Branch 21915: 1
Branch 21916: 1
Branch 21917: 1
Branch 21918: 1
Branch 21919: 1
Branch 21920: 1
Branch 21921: 1
Branch 21922: 1
Branch 21923: 1
Branch 21924: 1
Branch 21925: 1
Branch 21926: 1
Branch 21927: 1
Branch 21928: 1
Branch 21929: 1
Branch 21930: 1
Branch 21931: 1
Branch 21932: 1
Branch 21933: 1
Branch 21934: 1
Branch 21935: 1
Branch 21936: 1
Branch 21937: 1
Branch 21938: 1
Branch 21939: 1
Branch 21940: 1
Branch 21941: 1
Branch 21942: 1
Branch 21943: 1
Branch 21944: 1
Branch 21945: 1
Branch 21946: 1
Branch 21947: 1
Branch 21948: 1
Branch 21949: 1
Branch 21950: 1
Branch 21951: 1
Branch 21952: 1
Branch 21953: 1
Branch 21954: 1
Branch 21955: 1
Branch 21956: 1
Branch 21957: 1
Branch 21958: 1
Branch 21959: 1
Branch 21960: 1
Branch 21961: 1
Branch 21962: 1
Branch 21963: 1
Branch 21964: 1
Branch 21965: 1
Branch 21966: 1
Branch 21967: 1
Branch 21968: 1
Branch 21969: 1
Branch 21970: 1
Branch 21971: 1
Branch 21972: 1
Branch 21973: 1
Branch 21974: 1
Branch 21975: 1
Branch 21976: 1
Branch 21977: 1
Branch 21978: 1
Branch 21979: 1
Branch 21980: 1
Branch 21981: 1
Branch 21982: 1
Branch 21983: 1
Branch 21984: 1
Branch 21985: 1
Branch 21986: 1
Branch 21987: 1
Branch 21988: 1
Branch 21989: 1
Branch 21990: 1
Branch 21991: 1
Branch 21992: 1
Branch 21993: 1
Branch 21994: 1
Branch 21995: 1
Branch 21996: 1
Branch 21997: 1
Branch 21998: 1
Branch 21999: 1
Branch 22000: 1
Branch 22001: 1
Branch 22002: 1
Branch 22003: 1
Branch 22004: 1
Branch 22005: 1
Branch 22006: 1
Branch 22007: 1
Branch 22008: 1
Branch 22009: 1
Branch 22010: 1
Branch 22011: 1
Branch 22012: 1
Branch 22013: 1
Branch 22014: 1
Branch 22015: 1
Branch 22016: 1
Branch 22017: 1
Branch 22018: 1
Branch 22019: 1
Branch 22020: 1
Branch 22021: 1
Branch 22022: 1
Branch 22023: 1
Branch 22024: 1
Branch 22025: 1
Branch 22026: 1
Branch 22027: 1
Branch 22028: 1
Branch 22029: 1
Branch 22030: 1
Branch 22031: 1
Branch 22032: 1
Branch 22033: 1
Branch 22034: 1
Branch 22035: 1
Branch 22036: 1
Branch 22037: 1
Branch 22038: 1
Branch 22039: 1
Branch 22040: 1
Branch 22041: 1
Branch 22042: 1
Branch 22043: 1
Branch 22044: 1
Branch 22045: 1
Branch 22046: 1
Branch 22047: 1
Branch 22048: 1
Branch 22049: 1
Branch 22050: 1
Branch 22051: 1
Branch 22052: 1
Branch 22053: 1
Branch 22054: 1
Branch 22055: 1
Branch 22056: 1
Branch 22057: 1
Branch 22058: 1
Branch 22059: 1
Branch 22060: 1
Branch 22061: 1
Branch 22062: 1
Branch 22063: 1
Branch 22064: 1
Branch 22065: 1
Branch 22066: 1
Branch 22067: 1
Branch 22068: 1
Branch 22069: 1
Branch 22070: 1
Branch 22071: 1
Branch 22072: 1
Branch 22073: 1
Branch 22074: 1
Branch 22075: 1
Branch 22076: 1
Branch 22077: 1
Branch 22078: 1
Branch 22079: 1
Branch 22080: 1
Branch 22081: 1
Branch 22082: 1
Branch 22083: 1
Branch 22084: 1
Branch 22085: 1
Branch 22086: 1
Branch 22087: 1
Branch 22088: 1
Branch 22089: 1
Branch 22090: 1
Branch 22091: 1
Branch 22092: 1
Branch 22093: 1
Branch 22094: 1
Branch 22095: 1
Branch 22096: 1
Branch 22097: 1
Branch 22098: 1
Branch 22099: 1
Branch 22100: 1
Branch 22101: 1
Branch 22102: 1
Branch 22103: 1
Branch 22104: 1
Branch 22105: 1
Branch 22106: 1
Branch 22107: 1
Branch 22108: 1
Branch 22109: 1
Branch 22110: 1
Branch 22111: 1
Branch 22112: 1
Branch 22113: 1
Branch 22114: 1
Branch 22115: 1
Branch 22116: 1
Branch 22117: 1
Branch 22118: 1
Branch 22119: 1
Branch 22120: 1
Branch 22121: 1
Branch 22122: 1
Branch 22123: 1
Branch 22124: 1
Branch 22125: 1
Branch 22126: 1
Branch 22127: 1
Branch 22128: 1
Branch 22129: 1
Branch 22130: 1
Branch 22131: 1
Branch 22132: 1
Branch 22133: 1
Branch 22134: 1
Branch 22135: 1
Branch 22136: 1
Branch 22137: 1
Branch 22138: 1
Branch 22139: 1
Branch 22140: 1
Branch 22141: 1
Branch 22142: 1
Branch 22143: 1
Branch 22144: 1
Branch 22145: 1
Branch 22146: 1
Branch 22147: 1
Branch 22148: 1
Branch 22149: 1
Branch 22150: 1
Branch 22151: 1
Branch 22152: 1
Branch 22153: 1
Branch 22154: 1
Branch 22155: 1
Branch 22156: 1
Branch 22157: 1
Branch 22158: 1
Branch 22159: 1
Branch 22160: 1
Branch 22161: 1
Branch 22162: 1
Branch 22163: 1
Branch 22164: 1
Branch 22165: 1
Branch 22166: 1
Branch 22167: 1
Branch 22168: 1
Branch 22169: 1
Branch 22170: 1
Branch 22171: 1
Branch 22172: 1
Branch 22173: 1
Branch 22174: 1
Branch 22175: 1
Branch 22176: 1
Branch 22177: 1
Branch 22178: 1
Branch 22179: 1
Branch 22180: 1
Branch 22181: 1
Branch 22182: 1
Branch 22183: 1
Branch 22184: 1
Branch 22185: 1
Branch 22186: 1
Branch 22187: 1
Branch 22188: 1
Branch 22189: 1
Branch 22190: 1
Branch 22191: 1
Branch 22192: 1
Branch 22193: 1
Branch 22194: 1
Branch 22195: 1
Branch 22196: 1
Branch 22197: 1
Branch 22198: 1
Branch 22199: 1
Branch 22200: 1
Branch 22201: 1
Branch 22202: 1
Branch 22203: 1
Branch 22204: 1
Branch 22205: 1
Branch 22206: 1
Branch 22207: 1
Branch 22208: 1
Branch 22209: 1
Branch 22210: 1
Branch 22211: 1
Branch 22212: 1
Branch 22213: 1
Branch 22214: 1
Branch 22215: 1
Branch 22216: 1
Branch 22217: 1
Branch 22218: 1
Branch 22219: 1
Branch 22220: 1
Branch 22221: 1
Branch 22222: 1
Branch 22223: 1
Branch 22224: 1
Branch 22225: 1
Branch 22226: 1
Branch 22227: 1
Branch 22228: 1
Branch 22229: 1
Branch 22230: 1
Branch 22231: 1
Branch 22232: 1
Branch 22233: 1
Branch 22234: 1
Branch 22235: 1
Branch 22236: 1
Branch 22237: 1
Branch 22238: 1
Branch 22239: 1
Branch 22240: 1
Branch 22241: 1
Branch 22242: 1
Branch 22243: 1
Branch 22244: 1
Branch 22245: 1
Branch 22246: 1
Branch 22247: 1
Branch 22248: 1
Branch 22249: 1
Branch 22250: 1
Branch 22251: 1
Branch 22252: 1
Branch 22253: 1
Branch 22254: 1
Branch 22255: 1
Branch 22256: 1
Branch 22257: 1
Branch 22258: 1
Branch 22259: 1
Branch 22260: 1
Branch 22261: 1
Branch 22262: 1
Branch 22263: 1
Branch 22264: 1
Branch 22265: 1
Branch 22266: 1
Branch 22267: 1
Branch 22268: 1
Branch 22269: 1
Branch 22270: 1
Branch 22271: 1
Branch 22272: 1
Branch 22273: 1
Branch 22274: 1
Branch 22275: 1
Branch 22276: 1
Branch 22277: 1
Branch 22278: 1
Branch 22279: 1
Branch 22280: 1
Branch 22281: 1
Branch 22282: 1
Branch 22283: 1
Branch 22284: 1
Branch 22285: 1
Branch 22286: 1
Branch 22287: 1
Branch 22288: 1
Branch 22289: 1
Branch 22290: 1
Branch 22291: 1
Branch 22292: 1
Branch 22293: 1
Branch 22294: 1
Branch 22295: 1
Branch 22296: 1
Branch 22297: 1
Branch 22298: 1
Branch 22299: 1
Branch 22300: 1
Branch 22301: 1
Branch 22302: 1
Branch 22303: 1
Branch 22304: 1
Branch 22305: 1
Branch 22306: 1
Branch 22307: 1
Branch 22308: 1
Branch 22309: 1
Branch 22310: 1
Branch 22311: 1
Branch 22312: 1
Branch 22313: 1
Branch 22314: 1
Branch 22315: 1
Branch 22316: 1
Branch 22317: 1
Branch 22318: 1
Branch 22319: 1
Branch 22320: 1
Branch 22321: 1
Branch 22322: 1
Branch 22323: 1
Branch 22324: 1
Branch 22325: 1
Branch 22326: 1
Branch 22327: 1
Branch 22328: 1
Branch 22329: 1
Branch 22330: 1
Branch 22331: 1
Branch 22332: 1
Branch 22333: 1
Branch 22334: 1
Branch 22335: 1
Branch 22336: 1
Branch 22337: 1
Branch 22338: 1
Branch 22339: 1
Branch 22340: 1
Branch 22341: 1
Branch 22342: 1
Branch 22343: 1
Branch 22344: 1
Branch 22345: 1
Branch 22346: 1
Branch 22347: 1
Branch 22348: 1
Branch 22349: 1
Branch 22350: 1
Branch 22351: 1
Branch 22352: 1
Branch 22353: 1
Branch 22354: 1
Branch 22355: 1
Branch 22356: 1
Branch 22357: 1
Branch 22358: 1
Branch 22359: 1
Branch 22360: 1
Branch 22361: 1
Branch 22362: 1
Branch 22363: 1
Branch 22364: 1
Branch 22365: 1
Branch 22366: 1
Branch 22367: 1
Branch 22368: 1
Branch 22369: 1
Branch 22370: 1
Branch 22371: 1
Branch 22372: 1
Branch 22373: 1
Branch 22374: 1
Branch 22375: 1
Branch 22376: 1
Branch 22377: 1
Branch 22378: 1
Branch 22379: 1
Branch 22380: 1
Branch 22381: 1
Branch 22382: 1
Branch 22383: 1
Branch 22384: 1
Branch 22385: 1
Branch 22386: 1
Branch 22387: 1
Branch 22388: 1
Branch 22389: 1
Branch 22390: 1
Branch 22391: 1
Branch 22392: 1
Branch 22393: 1
Branch 22394: 1
Branch 22395: 1
Branch 22396: 1
Branch 22397: 1
Branch 22398: 1
Branch 22399: 1
Branch 22400: 1
Branch 22401: 1
Branch 22402: 1
Branch 22403: 1
Branch 22404: 1
Branch 22405: 1
Branch 22406: 1
Branch 22407: 1
Branch 22408: 1
Branch 22409: 1
Branch 22410: 1
Branch 22411: 1
Branch 22412: 1
Branch 22413: 1
Branch 22414: 1
Branch 22415: 1
Branch 22416: 1
Branch 22417: 1
Branch 22418: 1
Branch 22419: 1
Branch 22420: 1
Branch 22421: 1
Branch 22422: 1
Branch 22423: 1
Branch 22424: 1
Branch 22425: 1
Branch 22426: 1
Branch 22427: 1
Branch 22428: 1
Branch 22429: 1
Branch 22430: 1
Branch 22431: 1
Branch 22432: 1
Branch 22433: 1
Branch 22434: 1
Branch 22435: 1
Branch 22436: 1
Branch 22437: 1
Branch 22438: 1
Branch 22439: 1
Branch 22440: 1
Branch 22441: 1
Branch 22442: 1
Branch 22443: 1
Branch 22444: 1
Branch 22445: 1
Branch 22446: 1
Branch 22447: 1
Branch 22448: 1
Branch 22449: 1
Branch 22450: 1
Branch 22451: 1
Branch 22452: 1
Branch 22453: 1
Branch 22454: 1
Branch 22455: 1
Branch 22456: 1
Branch 22457: 1
Branch 22458: 1
Branch 22459: 1
Branch 22460: 1
Branch 22461: 1
Branch 22462: 1
Branch 22463: 1
Branch 22464: 1
Branch 22465: 1
Branch 22466: 1
Branch 22467: 1
Branch 22468: 1
Branch 22469: 1
Branch 22470: 1
Branch 22471: 1
Branch 22472: 1
Branch 22473: 1
Branch 22474: 1
Branch 22475: 1
Branch 22476: 1
Branch 22477: 1
Branch 22478: 1
Branch 22479: 1
Branch 22480: 1
Branch 22481: 1
Branch 22482: 1
Branch 22483: 1
Branch 22484: 1
Branch 22485: 1
Branch 22486: 1
Branch 22487: 1
Branch 22488: 1
Branch 22489: 1
Branch 22490: 1
Branch 22491: 1
Branch 22492: 1
Branch 22493: 1
Branch 22494: 1
Branch 22495: 1
Branch 22496: 1
Branch 22497: 1
Branch 22498: 1
Branch 22499: 1
Branch 22500: 1
Branch 22501: 1
Branch 22502: 1
Branch 22503: 1
Branch 22504: 1
Branch 22505: 1
Branch 22506: 1
Branch 22507: 1
Branch 22508: 1
Branch 22509: 1
Branch 22510: 1
Branch 22511: 1
Branch 22512: 1
Branch 22513: 1
Branch 22514: 1
Branch 22515: 1
Branch 22516: 1
Branch 22517: 1
Branch 22518: 1
Branch 22519: 1
Branch 22520: 1
Branch 22521: 1
Branch 22522: 1
Branch 22523: 1
Branch 22524: 1
Branch 22525: 1
Branch 22526: 1
Branch 22527: 1
Branch 22528: 1
Branch 22529: 1
Branch 22530: 1
Branch 22531: 1
Branch 22532: 1
Branch 22533: 1
Branch 22534: 1
Branch 22535: 1
Branch 22536: 1
Branch 22537: 1
Branch 22538: 1
Branch 22539: 1
Branch 22540: 1
Branch 22541: 1
Branch 22542: 1
Branch 22543: 1
Branch 22544: 1
Branch 22545: 1
Branch 22546: 1
Branch 22547: 1
Branch 22548: 1
Branch 22549: 1
Branch 22550: 1
Branch 22551: 1
Branch 22552: 1
Branch 22553: 1
Branch 22554: 1
Branch 22555: 1
Branch 22556: 1
Branch 22557: 1
Branch 22558: 1
Branch 22559: 1
Branch 22560: 1
Branch 22561: 1
Branch 22562: 1
Branch 22563: 1
Branch 22564: 1
Branch 22565: 1
Branch 22566: 1
Branch 22567: 1
Branch 22568: 1
Branch 22569: 1
Branch 22570: 1
Branch 22571: 1
Branch 22572: 1
Branch 22573: 1
Branch 22574: 1
Branch 22575: 1
Branch 22576: 1
Branch 22577: 1
Branch 22578: 1
Branch 22579: 1
Branch 22580: 1
Branch 22581: 1
Branch 22582: 1
Branch 22583: 1
Branch 22584: 1
Branch 22585: 1
Branch 22586: 1
Branch 22587: 1
Branch 22588: 1
Branch 22589: 1
Branch 22590: 1
Branch 22591: 1
Branch 22592: 1
Branch 22593: 1
Branch 22594: 1
Branch 22595: 1
Branch 22596: 1
Branch 22597: 1
Branch 22598: 1
Branch 22599: 1
Branch 22600: 1
Branch 22601: 1
Branch 22602: 1
Branch 22603: 1
Branch 22604: 1
Branch 22605: 1
Branch 22606: 1
Branch 22607: 1
Branch 22608: 1
Branch 22609: 1
Branch 22610: 1
Branch 22611: 1
Branch 22612: 1
Branch 22613: 1
Branch 22614: 1
Branch 22615: 1
Branch 22616: 1
Branch 22617: 1
Branch 22618: 1
Branch 22619: 1
Branch 22620: 1
Branch 22621: 1
Branch 22622: 1
Branch 22623: 1
Branch 22624: 1
Branch 22625: 1
Branch 22626: 1
Branch 22627: 1
Branch 22628: 1
Branch 22629: 1
Branch 22630: 1
Branch 22631: 1
Branch 22632: 1
Branch 22633: 1
Branch 22634: 1
Branch 22635: 1
Branch 22636: 1
Branch 22637: 1
Branch 22638: 1
Branch 22639: 1
Branch 22640: 1
Branch 22641: 1
Branch 22642: 1
Branch 22643: 1
Branch 22644: 1
Branch 22645: 1
Branch 22646: 1
Branch 22647: 1
Branch 22648: 1
Branch 22649: 1
Branch 22650: 1
Branch 22651: 1
Branch 22652: 1
Branch 22653: 1
Branch 22654: 1
Branch 22655: 1
Branch 22656: 1
Branch 22657: 1
Branch 22658: 1
Branch 22659: 1
Branch 22660: 1
Branch 22661: 1
Branch 22662: 1
Branch 22663: 1
Branch 22664: 1
Branch 22665: 1
Branch 22666: 1
Branch 22667: 1
Branch 22668: 1
Branch 22669: 1
Branch 22670: 1
Branch 22671: 1
Branch 22672: 1
Branch 22673: 1
Branch 22674: 1
Branch 22675: 1
Branch 22676: 1
Branch 22677: 1
Branch 22678: 1
Branch 22679: 1
Branch 22680: 1
Branch 22681: 1
Branch 22682: 1
Branch 22683: 1
Branch 22684: 1
Branch 22685: 1
Branch 22686: 1
Branch 22687: 1
Branch 22688: 1
Branch 22689: 1
Branch 22690: 1
Branch 22691: 1
Branch 22692: 1
Branch 22693: 1
Branch 22694: 1
Branch 22695: 1
Branch 22696: 1
Branch 22697: 1
Branch 22698: 1
Branch 22699: 1
Branch 22700: 1
Branch 22701: 1
Branch 22702: 1
Branch 22703: 1
Branch 22704: 1
Branch 22705: 1
Branch 22706: 1
Branch 22707: 1
Branch 22708: 1
Branch 22709: 1
Branch 22710: 1
Branch 22711: 1
Branch 22712: 1
Branch 22713: 1
Branch 22714: 1
Branch 22715: 1
Branch 22716: 1
Branch 22717: 1
Branch 22718: 1
Branch 22719: 1
Branch 22720: 1
Branch 22721: 1
Branch 22722: 1
Branch 22723: 1
Branch 22724: 1
Branch 22725: 1
Branch 22726: 1
Branch 22727: 1
Branch 22728: 1
Branch 22729: 1
Branch 22730: 1
Branch 22731: 1
Branch 22732: 1
Branch 22733: 1
Branch 22734: 1
Branch 22735: 1
Branch 22736: 1
Branch 22737: 1
Branch 22738: 1
Branch 22739: 1
Branch 22740: 1
Branch 22741: 1
Branch 22742: 1
Branch 22743: 1
Branch 22744: 1
Branch 22745: 1
Branch 22746: 1
Branch 22747: 1
Branch 22748: 1
Branch 22749: 1
Branch 22750: 1
Branch 22751: 1
Branch 22752: 1
Branch 22753: 1
Branch 22754: 1
Branch 22755: 1
Branch 22756: 1
Branch 22757: 1
Branch 22758: 1
Branch 22759: 1
Branch 22760: 1
Branch 22761: 1
Branch 22762: 1
Branch 22763: 1
Branch 22764: 1
Branch 22765: 1
Branch 22766: 1
Branch 22767: 1
Branch 22768: 1
Branch 22769: 1
Branch 22770: 1
Branch 22771: 1
Branch 22772: 1
Branch 22773: 1
Branch 22774: 1
Branch 22775: 1
Branch 22776: 1
Branch 22777: 1
Branch 22778: 1
Branch 22779: 1
Branch 22780: 1
Branch 22781: 1
Branch 22782: 1
Branch 22783: 1
Branch 22784: 1
Branch 22785: 1
Branch 22786: 1
Branch 22787: 1
Branch 22788: 1
Branch 22789: 1
Branch 22790: 1
Branch 22791: 1
Branch 22792: 1
Branch 22793: 1
Branch 22794: 1
Branch 22795: 1
Branch 22796: 1
Branch 22797: 1
Branch 22798: 1
Branch 22799: 1
Branch 22800: 1
Branch 22801: 1
Branch 22802: 1
Branch 22803: 1
Branch 22804: 1
Branch 22805: 1
Branch 22806: 1
Branch 22807: 1
Branch 22808: 1
Branch 22809: 1
Branch 22810: 1
Branch 22811: 1
Branch 22812: 1
Branch 22813: 1
Branch 22814: 1
Branch 22815: 1
Branch 22816: 1
Branch 22817: 1
Branch 22818: 1
Branch 22819: 1
Branch 22820: 1
Branch 22821: 1
Branch 22822: 1
Branch 22823: 1
Branch 22824: 1
Branch 22825: 1
Branch 22826: 1
Branch 22827: 1
Branch 22828: 1
Branch 22829: 1
Branch 22830: 1
Branch 22831: 1
Branch 22832: 1
Branch 22833: 1
Branch 22834: 1
Branch 22835: 1
Branch 22836: 1
Branch 22837: 1
Branch 22838: 1
Branch 22839: 1
Branch 22840: 1
Branch 22841: 1
Branch 22842: 1
Branch 22843: 1
Branch 22844: 1
Branch 22845: 1
Branch 22846: 1
Branch 22847: 1
Branch 22848: 1
Branch 22849: 1
Branch 22850: 1
Branch 22851: 1
Branch 22852: 1
Branch 22853: 1
Branch 22854: 1
Branch 22855: 1
Branch 22856: 1
Branch 22857: 1
Branch 22858: 1
Branch 22859: 1
Branch 22860: 1
Branch 22861: 1
Branch 22862: 1
Branch 22863: 1
Branch 22864: 1
Branch 22865: 1
Branch 22866: 1
Branch 22867: 1
Branch 22868: 1
Branch 22869: 1
Branch 22870: 1
Branch 22871: 1
Branch 22872: 1
Branch 22873: 1
Branch 22874: 1
Branch 22875: 1
Branch 22876: 1
Branch 22877: 1
Branch 22878: 1
Branch 22879: 1
Branch 22880: 1
Branch 22881: 1
Branch 22882: 1
Branch 22883: 1
Branch 22884: 1
Branch 22885: 1
Branch 22886: 1
Branch 22887: 1
Branch 22888: 1
Branch 22889: 1
Branch 22890: 1
Branch 22891: 1
Branch 22892: 1
Branch 22893: 1
Branch 22894: 1
Branch 22895: 1
Branch 22896: 1
Branch 22897: 1
Branch 22898: 1
Branch 22899: 1
Branch 22900: 1
Branch 22901: 1
Branch 22902: 1
Branch 22903: 1
Branch 22904: 1
Branch 22905: 1
Branch 22906: 1
Branch 22907: 1
Branch 22908: 1
Branch 22909: 1
Branch 22910: 1
Branch 22911: 1
Branch 22912: 1
Branch 22913: 1
Branch 22914: 1
Branch 22915: 1
Branch 22916: 1
Branch 22917: 1
Branch 22918: 1
Branch 22919: 1
Branch 22920: 1
Branch 22921: 1
Branch 22922: 1
Branch 22923: 1
Branch 22924: 1
Branch 22925: 1
Branch 22926: 1
Branch 22927: 1
Branch 22928: 1
Branch 22929: 1
Branch 22930: 1
Branch 22931: 1
Branch 22932: 1
Branch 22933: 1
Branch 22934: 1
Branch 22935: 1
Branch 22936: 1
Branch 22937: 1
Branch 22938: 1
Branch 22939: 1
Branch 22940: 1
Branch 22941: 1
Branch 22942: 1
Branch 22943: 1
Branch 22944: 1
Branch 22945: 1
Branch 22946: 1
Branch 22947: 1
Branch 22948: 1
Branch 22949: 1
Branch 22950: 1
Branch 22951: 1
Branch 22952: 1
Branch 22953: 1
Branch 22954: 1
Branch 22955: 1
Branch 22956: 1
Branch 22957: 1
Branch 22958: 1
Branch 22959: 1
Branch 22960: 1
Branch 22961: 1
Branch 22962: 1
Branch 22963: 1
Branch 22964: 1
Branch 22965: 1
Branch 22966: 1
Branch 22967: 1
Branch 22968: 1
Branch 22969: 1
Branch 22970: 1
Branch 22971: 1
Branch 22972: 1
Branch 22973: 1
Branch 22974: 1
Branch 22975: 1
Branch 22976: 1
Branch 22977: 1
Branch 22978: 1
Branch 22979: 1
Branch 22980: 1
Branch 22981: 1
Branch 22982: 1
Branch 22983: 1
Branch 22984: 1
Branch 22985: 1
Branch 22986: 1
Branch 22987: 1
Branch 22988: 1
Branch 22989: 1
Branch 22990: 1
Branch 22991: 1
Branch 22992: 1
Branch 22993: 1
Branch 22994: 1
Branch 22995: 1
Branch 22996: 1
Branch 22997: 1
Branch 22998: 1
Branch 22999: 1
Branch 23000: 1
Branch 23001: 1
Branch 23002: 1
Branch 23003: 1
Branch 23004: 1
Branch 23005: 1
Branch 23006: 1
Branch 23007: 1
Branch 23008: 1
Branch 23009: 1
Branch 23010: 1
Branch 23011: 1
Branch 23012: 1
Branch 23013: 1
Branch 23014: 1
Branch 23015: 1
Branch 23016: 1
Branch 23017: 1
Branch 23018: 1
Branch 23019: 1
Branch 23020: 1
Branch 23021: 1
Branch 23022: 1
Branch 23023: 1
Branch 23024: 1
Branch 23025: 1
Branch 23026: 1
Branch 23027: 1
Branch 23028: 1
Branch 23029: 1
Branch 23030: 1
Branch 23031: 1
Branch 23032: 1
Branch 23033: 1
Branch 23034: 1
Branch 23035: 1
Branch 23036: 1
Branch 23037: 1
Branch 23038: 1
Branch 23039: 1
Branch 23040: 1
Branch 23041: 1
Branch 23042: 1
Branch 23043: 1
Branch 23044: 1
Branch 23045: 1
Branch 23046: 1
Branch 23047: 1
Branch 23048: 1
Branch 23049: 1
Branch 23050: 1
Branch 23051: 1
Branch 23052: 1
Branch 23053: 1
Branch 23054: 1
Branch 23055: 1
Branch 23056: 1
Branch 23057: 1
Branch 23058: 1
Branch 23059: 1
Branch 23060: 1
Branch 23061: 1
Branch 23062: 1
Branch 23063: 1
Branch 23064: 1
Branch 23065: 1
Branch 23066: 1
Branch 23067: 1
Branch 23068: 1
Branch 23069: 1
Branch 23070: 1
Branch 23071: 1
Branch 23072: 1
Branch 23073: 1
Branch 23074: 1
Branch 23075: 1
Branch 23076: 1
Branch 23077: 1
Branch 23078: 1
Branch 23079: 1
Branch 23080: 1
Branch 23081: 1
Branch 23082: 1
Branch 23083: 1
Branch 23084: 1
Branch 23085: 1
Branch 23086: 1
Branch 23087: 1
Branch 23088: 1
Branch 23089: 1
Branch 23090: 1
Branch 23091: 1
Branch 23092: 1
Branch 23093: 1
Branch 23094: 1
Branch 23095: 1
Branch 23096: 1
Branch 23097: 1
Branch 23098: 1
Branch 23099: 1
Branch 23100: 1
Branch 23101: 1
Branch 23102: 1
Branch 23103: 1
Branch 23104: 1
Branch 23105: 1
Branch 23106: 1
Branch 23107: 1
Branch 23108: 1
Branch 23109: 1
Branch 23110: 1
Branch 23111: 1
Branch 23112: 1
Branch 23113: 1
Branch 23114: 1
Branch 23115: 1
Branch 23116: 1
Branch 23117: 1
Branch 23118: 1
Branch 23119: 1
Branch 23120: 1
Branch 23121: 1
Branch 23122: 1
Branch 23123: 1
Branch 23124: 1
Branch 23125: 1
Branch 23126: 1
Branch 23127: 1
Branch 23128: 1
Branch 23129: 1
Branch 23130: 1
Branch 23131: 1
Branch 23132: 1
Branch 23133: 1
Branch 23134: 1
Branch 23135: 1
Branch 23136: 1
Branch 23137: 1
Branch 23138: 1
Branch 23139: 1
Branch 23140: 1
Branch 23141: 1
Branch 23142: 1
Branch 23143: 1
Branch 23144: 1
Branch 23145: 1
Branch 23146: 1
Branch 23147: 1
Branch 23148: 1
Branch 23149: 1
Branch 23150: 1
Branch 23151: 1
Branch 23152: 1
Branch 23153: 1
Branch 23154: 1
Branch 23155: 1
Branch 23156: 1
Branch 23157: 1
Branch 23158: 1
Branch 23159: 1
Branch 23160: 1
Branch 23161: 1
Branch 23162: 1
Branch 23163: 1
Branch 23164: 1
Branch 23165: 1
Branch 23166: 1
Branch 23167: 1
Branch 23168: 1
Branch 23169: 1
Branch 23170: 1
Branch 23171: 1
Branch 23172: 1
Branch 23173: 1
Branch 23174: 1
Branch 23175: 1
Branch 23176: 1
Branch 23177: 1
Branch 23178: 1
Branch 23179: 1
Branch 23180: 1
Branch 23181: 1
Branch 23182: 1
Branch 23183: 1
Branch 23184: 1
Branch 23185: 1
Branch 23186: 1
Branch 23187: 1
Branch 23188: 1
Branch 23189: 1
Branch 23190: 1
Branch 23191: 1
Branch 23192: 1
Branch 23193: 1
Branch 23194: 1
Branch 23195: 1
Branch 23196: 1
Branch 23197: 1
Branch 23198: 1
Branch 23199: 1
Branch 23200: 1
Branch 23201: 1
Branch 23202: 1
Branch 23203: 1
Branch 23204: 1
Branch 23205: 1
Branch 23206: 1
Branch 23207: 1
Branch 23208: 1
Branch 23209: 1
Branch 23210: 1
Branch 23211: 1
Branch 23212: 1
Branch 23213: 1
Branch 23214: 1
Branch 23215: 1
Branch 23216: 1
Branch 23217: 1
Branch 23218: 1
Branch 23219: 1
Branch 23220: 1
Branch 23221: 1
Branch 23222: 1
Branch 23223: 1
Branch 23224: 1
Branch 23225: 1
Branch 23226: 1
Branch 23227: 1
Branch 23228: 1
Branch 23229: 1
Branch 23230: 1
Branch 23231: 1
Branch 23232: 1
Branch 23233: 1
Branch 23234: 1
Branch 23235: 1
Branch 23236: 1
Branch 23237: 1
Branch 23238: 1
Branch 23239: 1
Branch 23240: 1
Branch 23241: 1
Branch 23242: 1
Branch 23243: 1
Branch 23244: 1
Branch 23245: 1
Branch 23246: 1
Branch 23247: 1
Branch 23248: 1
Branch 23249: 1
Branch 23250: 1
Branch 23251: 1
Branch 23252: 1
Branch 23253: 1
Branch 23254: 1
Branch 23255: 1
Branch 23256: 1
Branch 23257: 1
Branch 23258: 1
Branch 23259: 1
Branch 23260: 1
Branch 23261: 1
Branch 23262: 1
Branch 23263: 1
Branch 23264: 1
Branch 23265: 1
Branch 23266: 1
Branch 23267: 1
Branch 23268: 1
Branch 23269: 1
Branch 23270: 1
Branch 23271: 1
Branch 23272: 1
Branch 23273: 1
Branch 23274: 1
Branch 23275: 1
Branch 23276: 1
Branch 23277: 1
Branch 23278: 1
Branch 23279: 1
Branch 23280: 1
Branch 23281: 1
Branch 23282: 1
Branch 23283: 1
Branch 23284: 1
Branch 23285: 1
Branch 23286: 1
Branch 23287: 1
Branch 23288: 1
Branch 23289: 1
Branch 23290: 1
Branch 23291: 1
Branch 23292: 1
Branch 23293: 1
Branch 23294: 1
Branch 23295: 1
Branch 23296: 1
Branch 23297: 1
Branch 23298: 1
Branch 23299: 1
Branch 23300: 1
Branch 23301: 1
Branch 23302: 1
Branch 23303: 1
Branch 23304: 1
Branch 23305: 1
Branch 23306: 1
Branch 23307: 1
Branch 23308: 1
Branch 23309: 1
Branch 23310: 1
Branch 23311: 1
Branch 23312: 1
Branch 23313: 1
Branch 23314: 1
Branch 23315: 1
Branch 23316: 1
Branch 23317: 1
Branch 23318: 1
Branch 23319: 1
Branch 23320: 1
Branch 23321: 1
Branch 23322: 1
Branch 23323: 1
Branch 23324: 1
Branch 23325: 1
Branch 23326: 1
Branch 23327: 1
Branch 23328: 1
Branch 23329: 1
Branch 23330: 1
Branch 23331: 1
Branch 23332: 1
Branch 23333: 1
Branch 23334: 1
Branch 23335: 1
Branch 23336: 1
Branch 23337: 1
Branch 23338: 1
Branch 23339: 1
Branch 23340: 1
Branch 23341: 1
Branch 23342: 1
Branch 23343: 1
Branch 23344: 1
Branch 23345: 1
Branch 23346: 1
Branch 23347: 1
Branch 23348: 1
Branch 23349: 1
Branch 23350: 1
Branch 23351: 1
Branch 23352: 1
Branch 23353: 1
Branch 23354: 1
Branch 23355: 1
Branch 23356: 1
Branch 23357: 1
Branch 23358: 1
Branch 23359: 1
Branch 23360: 1
Branch 23361: 1
Branch 23362: 1
Branch 23363: 1
Branch 23364: 1
Branch 23365: 1
Branch 23366: 1
Branch 23367: 1
Branch 23368: 1
Branch 23369: 1
Branch 23370: 1
Branch 23371: 1
Branch 23372: 1
Branch 23373: 1
Branch 23374: 1
Branch 23375: 1
Branch 23376: 1
Branch 23377: 1
Branch 23378: 1
Branch 23379: 1
Branch 23380: 1
Branch 23381: 1
Branch 23382: 1
Branch 23383: 1
Branch 23384: 1
Branch 23385: 1
Branch 23386: 1
Branch 23387: 1
Branch 23388: 1
Branch 23389: 1
Branch 23390: 1
Branch 23391: 1
Branch 23392: 1
Branch 23393: 1
Branch 23394: 1
Branch 23395: 1
Branch 23396: 1
Branch 23397: 1
Branch 23398: 1
Branch 23399: 1
Branch 23400: 1
Branch 23401: 1
Branch 23402: 1
Branch 23403: 1
Branch 23404: 1
Branch 23405: 1
Branch 23406: 1
Branch 23407: 1
Branch 23408: 1
Branch 23409: 1
Branch 23410: 1
Branch 23411: 1
Branch 23412: 1
Branch 23413: 1
Branch 23414: 1
Branch 23415: 1
Branch 23416: 1
Branch 23417: 1
Branch 23418: 1
Branch 23419: 1
Branch 23420: 1
Branch 23421: 1
Branch 23422: 1
Branch 23423: 1
Branch 23424: 1
Branch 23425: 1
Branch 23426: 1
Branch 23427: 1
Branch 23428: 1
Branch 23429: 1
Branch 23430: 1
Branch 23431: 1
Branch 23432: 1
Branch 23433: 1
Branch 23434: 1
Branch 23435: 1
Branch 23436: 1
Branch 23437: 1
Branch 23438: 1
Branch 23439: 1
Branch 23440: 1
Branch 23441: 1
Branch 23442: 1
Branch 23443: 1
Branch 23444: 1
Branch 23445: 1
Branch 23446: 1
Branch 23447: 1
Branch 23448: 1
Branch 23449: 1
Branch 23450: 1
Branch 23451: 1
Branch 23452: 1
Branch 23453: 1
Branch 23454: 1
Branch 23455: 1
Branch 23456: 1
Branch 23457: 1
Branch 23458: 1
Branch 23459: 1
Branch 23460: 1
Branch 23461: 1
Branch 23462: 1
Branch 23463: 1
Branch 23464: 1
Branch 23465: 1
Branch 23466: 1
Branch 23467: 1
Branch 23468: 1
Branch 23469: 1
Branch 23470: 1
Branch 23471: 1
Branch 23472: 1
Branch 23473: 1
Branch 23474: 1
Branch 23475: 1
Branch 23476: 1
Branch 23477: 1
Branch 23478: 1
Branch 23479: 1
Branch 23480: 1
Branch 23481: 1
Branch 23482: 1
Branch 23483: 1
Branch 23484: 1
Branch 23485: 1
Branch 23486: 1
Branch 23487: 1
Branch 23488: 1
Branch 23489: 1
Branch 23490: 1
Branch 23491: 1
Branch 23492: 1
Branch 23493: 1
Branch 23494: 1
Branch 23495: 1
Branch 23496: 1
Branch 23497: 1
Branch 23498: 1
Branch 23499: 1
Branch 23500: 1
Branch 23501: 1
Branch 23502: 1
Branch 23503: 1
Branch 23504: 1
Branch 23505: 1
Branch 23506: 1
Branch 23507: 1
Branch 23508: 1
Branch 23509: 1
Branch 23510: 1
Branch 23511: 1
Branch 23512: 1
Branch 23513: 1
Branch 23514: 1
Branch 23515: 1
Branch 23516: 1
Branch 23517: 1
Branch 23518: 1
Branch 23519: 1
Branch 23520: 1
Branch 23521: 1
Branch 23522: 1
Branch 23523: 1
Branch 23524: 1
Branch 23525: 1
Branch 23526: 1
Branch 23527: 1
Branch 23528: 1
Branch 23529: 1
Branch 23530: 1
Branch 23531: 1
Branch 23532: 1
Branch 23533: 1
Branch 23534: 1
Branch 23535: 1
Branch 23536: 1
Branch 23537: 1
Branch 23538: 1
Branch 23539: 1
Branch 23540: 1
Branch 23541: 1
Branch 23542: 1
Branch 23543: 1
Branch 23544: 1
Branch 23545: 1
Branch 23546: 1
Branch 23547: 1
Branch 23548: 1
Branch 23549: 1
Branch 23550: 1
Branch 23551: 1
Branch 23552: 1
Branch 23553: 1
Branch 23554: 1
Branch 23555: 1
Branch 23556: 1
Branch 23557: 1
Branch 23558: 1
Branch 23559: 1
Branch 23560: 1
Branch 23561: 1
Branch 23562: 1
Branch 23563: 1
Branch 23564: 1
Branch 23565: 1
Branch 23566: 1
Branch 23567: 1
Branch 23568: 1
Branch 23569: 1
Branch 23570: 1
Branch 23571: 1
Branch 23572: 1
Branch 23573: 1
Branch 23574: 1
Branch 23575: 1
Branch 23576: 1
Branch 23577: 1
Branch 23578: 1
Branch 23579: 1
Branch 23580: 1
Branch 23581: 1
Branch 23582: 1
Branch 23583: 1
Branch 23584: 1
Branch 23585: 1
Branch 23586: 1
Branch 23587: 1
Branch 23588: 1
Branch 23589: 1
Branch 23590: 1
Branch 23591: 1
Branch 23592: 1
Branch 23593: 1
Branch 23594: 1
Branch 23595: 1
Branch 23596: 1
Branch 23597: 1
Branch 23598: 1
Branch 23599: 1
Branch 23600: 1
Branch 23601: 1
Branch 23602: 1
Branch 23603: 1
Branch 23604: 1
Branch 23605: 1
Branch 23606: 1
Branch 23607: 1
Branch 23608: 1
Branch 23609: 1
Branch 23610: 1
Branch 23611: 1
Branch 23612: 1
Branch 23613: 1
Branch 23614: 1
Branch 23615: 1
Branch 23616: 1
Branch 23617: 1
Branch 23618: 1
Branch 23619: 1
Branch 23620: 1
Branch 23621: 1
Branch 23622: 1
Branch 23623: 1
Branch 23624: 1
Branch 23625: 1
Branch 23626: 1
Branch 23627: 1
Branch 23628: 1
Branch 23629: 1
Branch 23630: 1
Branch 23631: 1
Branch 23632: 1
Branch 23633: 1
Branch 23634: 1
Branch 23635: 1
Branch 23636: 1
Branch 23637: 1
Branch 23638: 1
Branch 23639: 1
Branch 23640: 1
Branch 23641: 1
Branch 23642: 1
Branch 23643: 1
Branch 23644: 1
Branch 23645: 1
Branch 23646: 1
Branch 23647: 1
Branch 23648: 1
Branch 23649: 1
Branch 23650: 1
Branch 23651: 1
Branch 23652: 1
Branch 23653: 1
Branch 23654: 1
Branch 23655: 1
Branch 23656: 1
Branch 23657: 1
Branch 23658: 1
Branch 23659: 1
Branch 23660: 1
Branch 23661: 1
Branch 23662: 1
Branch 23663: 1
Branch 23664: 1
Branch 23665: 1
Branch 23666: 1
Branch 23667: 1
Branch 23668: 1
Branch 23669: 1
Branch 23670: 1
Branch 23671: 1
Branch 23672: 1
Branch 23673: 1
Branch 23674: 1
Branch 23675: 1
Branch 23676: 1
Branch 23677: 1
Branch 23678: 1
Branch 23679: 1
Branch 23680: 1
Branch 23681: 1
Branch 23682: 1
Branch 23683: 1
Branch 23684: 1
Branch 23685: 1
Branch 23686: 1
Branch 23687: 1
Branch 23688: 1
Branch 23689: 1
Branch 23690: 1
Branch 23691: 1
Branch 23692: 1
Branch 23693: 1
Branch 23694: 1
Branch 23695: 1
Branch 23696: 1
Branch 23697: 1
Branch 23698: 1
Branch 23699: 1
Branch 23700: 1
Branch 23701: 1
Branch 23702: 1
Branch 23703: 1
Branch 23704: 1
Branch 23705: 1
Branch 23706: 1
Branch 23707: 1
Branch 23708: 1
Branch 23709: 1
Branch 23710: 1
Branch 23711: 1
Branch 23712: 1
Branch 23713: 1
Branch 23714: 1
Branch 23715: 1
Branch 23716: 1
Branch 23717: 1
Branch 23718: 1
Branch 23719: 1
Branch 23720: 1
Branch 23721: 1
Branch 23722: 1
Branch 23723: 1
Branch 23724: 1
Branch 23725: 1
Branch 23726: 1
Branch 23727: 1
Branch 23728: 1
Branch 23729: 1
Branch 23730: 1
Branch 23731: 1
Branch 23732: 1
Branch 23733: 1
Branch 23734: 1
Branch 23735: 1
Branch 23736: 1
Branch 23737: 1
Branch 23738: 1
Branch 23739: 1
Branch 23740: 1
Branch 23741: 1
Branch 23742: 1
Branch 23743: 1
Branch 23744: 1
Branch 23745: 1
Branch 23746: 1
Branch 23747: 1
Branch 23748: 1
Branch 23749: 1
Branch 23750: 1
Branch 23751: 1
Branch 23752: 1
Branch 23753: 1
Branch 23754: 1
Branch 23755: 1
Branch 23756: 1
Branch 23757: 1
Branch 23758: 1
Branch 23759: 1
Branch 23760: 1
Branch 23761: 1
Branch 23762: 1
Branch 23763: 1
Branch 23764: 1
Branch 23765: 1
Branch 23766: 1
Branch 23767: 1
Branch 23768: 1
Branch 23769: 1
Branch 23770: 1
Branch 23771: 1
Branch 23772: 1
Branch 23773: 1
Branch 23774: 1
Branch 23775: 1
Branch 23776: 1
Branch 23777: 1
Branch 23778: 1
Branch 23779: 1
Branch 23780: 1
Branch 23781: 1
Branch 23782: 1
Branch 23783: 1
Branch 23784: 1
Branch 23785: 1
Branch 23786: 1
Branch 23787: 1
Branch 23788: 1
Branch 23789: 1
Branch 23790: 1
Branch 23791: 1
Branch 23792: 1
Branch 23793: 1
Branch 23794: 1
Branch 23795: 1
Branch 23796: 1
Branch 23797: 1
Branch 23798: 1
Branch 23799: 1
Branch 23800: 1
Branch 23801: 1
Branch 23802: 1
Branch 23803: 1
Branch 23804: 1
Branch 23805: 1
Branch 23806: 1
Branch 23807: 1
Branch 23808: 1
Branch 23809: 1
Branch 23810: 1
Branch 23811: 1
Branch 23812: 1
Branch 23813: 1
Branch 23814: 1
Branch 23815: 1
Branch 23816: 1
Branch 23817: 1
Branch 23818: 1
Branch 23819: 1
Branch 23820: 1
Branch 23821: 1
Branch 23822: 1
Branch 23823: 1
Branch 23824: 1
Branch 23825: 1
Branch 23826: 1
Branch 23827: 1
Branch 23828: 1
Branch 23829: 1
Branch 23830: 1
Branch 23831: 1
Branch 23832: 1
Branch 23833: 1
Branch 23834: 1
Branch 23835: 1
Branch 23836: 1
Branch 23837: 1
Branch 23838: 1
Branch 23839: 1
Branch 23840: 1
Branch 23841: 1
Branch 23842: 1
Branch 23843: 1
Branch 23844: 1
Branch 23845: 1
Branch 23846: 1
Branch 23847: 1
Branch 23848: 1
Branch 23849: 1
Branch 23850: 1
Branch 23851: 1
Branch 23852: 1
Branch 23853: 1
Branch 23854: 1
Branch 23855: 1
Branch 23856: 1
Branch 23857: 1
Branch 23858: 1
Branch 23859: 1
Branch 23860: 1
Branch 23861: 1
Branch 23862: 1
Branch 23863: 1
Branch 23864: 1
Branch 23865: 1
Branch 23866: 1
Branch 23867: 1
Branch 23868: 1
Branch 23869: 1
Branch 23870: 1
Branch 23871: 1
Branch 23872: 1
Branch 23873: 1
Branch 23874: 1
Branch 23875: 1
Branch 23876: 1
Branch 23877: 1
Branch 23878: 1
Branch 23879: 1
Branch 23880: 1
Branch 23881: 1
Branch 23882: 1
Branch 23883: 1
Branch 23884: 1
Branch 23885: 1
Branch 23886: 1
Branch 23887: 1
Branch 23888: 1
Branch 23889: 1
Branch 23890: 1
Branch 23891: 1
Branch 23892: 1
Branch 23893: 1
Branch 23894: 1
Branch 23895: 1
Branch 23896: 1
Branch 23897: 1
Branch 23898: 1
Branch 23899: 1
Branch 23900: 1
Branch 23901: 1
Branch 23902: 1
Branch 23903: 1
Branch 23904: 1
Branch 23905: 1
Branch 23906: 1
Branch 23907: 1
Branch 23908: 1
Branch 23909: 1
Branch 23910: 1
Branch 23911: 1
Branch 23912: 1
Branch 23913: 1
Branch 23914: 1
Branch 23915: 1
Branch 23916: 1
Branch 23917: 1
Branch 23918: 1
Branch 23919: 1
Branch 23920: 1
Branch 23921: 1
Branch 23922: 1
Branch 23923: 1
Branch 23924: 1
Branch 23925: 1
Branch 23926: 1
Branch 23927: 1
Branch 23928: 1
Branch 23929: 1
Branch 23930: 1
Branch 23931: 1
Branch 23932: 1
Branch 23933: 1
Branch 23934: 1
Branch 23935: 1
Branch 23936: 1
Branch 23937: 1
Branch 23938: 1
Branch 23939: 1
Branch 23940: 1
Branch 23941: 1
Branch 23942: 1
Branch 23943: 1
Branch 23944: 1
Branch 23945: 1
Branch 23946: 1
Branch 23947: 1
Branch 23948: 1
Branch 23949: 1
Branch 23950: 1
Branch 23951: 1
Branch 23952: 1
Branch 23953: 1
Branch 23954: 1
Branch 23955: 1
Branch 23956: 1
Branch 23957: 1
Branch 23958: 1
Branch 23959: 1
Branch 23960: 1
Branch 23961: 1
Branch 23962: 1
Branch 23963: 1
Branch 23964: 1
Branch 23965: 1
Branch 23966: 1
Branch 23967: 1
Branch 23968: 1
Branch 23969: 1
Branch 23970: 1
Branch 23971: 1
Branch 23972: 1
Branch 23973: 1
Branch 23974: 1
Branch 23975: 1
Branch 23976: 1
Branch 23977: 1
Branch 23978: 1
Branch 23979: 1
Branch 23980: 1
Branch 23981: 1
Branch 23982: 1
Branch 23983: 1
Branch 23984: 1
Branch 23985: 1
Branch 23986: 1
Branch 23987: 1
Branch 23988: 1
Branch 23989: 1
Branch 23990: 1
Branch 23991: 1
Branch 23992: 1
Branch 23993: 1
Branch 23994: 1
Branch 23995: 1
Branch 23996: 1
Branch 23997: 1
Branch 23998: 1
Branch 23999: 1
Branch 24000: 1
Branch 24001: 1
Branch 24002: 1
Branch 24003: 1
Branch 24004: 1
Branch 24005: 1
Branch 24006: 1
Branch 24007: 1
Branch 24008: 1
Branch 24009: 1
Branch 24010: 1
Branch 24011: 1
Branch 24012: 1
Branch 24013: 1
Branch 24014: 1
Branch 24015: 1
Branch 24016: 1
Branch 24017: 1
Branch 24018: 1
Branch 24019: 1
Branch 24020: 1
Branch 24021: 1
Branch 24022: 1
Branch 24023: 1
Branch 24024: 1
Branch 24025: 1
Branch 24026: 1
Branch 24027: 1
Branch 24028: 1
Branch 24029: 1
Branch 24030: 1
Branch 24031: 1
Branch 24032: 1
Branch 24033: 1
Branch 24034: 1
Branch 24035: 1
Branch 24036: 1
Branch 24037: 1
Branch 24038: 1
Branch 24039: 1
Branch 24040: 1
Branch 24041: 1
Branch 24042: 1
Branch 24043: 1
Branch 24044: 1
Branch 24045: 1
Branch 24046: 1
Branch 24047: 1
Branch 24048: 1
Branch 24049: 1
Branch 24050: 1
Branch 24051: 1
Branch 24052: 1
Branch 24053: 1
Branch 24054: 1
Branch 24055: 1
Branch 24056: 1
Branch 24057: 1
Branch 24058: 1
Branch 24059: 1
Branch 24060: 1
Branch 24061: 1
Branch 24062: 1
Branch 24063: 1
Branch 24064: 1
Branch 24065: 1
Branch 24066: 1
Branch 24067: 1
Branch 24068: 1
Branch 24069: 1
Branch 24070: 1
Branch 24071: 1
Branch 24072: 1
Branch 24073: 1
Branch 24074: 1
Branch 24075: 1
Branch 24076: 1
Branch 24077: 1
Branch 24078: 1
Branch 24079: 1
Branch 24080: 1
Branch 24081: 1
Branch 24082: 1
Branch 24083: 1
Branch 24084: 1
Branch 24085: 1
Branch 24086: 1
Branch 24087: 1
Branch 24088: 1
Branch 24089: 1
Branch 24090: 1
Branch 24091: 1
Branch 24092: 1
Branch 24093: 1
Branch 24094: 1
Branch 24095: 1
Branch 24096: 1
Branch 24097: 1
Branch 24098: 1
Branch 24099: 1
Branch 24100: 1
Branch 24101: 1
Branch 24102: 1
Branch 24103: 1
Branch 24104: 1
Branch 24105: 1
Branch 24106: 1
Branch 24107: 1
Branch 24108: 1
Branch 24109: 1
Branch 24110: 1
Branch 24111: 1
Branch 24112: 1
Branch 24113: 1
Branch 24114: 1
Branch 24115: 1
Branch 24116: 1
Branch 24117: 1
Branch 24118: 1
Branch 24119: 1
Branch 24120: 1
Branch 24121: 1
Branch 24122: 1
Branch 24123: 1
Branch 24124: 1
Branch 24125: 1
Branch 24126: 1
Branch 24127: 1
Branch 24128: 1
Branch 24129: 1
Branch 24130: 1
Branch 24131: 1
Branch 24132: 1
Branch 24133: 1
Branch 24134: 1
Branch 24135: 1
Branch 24136: 1
Branch 24137: 1
Branch 24138: 1
Branch 24139: 1
Branch 24140: 1
Branch 24141: 1
Branch 24142: 1
Branch 24143: 1
Branch 24144: 1
Branch 24145: 1
Branch 24146: 1
Branch 24147: 1
Branch 24148: 1
Branch 24149: 1
Branch 24150: 1
Branch 24151: 1
Branch 24152: 1
Branch 24153: 1
Branch 24154: 1
Branch 24155: 1
Branch 24156: 1
Branch 24157: 1
Branch 24158: 1
Branch 24159: 1
Branch 24160: 1
Branch 24161: 1
Branch 24162: 1
Branch 24163: 1
Branch 24164: 1
Branch 24165: 1
Branch 24166: 1
Branch 24167: 1
Branch 24168: 1
Branch 24169: 1
Branch 24170: 1
Branch 24171: 1
Branch 24172: 1
Branch 24173: 1
Branch 24174: 1
Branch 24175: 1
Branch 24176: 1
Branch 24177: 1
Branch 24178: 1
Branch 24179: 1
Branch 24180: 1
Branch 24181: 1
Branch 24182: 1
Branch 24183: 1
Branch 24184: 1
Branch 24185: 1
Branch 24186: 1
Branch 24187: 1
Branch 24188: 1
Branch 24189: 1
Branch 24190: 1
Branch 24191: 1
Branch 24192: 1
Branch 24193: 1
Branch 24194: 1
Branch 24195: 1
Branch 24196: 1
Branch 24197: 1
Branch 24198: 1
Branch 24199: 1
Branch 24200: 1
Branch 24201: 1
Branch 24202: 1
Branch 24203: 1
Branch 24204: 1
Branch 24205: 1
Branch 24206: 1
Branch 24207: 1
Branch 24208: 1
Branch 24209: 1
Branch 24210: 1
Branch 24211: 1
Branch 24212: 1
Branch 24213: 1
Branch 24214: 1
Branch 24215: 1
Branch 24216: 1
Branch 24217: 1
Branch 24218: 1
Branch 24219: 1
Branch 24220: 1
Branch 24221: 1
Branch 24222: 1
Branch 24223: 1
Branch 24224: 1
Branch 24225: 1
Branch 24226: 1
Branch 24227: 1
Branch 24228: 1
Branch 24229: 1
Branch 24230: 1
Branch 24231: 1
Branch 24232: 1
Branch 24233: 1
Branch 24234: 1
Branch 24235: 1
Branch 24236: 1
Branch 24237: 1
Branch 24238: 1
Branch 24239: 1
Branch 24240: 1
Branch 24241: 1
Branch 24242: 1
Branch 24243: 1
Branch 24244: 1
Branch 24245: 1
Branch 24246: 1
Branch 24247: 1
Branch 24248: 1
Branch 24249: 1
Branch 24250: 1
Branch 24251: 1
Branch 24252: 1
Branch 24253: 1
Branch 24254: 1
Branch 24255: 1
Branch 24256: 1
Branch 24257: 1
Branch 24258: 1
Branch 24259: 1
Branch 24260: 1
Branch 24261: 1
Branch 24262: 1
Branch 24263: 1
Branch 24264: 1
Branch 24265: 1
Branch 24266: 1
Branch 24267: 1
Branch 24268: 1
Branch 24269: 1
Branch 24270: 1
Branch 24271: 1
Branch 24272: 1
Branch 24273: 1
Branch 24274: 1
Branch 24275: 1
Branch 24276: 1
Branch 24277: 1
Branch 24278: 1
Branch 24279: 1
Branch 24280: 1
Branch 24281: 1
Branch 24282: 1
Branch 24283: 1
Branch 24284: 1
Branch 24285: 1
Branch 24286: 1
Branch 24287: 1
Branch 24288: 1
Branch 24289: 1
Branch 24290: 1
Branch 24291: 1
Branch 24292: 1
Branch 24293: 1
Branch 24294: 1
Branch 24295: 1
Branch 24296: 1
Branch 24297: 1
Branch 24298: 1
Branch 24299: 1
Branch 24300: 1
Branch 24301: 1
Branch 24302: 1
Branch 24303: 1
Branch 24304: 1
Branch 24305: 1
Branch 24306: 1
Branch 24307: 1
Branch 24308: 1
Branch 24309: 1
Branch 24310: 1
Branch 24311: 1
Branch 24312: 1
Branch 24313: 1
Branch 24314: 1
Branch 24315: 1
Branch 24316: 1
Branch 24317: 1
Branch 24318: 1
Branch 24319: 1
Branch 24320: 1
Branch 24321: 1
Branch 24322: 1
Branch 24323: 1
Branch 24324: 1
Branch 24325: 1
Branch 24326: 1
Branch 24327: 1
Branch 24328: 1
Branch 24329: 1
Branch 24330: 1
Branch 24331: 1
Branch 24332: 1
Branch 24333: 1
Branch 24334: 1
Branch 24335: 1
Branch 24336: 1
Branch 24337: 1
Branch 24338: 1
Branch 24339: 1
Branch 24340: 1
Branch 24341: 1
Branch 24342: 1
Branch 24343: 1
Branch 24344: 1
Branch 24345: 1
Branch 24346: 1
Branch 24347: 1
Branch 24348: 1
Branch 24349: 1
Branch 24350: 1
Branch 24351: 1
Branch 24352: 1
Branch 24353: 1
Branch 24354: 1
Branch 24355: 1
Branch 24356: 1
Branch 24357: 1
Branch 24358: 1
Branch 24359: 1
Branch 24360: 1
Branch 24361: 1
Branch 24362: 1
Branch 24363: 1
Branch 24364: 1
Branch 24365: 1
Branch 24366: 1
Branch 24367: 1
Branch 24368: 1
Branch 24369: 1
Branch 24370: 1
Branch 24371: 1
Branch 24372: 1
Branch 24373: 1
Branch 24374: 1
Branch 24375: 1
Branch 24376: 1
Branch 24377: 1
Branch 24378: 1
Branch 24379: 1
Branch 24380: 1
Branch 24381: 1
Branch 24382: 1
Branch 24383: 1
Branch 24384: 1
Branch 24385: 1
Branch 24386: 1
Branch 24387: 1
Branch 24388: 1
Branch 24389: 1
Branch 24390: 1
Branch 24391: 1
Branch 24392: 1
Branch 24393: 1
Branch 24394: 1
Branch 24395: 1
Branch 24396: 1
Branch 24397: 1
Branch 24398: 1
Branch 24399: 1
Branch 24400: 1
Branch 24401: 1
Branch 24402: 1
Branch 24403: 1
Branch 24404: 1
Branch 24405: 1
Branch 24406: 1
Branch 24407: 1
Branch 24408: 1
Branch 24409: 1
Branch 24410: 1
Branch 24411: 1
Branch 24412: 1
Branch 24413: 1
Branch 24414: 1
Branch 24415: 1
Branch 24416: 1
Branch 24417: 1
Branch 24418: 1
Branch 24419: 1
Branch 24420: 1
Branch 24421: 1
Branch 24422: 1
Branch 24423: 1
Branch 24424: 1
Branch 24425: 1
Branch 24426: 1
Branch 24427: 1
Branch 24428: 1
Branch 24429: 1
Branch 24430: 1
Branch 24431: 1
Branch 24432: 1
Branch 24433: 1
Branch 24434: 1
Branch 24435: 1
Branch 24436: 1
Branch 24437: 1
Branch 24438: 1
Branch 24439: 1
Branch 24440: 1
Branch 24441: 1
Branch 24442: 1
Branch 24443: 1
Branch 24444: 1
Branch 24445: 1
Branch 24446: 1
Branch 24447: 1
Branch 24448: 1
Branch 24449: 1
Branch 24450: 1
Branch 24451: 1
Branch 24452: 1
Branch 24453: 1
Branch 24454: 1
Branch 24455: 1
Branch 24456: 1
Branch 24457: 1
Branch 24458: 1
Branch 24459: 1
Branch 24460: 1
Branch 24461: 1
Branch 24462: 1
Branch 24463: 1
Branch 24464: 1
Branch 24465: 1
Branch 24466: 1
Branch 24467: 1
Branch 24468: 1
Branch 24469: 1
Branch 24470: 1
Branch 24471: 1
Branch 24472: 1
Branch 24473: 1
Branch 24474: 1
Branch 24475: 1
Branch 24476: 1
Branch 24477: 1
Branch 24478: 1
Branch 24479: 1
Branch 24480: 1
Branch 24481: 1
Branch 24482: 1
Branch 24483: 1
Branch 24484: 1
Branch 24485: 1
Branch 24486: 1
Branch 24487: 1
Branch 24488: 1
Branch 24489: 1
Branch 24490: 1
Branch 24491: 1
Branch 24492: 1
Branch 24493: 1
Branch 24494: 1
Branch 24495: 1
Branch 24496: 1
Branch 24497: 1
Branch 24498: 1
Branch 24499: 1
Branch 24500: 1
Branch 24501: 1
Branch 24502: 1
Branch 24503: 1
Branch 24504: 1
Branch 24505: 1
Branch 24506: 1
Branch 24507: 1
Branch 24508: 1
Branch 24509: 1
Branch 24510: 1
Branch 24511: 1
Branch 24512: 1
Branch 24513: 1
Branch 24514: 1
Branch 24515: 1
Branch 24516: 1
Branch 24517: 1
Branch 24518: 1
Branch 24519: 1
Branch 24520: 1
Branch 24521: 1
Branch 24522: 1
Branch 24523: 1
Branch 24524: 1
Branch 24525: 1
Branch 24526: 1
Branch 24527: 1
Branch 24528: 1
Branch 24529: 1
Branch 24530: 1
Branch 24531: 1
Branch 24532: 1
Branch 24533: 1
Branch 24534: 1
Branch 24535: 1
Branch 24536: 1
Branch 24537: 1
Branch 24538: 1
Branch 24539: 1
Branch 24540: 1
Branch 24541: 1
Branch 24542: 1
Branch 24543: 1
Branch 24544: 1
Branch 24545: 1
Branch 24546: 1
Branch 24547: 1
Branch 24548: 1
Branch 24549: 1
Branch 24550: 1
Branch 24551: 1
Branch 24552: 1
Branch 24553: 1
Branch 24554: 1
Branch 24555: 1
Branch 24556: 1
Branch 24557: 1
Branch 24558: 1
Branch 24559: 1
Branch 24560: 1
Branch 24561: 1
Branch 24562: 1
Branch 24563: 1
Branch 24564: 1
Branch 24565: 1
Branch 24566: 1
Branch 24567: 1
Branch 24568: 1
Branch 24569: 1
Branch 24570: 1
Branch 24571: 1
Branch 24572: 1
Branch 24573: 1
Branch 24574: 1
Branch 24575: 1
Branch 24576: 1
Branch 24577: 1
Branch 24578: 1
Branch 24579: 1
Branch 24580: 1
Branch 24581: 1
Branch 24582: 1
Branch 24583: 1
Branch 24584: 1
Branch 24585: 1
Branch 24586: 1
Branch 24587: 1
Branch 24588: 1
Branch 24589: 1
Branch 24590: 1
Branch 24591: 1
Branch 24592: 1
Branch 24593: 1
Branch 24594: 1
Branch 24595: 1
Branch 24596: 1
Branch 24597: 1
Branch 24598: 1
Branch 24599: 1
Branch 24600: 1
Branch 24601: 1
Branch 24602: 1
Branch 24603: 1
Branch 24604: 1
Branch 24605: 1
Branch 24606: 1
Branch 24607: 1
Branch 24608: 1
Branch 24609: 1
Branch 24610: 1
Branch 24611: 1
Branch 24612: 1
Branch 24613: 1
Branch 24614: 1
Branch 24615: 1
Branch 24616: 1
Branch 24617: 1
Branch 24618: 1
Branch 24619: 1
Branch 24620: 1
Branch 24621: 1
Branch 24622: 1
Branch 24623: 1
Branch 24624: 1
Branch 24625: 1
Branch 24626: 1
Branch 24627: 1
Branch 24628: 1
Branch 24629: 1
Branch 24630: 1
Branch 24631: 1
Branch 24632: 1
Branch 24633: 1
Branch 24634: 1
Branch 24635: 1
Branch 24636: 1
Branch 24637: 1
Branch 24638: 1
Branch 24639: 1
Branch 24640: 1
Branch 24641: 1
Branch 24642: 1
Branch 24643: 1
Branch 24644: 1
Branch 24645: 1
Branch 24646: 1
Branch 24647: 1
Branch 24648: 1
Branch 24649: 1
Branch 24650: 1
Branch 24651: 1
Branch 24652: 1
Branch 24653: 1
Branch 24654: 1
Branch 24655: 1
Branch 24656: 1
Branch 24657: 1
Branch 24658: 1
Branch 24659: 1
Branch 24660: 1
Branch 24661: 1
Branch 24662: 1
Branch 24663: 1
Branch 24664: 1
Branch 24665: 1
Branch 24666: 1
Branch 24667: 1
Branch 24668: 1
Branch 24669: 1
Branch 24670: 1
Branch 24671: 1
Branch 24672: 1
Branch 24673: 1
Branch 24674: 1
Branch 24675: 1
Branch 24676: 1
Branch 24677: 1
Branch 24678: 1
Branch 24679: 1
Branch 24680: 1
Branch 24681: 1
Branch 24682: 1
Branch 24683: 1
Branch 24684: 1
Branch 24685: 1
Branch 24686: 1
Branch 24687: 1
Branch 24688: 1
Branch 24689: 1
Branch 24690: 1
Branch 24691: 1
Branch 24692: 1
Branch 24693: 1
Branch 24694: 1
Branch 24695: 1
Branch 24696: 1
Branch 24697: 1
Branch 24698: 1
Branch 24699: 1
Branch 24700: 1
Branch 24701: 1
Branch 24702: 1
Branch 24703: 1
Branch 24704: 1
Branch 24705: 1
Branch 24706: 1
Branch 24707: 1
Branch 24708: 1
Branch 24709: 1
Branch 24710: 1
Branch 24711: 1
Branch 24712: 1
Branch 24713: 1
Branch 24714: 1
Branch 24715: 1
Branch 24716: 1
Branch 24717: 1
Branch 24718: 1
Branch 24719: 1
Branch 24720: 1
Branch 24721: 1
Branch 24722: 1
Branch 24723: 1
Branch 24724: 1
Branch 24725: 1
Branch 24726: 1
Branch 24727: 1
Branch 24728: 1
Branch 24729: 1
Branch 24730: 1
Branch 24731: 1
Branch 24732: 1
Branch 24733: 1
Branch 24734: 1
Branch 24735: 1
Branch 24736: 1
Branch 24737: 1
Branch 24738: 1
Branch 24739: 1
Branch 24740: 1
Branch 24741: 1
Branch 24742: 1
Branch 24743: 1
Branch 24744: 1
Branch 24745: 1
Branch 24746: 1
Branch 24747: 1
Branch 24748: 1
Branch 24749: 1
Branch 24750: 1
Branch 24751: 1
Branch 24752: 1
Branch 24753: 1
Branch 24754: 1
Branch 24755: 1
Branch 24756: 1
Branch 24757: 1
Branch 24758: 1
Branch 24759: 1
Branch 24760: 1
Branch 24761: 1
Branch 24762: 1
Branch 24763: 1
Branch 24764: 1
Branch 24765: 1
Branch 24766: 1
Branch 24767: 1
Branch 24768: 1
Branch 24769: 1
Branch 24770: 1
Branch 24771: 1
Branch 24772: 1
Branch 24773: 1
Branch 24774: 1
Branch 24775: 1
Branch 24776: 1
Branch 24777: 1
Branch 24778: 1
Branch 24779: 1
Branch 24780: 1
Branch 24781: 1
Branch 24782: 1
Branch 24783: 1
Branch 24784: 1
Branch 24785: 1
Branch 24786: 1
Branch 24787: 1
Branch 24788: 1
Branch 24789: 1
Branch 24790: 1
Branch 24791: 1
Branch 24792: 1
Branch 24793: 1
Branch 24794: 1
Branch 24795: 1
Branch 24796: 1
Branch 24797: 1
Branch 24798: 1
Branch 24799: 1
Branch 24800: 1
Branch 24801: 1
Branch 24802: 1
Branch 24803: 1
Branch 24804: 1
Branch 24805: 1
Branch 24806: 1
Branch 24807: 1
Branch 24808: 1
Branch 24809: 1
Branch 24810: 1
Branch 24811: 1
Branch 24812: 1
Branch 24813: 1
Branch 24814: 1
Branch 24815: 1
Branch 24816: 1
Branch 24817: 1
Branch 24818: 1
Branch 24819: 1
Branch 24820: 1
Branch 24821: 1
Branch 24822: 1
Branch 24823: 1
Branch 24824: 1
Branch 24825: 1
Branch 24826: 1
Branch 24827: 1
Branch 24828: 1
Branch 24829: 1
Branch 24830: 1
Branch 24831: 1
Branch 24832: 1
Branch 24833: 1
Branch 24834: 1
Branch 24835: 1
Branch 24836: 1
Branch 24837: 1
Branch 24838: 1
Branch 24839: 1
Branch 24840: 1
Branch 24841: 1
Branch 24842: 1
Branch 24843: 1
Branch 24844: 1
Branch 24845: 1
Branch 24846: 1
Branch 24847: 1
Branch 24848: 1
Branch 24849: 1
Branch 24850: 1
Branch 24851: 1
Branch 24852: 1
Branch 24853: 1
Branch 24854: 1
Branch 24855: 1
Branch 24856: 1
Branch 24857: 1
Branch 24858: 1
Branch 24859: 1
Branch 24860: 1
Branch 24861: 1
Branch 24862: 1
Branch 24863: 1
Branch 24864: 1
Branch 24865: 1
Branch 24866: 1
Branch 24867: 1
Branch 24868: 1
Branch 24869: 1
Branch 24870: 1
Branch 24871: 1
Branch 24872: 1
Branch 24873: 1
Branch 24874: 1
Branch 24875: 1
Branch 24876: 1
Branch 24877: 1
Branch 24878: 1
Branch 24879: 1
Branch 24880: 1
Branch 24881: 1
Branch 24882: 1
Branch 24883: 1
Branch 24884: 1
Branch 24885: 1
Branch 24886: 1
Branch 24887: 1
Branch 24888: 1
Branch 24889: 1
Branch 24890: 1
Branch 24891: 1
Branch 24892: 1
Branch 24893: 1
Branch 24894: 1
Branch 24895: 1
Branch 24896: 1
Branch 24897: 1
Branch 24898: 1
Branch 24899: 1
Branch 24900: 1
Branch 24901: 1
Branch 24902: 1
Branch 24903: 1
Branch 24904: 1
Branch 24905: 1
Branch 24906: 1
Branch 24907: 1
Branch 24908: 1
Branch 24909: 1
Branch 24910: 1
Branch 24911: 1
Branch 24912: 1
Branch 24913: 1
Branch 24914: 1
Branch 24915: 1
Branch 24916: 1
Branch 24917: 1
Branch 24918: 1
Branch 24919: 1
Branch 24920: 1
Branch 24921: 1
Branch 24922: 1
Branch 24923: 1
Branch 24924: 1
Branch 24925: 1
Branch 24926: 1
Branch 24927: 1
Branch 24928: 1
Branch 24929: 1
Branch 24930: 1
Branch 24931: 1
Branch 24932: 1
Branch 24933: 1
Branch 24934: 1
Branch 24935: 1
Branch 24936: 1
Branch 24937: 1
Branch 24938: 1
Branch 24939: 1
Branch 24940: 1
Branch 24941: 1
Branch 24942: 1
Branch 24943: 1
Branch 24944: 1
Branch 24945: 1
Branch 24946: 1
Branch 24947: 1
Branch 24948: 1
Branch 24949: 1
Branch 24950: 1
Branch 24951: 1
Branch 24952: 1
Branch 24953: 1
Branch 24954: 1
Branch 24955: 1
Branch 24956: 1
Branch 24957: 1
Branch 24958: 1
Branch 24959: 1
Branch 24960: 1
Branch 24961: 1
Branch 24962: 1
Branch 24963: 1
Branch 24964: 1
Branch 24965: 1
Branch 24966: 1
Branch 24967: 1
Branch 24968: 1
Branch 24969: 1
Branch 24970: 1
Branch 24971: 1
Branch 24972: 1
Branch 24973: 1
Branch 24974: 1
Branch 24975: 1
Branch 24976: 1
Branch 24977: 1
Branch 24978: 1
Branch 24979: 1
Branch 24980: 1
Branch 24981: 1
Branch 24982: 1
Branch 24983: 1
Branch 24984: 1
Branch 24985: 1
Branch 24986: 1
Branch 24987: 1
Branch 24988: 1
Branch 24989: 1
Branch 24990: 1
Branch 24991: 1
Branch 24992: 1
Branch 24993: 1
Branch 24994: 1
Branch 24995: 1
Branch 24996: 1
Branch 24997: 1
Branch 24998: 1
Branch 24999: 1
Branch 25000: 1
Branch 25001: 1
Branch 25002: 1
Branch 25003: 1
Branch 25004: 1
Branch 25005: 1
Branch 25006: 1
Branch 25007: 1
Branch 25008: 1
Branch 25009: 1
Branch 25010: 1
Branch 25011: 1
Branch 25012: 1
Branch 25013: 1
Branch 25014: 1
Branch 25015: 1
Branch 25016: 1
Branch 25017: 1
Branch 25018: 1
Branch 25019: 1
Branch 25020: 1
Branch 25021: 1
Branch 25022: 1
Branch 25023: 1
Branch 25024: 1
Branch 25025: 1
Branch 25026: 1
Branch 25027: 1
Branch 25028: 1
Branch 25029: 1
Branch 25030: 1
Branch 25031: 1
Branch 25032: 1
Branch 25033: 1
Branch 25034: 1
Branch 25035: 1
Branch 25036: 1
Branch 25037: 1
Branch 25038: 1
Branch 25039: 1
Branch 25040: 1
Branch 25041: 1
Branch 25042: 1
Branch 25043: 1
Branch 25044: 1
Branch 25045: 1
Branch 25046: 1
Branch 25047: 1
Branch 25048: 1
Branch 25049: 1
Branch 25050: 1
Branch 25051: 1
Branch 25052: 1
Branch 25053: 1
Branch 25054: 1
Branch 25055: 1
Branch 25056: 1
Branch 25057: 1
Branch 25058: 1
Branch 25059: 1
Branch 25060: 1
Branch 25061: 1
Branch 25062: 1
Branch 25063: 1
Branch 25064: 1
Branch 25065: 1
Branch 25066: 1
Branch 25067: 1
Branch 25068: 1
Branch 25069: 1
Branch 25070: 1
Branch 25071: 1
Branch 25072: 1
Branch 25073: 1
Branch 25074: 1
Branch 25075: 1
Branch 25076: 1
Branch 25077: 1
Branch 25078: 1
Branch 25079: 1
Branch 25080: 1
Branch 25081: 1
Branch 25082: 1
Branch 25083: 1
Branch 25084: 1
Branch 25085: 1
Branch 25086: 1
Branch 25087: 1
Branch 25088: 1
Branch 25089: 1
Branch 25090: 1
Branch 25091: 1
Branch 25092: 1
Branch 25093: 1
Branch 25094: 1
Branch 25095: 1
Branch 25096: 1
Branch 25097: 1
Branch 25098: 1
Branch 25099: 1
Branch 25100: 1
Branch 25101: 1
Branch 25102: 1
Branch 25103: 1
Branch 25104: 1
Branch 25105: 1
Branch 25106: 1
Branch 25107: 1
Branch 25108: 1
Branch 25109: 1
Branch 25110: 1
Branch 25111: 1
Branch 25112: 1
Branch 25113: 1
Branch 25114: 1
Branch 25115: 1
Branch 25116: 1
Branch 25117: 1
Branch 25118: 1
Branch 25119: 1
Branch 25120: 1
Branch 25121: 1
Branch 25122: 1
Branch 25123: 1
Branch 25124: 1
Branch 25125: 1
Branch 25126: 1
Branch 25127: 1
Branch 25128: 1
Branch 25129: 1
Branch 25130: 1
Branch 25131: 1
Branch 25132: 1
Branch 25133: 1
Branch 25134: 1
Branch 25135: 1
Branch 25136: 1
Branch 25137: 1
Branch 25138: 1
Branch 25139: 1
Branch 25140: 1
Branch 25141: 1
Branch 25142: 1
Branch 25143: 1
Branch 25144: 1
Branch 25145: 1
Branch 25146: 1
Branch 25147: 1
Branch 25148: 1
Branch 25149: 1
Branch 25150: 1
Branch 25151: 1
Branch 25152: 1
Branch 25153: 1
Branch 25154: 1
Branch 25155: 1
Branch 25156: 1
Branch 25157: 1
Branch 25158: 1
Branch 25159: 1
Branch 25160: 1
Branch 25161: 1
Branch 25162: 1
Branch 25163: 1
Branch 25164: 1
Branch 25165: 1
Branch 25166: 1
Branch 25167: 1
Branch 25168: 1
Branch 25169: 1
Branch 25170: 1
Branch 25171: 1
Branch 25172: 1
Branch 25173: 1
Branch 25174: 1
Branch 25175: 1
Branch 25176: 1
Branch 25177: 1
Branch 25178: 1
Branch 25179: 1
Branch 25180: 1
Branch 25181: 1
Branch 25182: 1
Branch 25183: 1
Branch 25184: 1
Branch 25185: 1
Branch 25186: 1
Branch 25187: 1
Branch 25188: 1
Branch 25189: 1
Branch 25190: 1
Branch 25191: 1
Branch 25192: 1
Branch 25193: 1
Branch 25194: 1
Branch 25195: 1
Branch 25196: 1
Branch 25197: 1
Branch 25198: 1
Branch 25199: 1
Branch 25200: 1
Branch 25201: 1
Branch 25202: 1
Branch 25203: 1
Branch 25204: 1
Branch 25205: 1
Branch 25206: 1
Branch 25207: 1
Branch 25208: 1
Branch 25209: 1
Branch 25210: 1
Branch 25211: 1
Branch 25212: 1
Branch 25213: 1
Branch 25214: 1
Branch 25215: 1
Branch 25216: 1
Branch 25217: 1
Branch 25218: 1
Branch 25219: 1
Branch 25220: 1
Branch 25221: 1
Branch 25222: 1
Branch 25223: 1
Branch 25224: 1
Branch 25225: 1
Branch 25226: 1
Branch 25227: 1
Branch 25228: 1
Branch 25229: 1
Branch 25230: 1
Branch 25231: 1
Branch 25232: 1
Branch 25233: 1
Branch 25234: 1
Branch 25235: 1
Branch 25236: 1
Branch 25237: 1
Branch 25238: 1
Branch 25239: 1
Branch 25240: 1
Branch 25241: 1
Branch 25242: 1
Branch 25243: 1
Branch 25244: 1
Branch 25245: 1
Branch 25246: 1
Branch 25247: 1
Branch 25248: 1
Branch 25249: 1
Branch 25250: 1
Branch 25251: 1
Branch 25252: 1
Branch 25253: 1
Branch 25254: 1
Branch 25255: 1
Branch 25256: 1
Branch 25257: 1
Branch 25258: 1
Branch 25259: 1
Branch 25260: 1
Branch 25261: 1
Branch 25262: 1
Branch 25263: 1
Branch 25264: 1
Branch 25265: 1
Branch 25266: 1
Branch 25267: 1
Branch 25268: 1
Branch 25269: 1
Branch 25270: 1
Branch 25271: 1
Branch 25272: 1
Branch 25273: 1
Branch 25274: 1
Branch 25275: 1
Branch 25276: 1
Branch 25277: 1
Branch 25278: 1
Branch 25279: 1
Branch 25280: 1
Branch 25281: 1
Branch 25282: 1
Branch 25283: 1
Branch 25284: 1
Branch 25285: 1
Branch 25286: 1
Branch 25287: 1
Branch 25288: 1
Branch 25289: 1
Branch 25290: 1
Branch 25291: 1
Branch 25292: 1
Branch 25293: 1
Branch 25294: 1
Branch 25295: 1
Branch 25296: 1
Branch 25297: 1
Branch 25298: 1
Branch 25299: 1
Branch 25300: 1
Branch 25301: 1
Branch 25302: 1
Branch 25303: 1
Branch 25304: 1
Branch 25305: 1
Branch 25306: 1
Branch 25307: 1
Branch 25308: 1
Branch 25309: 1
Branch 25310: 1
Branch 25311: 1
Branch 25312: 1
Branch 25313: 1
Branch 25314: 1
Branch 25315: 1
Branch 25316: 1
Branch 25317: 1
Branch 25318: 1
Branch 25319: 1
Branch 25320: 1
Branch 25321: 1
Branch 25322: 1
Branch 25323: 1
Branch 25324: 1
Branch 25325: 1
Branch 25326: 1
Branch 25327: 1
Branch 25328: 1
Branch 25329: 1
Branch 25330: 1
Branch 25331: 1
Branch 25332: 1
Branch 25333: 1
Branch 25334: 1
Branch 25335: 1
Branch 25336: 1
Branch 25337: 1
Branch 25338: 1
Branch 25339: 1
Branch 25340: 1
Branch 25341: 1
Branch 25342: 1
Branch 25343: 1
Branch 25344: 1
Branch 25345: 1
Branch 25346: 1
Branch 25347: 1
Branch 25348: 1
Branch 25349: 1
Branch 25350: 1
Branch 25351: 1
Branch 25352: 1
Branch 25353: 1
Branch 25354: 1
Branch 25355: 1
Branch 25356: 1
Branch 25357: 1
Branch 25358: 1
Branch 25359: 1
Branch 25360: 1
Branch 25361: 1
Branch 25362: 1
Branch 25363: 1
Branch 25364: 1
Branch 25365: 1
Branch 25366: 1
Branch 25367: 1
Branch 25368: 1
Branch 25369: 1
Branch 25370: 1
Branch 25371: 1
Branch 25372: 1
Branch 25373: 1
Branch 25374: 1
Branch 25375: 1
Branch 25376: 1
Branch 25377: 1
Branch 25378: 1
Branch 25379: 1
Branch 25380: 1
Branch 25381: 1
Branch 25382: 1
Branch 25383: 1
Branch 25384: 1
Branch 25385: 1
Branch 25386: 1
Branch 25387: 1
Branch 25388: 1
Branch 25389: 1
Branch 25390: 1
Branch 25391: 1
Branch 25392: 1
Branch 25393: 1
Branch 25394: 1
Branch 25395: 1
Branch 25396: 1
Branch 25397: 1
Branch 25398: 1
Branch 25399: 1
Branch 25400: 1
Branch 25401: 1
Branch 25402: 1
Branch 25403: 1
Branch 25404: 1
Branch 25405: 1
Branch 25406: 1
Branch 25407: 1
Branch 25408: 1
Branch 25409: 1
Branch 25410: 1
Branch 25411: 1
Branch 25412: 1
Branch 25413: 1
Branch 25414: 1
Branch 25415: 1
Branch 25416: 1
Branch 25417: 1
Branch 25418: 1
Branch 25419: 1
Branch 25420: 1
Branch 25421: 1
Branch 25422: 1
Branch 25423: 1
Branch 25424: 1
Branch 25425: 1
Branch 25426: 1
Branch 25427: 1
Branch 25428: 1
Branch 25429: 1
Branch 25430: 1
Branch 25431: 1
Branch 25432: 1
Branch 25433: 1
Branch 25434: 1
Branch 25435: 1
Branch 25436: 1
Branch 25437: 1
Branch 25438: 1
Branch 25439: 1
Branch 25440: 1
Branch 25441: 1
Branch 25442: 1
Branch 25443: 1
Branch 25444: 1
Branch 25445: 1
Branch 25446: 1
Branch 25447: 1
Branch 25448: 1
Branch 25449: 1
Branch 25450: 1
Branch 25451: 1
Branch 25452: 1
Branch 25453: 1
Branch 25454: 1
Branch 25455: 1
Branch 25456: 1
Branch 25457: 1
Branch 25458: 1
Branch 25459: 1
Branch 25460: 1
Branch 25461: 1
Branch 25462: 1
Branch 25463: 1
Branch 25464: 1
Branch 25465: 1
Branch 25466: 1
Branch 25467: 1
Branch 25468: 1
Branch 25469: 1
Branch 25470: 1
Branch 25471: 1
Branch 25472: 1
Branch 25473: 1
Branch 25474: 1
Branch 25475: 1
Branch 25476: 1
Branch 25477: 1
Branch 25478: 1
Branch 25479: 1
Branch 25480: 1
Branch 25481: 1
Branch 25482: 1
Branch 25483: 1
Branch 25484: 1
Branch 25485: 1
Branch 25486: 1
Branch 25487: 1
Branch 25488: 1
Branch 25489: 1
Branch 25490: 1
Branch 25491: 1
Branch 25492: 1
Branch 25493: 1
Branch 25494: 1
Branch 25495: 1
Branch 25496: 1
Branch 25497: 1
Branch 25498: 1
Branch 25499: 1
Branch 25500: 1
Branch 25501: 1
Branch 25502: 1
Branch 25503: 1
Branch 25504: 1
Branch 25505: 1
Branch 25506: 1
Branch 25507: 1
Branch 25508: 1
Branch 25509: 1
Branch 25510: 1
Branch 25511: 1
Branch 25512: 1
Branch 25513: 1
Branch 25514: 1
Branch 25515: 1
Branch 25516: 1
Branch 25517: 1
Branch 25518: 1
Branch 25519: 1
Branch 25520: 1
Branch 25521: 1
Branch 25522: 1
Branch 25523: 1
Branch 25524: 1
Branch 25525: 1
Branch 25526: 1
Branch 25527: 1
Branch 25528: 1
Branch 25529: 1
Branch 25530: 1
Branch 25531: 1
Branch 25532: 1
Branch 25533: 1
Branch 25534: 1
Branch 25535: 1
Branch 25536: 1
Branch 25537: 1
Branch 25538: 1
Branch 25539: 1
Branch 25540: 1
Branch 25541: 1
Branch 25542: 1
Branch 25543: 1
Branch 25544: 1
Branch 25545: 1
Branch 25546: 1
Branch 25547: 1
Branch 25548: 1
Branch 25549: 1
Branch 25550: 1
Branch 25551: 1
Branch 25552: 1
Branch 25553: 1
Branch 25554: 1
Branch 25555: 1
Branch 25556: 1
Branch 25557: 1
Branch 25558: 1
Branch 25559: 1
Branch 25560: 1
Branch 25561: 1
Branch 25562: 1
Branch 25563: 1
Branch 25564: 1
Branch 25565: 1
Branch 25566: 1
Branch 25567: 1
Branch 25568: 1
Branch 25569: 1
Branch 25570: 1
Branch 25571: 1
Branch 25572: 1
Branch 25573: 1
Branch 25574: 1
Branch 25575: 1
Branch 25576: 1
Branch 25577: 1
Branch 25578: 1
Branch 25579: 1
Branch 25580: 1
Branch 25581: 1
Branch 25582: 1
Branch 25583: 1
Branch 25584: 1
Branch 25585: 1
Branch 25586: 1
Branch 25587: 1
Branch 25588: 1
Branch 25589: 1
Branch 25590: 1
Branch 25591: 1
Branch 25592: 1
Branch 25593: 1
Branch 25594: 1
Branch 25595: 1
Branch 25596: 1
Branch 25597: 1
Branch 25598: 1
Branch 25599: 1
Branch 25600: 1
Branch 25601: 1
Branch 25602: 1
Branch 25603: 1
Branch 25604: 1
Branch 25605: 1
Branch 25606: 1
Branch 25607: 1
Branch 25608: 1
Branch 25609: 1
Branch 25610: 1
Branch 25611: 1
Branch 25612: 1
Branch 25613: 1
Branch 25614: 1
Branch 25615: 1
Branch 25616: 1
Branch 25617: 1
Branch 25618: 1
Branch 25619: 1
Branch 25620: 1
Branch 25621: 1
Branch 25622: 1
Branch 25623: 1
Branch 25624: 1
Branch 25625: 1
Branch 25626: 1
Branch 25627: 1
Branch 25628: 1
Branch 25629: 1
Branch 25630: 1
Branch 25631: 1
Branch 25632: 1
Branch 25633: 1
Branch 25634: 1
Branch 25635: 1
Branch 25636: 1
Branch 25637: 1
Branch 25638: 1
Branch 25639: 1
Branch 25640: 1
Branch 25641: 1
Branch 25642: 1
Branch 25643: 1
Branch 25644: 1
Branch 25645: 1
Branch 25646: 1
Branch 25647: 1
Branch 25648: 1
Branch 25649: 1
Branch 25650: 1
Branch 25651: 1
Branch 25652: 1
Branch 25653: 1
Branch 25654: 1
Branch 25655: 1
Branch 25656: 1
Branch 25657: 1
Branch 25658: 1
Branch 25659: 1
Branch 25660: 1
Branch 25661: 1
Branch 25662: 1
Branch 25663: 1
Branch 25664: 1
Branch 25665: 1
Branch 25666: 1
Branch 25667: 1
Branch 25668: 1
Branch 25669: 1
Branch 25670: 1
Branch 25671: 1
Branch 25672: 1
Branch 25673: 1
Branch 25674: 1
Branch 25675: 1
Branch 25676: 1
Branch 25677: 1
Branch 25678: 1
Branch 25679: 1
Branch 25680: 1
Branch 25681: 1
Branch 25682: 1
Branch 25683: 1
Branch 25684: 1
Branch 25685: 1
Branch 25686: 1
Branch 25687: 1
Branch 25688: 1
Branch 25689: 1
Branch 25690: 1
Branch 25691: 1
Branch 25692: 1
Branch 25693: 1
Branch 25694: 1
Branch 25695: 1
Branch 25696: 1
Branch 25697: 1
Branch 25698: 1
Branch 25699: 1
Branch 25700: 1
Branch 25701: 1
Branch 25702: 1
Branch 25703: 1
Branch 25704: 1
Branch 25705: 1
Branch 25706: 1
Branch 25707: 1
Branch 25708: 1
Branch 25709: 1
Branch 25710: 1
Branch 25711: 1
Branch 25712: 1
Branch 25713: 1
Branch 25714: 1
Branch 25715: 1
Branch 25716: 1
Branch 25717: 1
Branch 25718: 1
Branch 25719: 1
Branch 25720: 1
Branch 25721: 1
Branch 25722: 1
Branch 25723: 1
Branch 25724: 1
Branch 25725: 1
Branch 25726: 1
Branch 25727: 1
Branch 25728: 1
Branch 25729: 1
Branch 25730: 1
Branch 25731: 1
Branch 25732: 1
Branch 25733: 1
Branch 25734: 1
Branch 25735: 1
Branch 25736: 1
Branch 25737: 1
Branch 25738: 1
Branch 25739: 1
Branch 25740: 1
Branch 25741: 1
Branch 25742: 1
Branch 25743: 1
Branch 25744: 1
Branch 25745: 1
Branch 25746: 1
Branch 25747: 1
Branch 25748: 1
Branch 25749: 1
Branch 25750: 1
Branch 25751: 1
Branch 25752: 1
Branch 25753: 1
Branch 25754: 1
Branch 25755: 1
Branch 25756: 1
Branch 25757: 1
Branch 25758: 1
Branch 25759: 1
Branch 25760: 1
Branch 25761: 1
Branch 25762: 1
Branch 25763: 1
Branch 25764: 1
Branch 25765: 1
Branch 25766: 1
Branch 25767: 1
Branch 25768: 1
Branch 25769: 1
Branch 25770: 1
Branch 25771: 1
Branch 25772: 1
Branch 25773: 1
Branch 25774: 1
Branch 25775: 1
Branch 25776: 1
Branch 25777: 1
Branch 25778: 1
Branch 25779: 1
Branch 25780: 1
Branch 25781: 1
Branch 25782: 1
Branch 25783: 1
Branch 25784: 1
Branch 25785: 1
Branch 25786: 1
Branch 25787: 1
Branch 25788: 1
Branch 25789: 1
Branch 25790: 1
Branch 25791: 1
Branch 25792: 1
Branch 25793: 1
Branch 25794: 1
Branch 25795: 1
Branch 25796: 1
Branch 25797: 1
Branch 25798: 1
Branch 25799: 1
Branch 25800: 1
Branch 25801: 1
Branch 25802: 1
Branch 25803: 1
Branch 25804: 1
Branch 25805: 1
Branch 25806: 1
Branch 25807: 1
Branch 25808: 1
Branch 25809: 1
Branch 25810: 1
Branch 25811: 1
Branch 25812: 1
Branch 25813: 1
Branch 25814: 1
Branch 25815: 1
Branch 25816: 1
Branch 25817: 1
Branch 25818: 1
Branch 25819: 1
Branch 25820: 1
Branch 25821: 1
Branch 25822: 1
Branch 25823: 1
Branch 25824: 1
Branch 25825: 1
Branch 25826: 1
Branch 25827: 1
Branch 25828: 1
Branch 25829: 1
Branch 25830: 1
Branch 25831: 1
Branch 25832: 1
Branch 25833: 1
Branch 25834: 1
Branch 25835: 1
Branch 25836: 1
Branch 25837: 1
Branch 25838: 1
Branch 25839: 1
Branch 25840: 1
Branch 25841: 1
Branch 25842: 1
Branch 25843: 1
Branch 25844: 1
Branch 25845: 1
Branch 25846: 1
Branch 25847: 1
Branch 25848: 1
Branch 25849: 1
Branch 25850: 1
Branch 25851: 1
Branch 25852: 1
Branch 25853: 1
Branch 25854: 1
Branch 25855: 1
Branch 25856: 1
Branch 25857: 1
Branch 25858: 1
Branch 25859: 1
Branch 25860: 1
Branch 25861: 1
Branch 25862: 1
Branch 25863: 1
Branch 25864: 1
Branch 25865: 1
Branch 25866: 1
Branch 25867: 1
Branch 25868: 1
Branch 25869: 1
Branch 25870: 1
Branch 25871: 1
Branch 25872: 1
Branch 25873: 1
Branch 25874: 1
Branch 25875: 1
Branch 25876: 1
Branch 25877: 1
Branch 25878: 1
Branch 25879: 1
Branch 25880: 1
Branch 25881: 1
Branch 25882: 1
Branch 25883: 1
Branch 25884: 1
Branch 25885: 1
Branch 25886: 1
Branch 25887: 1
Branch 25888: 1
Branch 25889: 1
Branch 25890: 1
Branch 25891: 1
Branch 25892: 1
Branch 25893: 1
Branch 25894: 1
Branch 25895: 1
Branch 25896: 1
Branch 25897: 1
Branch 25898: 1
Branch 25899: 1
Branch 25900: 1
Branch 25901: 1
Branch 25902: 1
Branch 25903: 1
Branch 25904: 1
Branch 25905: 1
Branch 25906: 1
Branch 25907: 1
Branch 25908: 1
Branch 25909: 1
Branch 25910: 1
Branch 25911: 1
Branch 25912: 1
Branch 25913: 1
Branch 25914: 1
Branch 25915: 1
Branch 25916: 1
Branch 25917: 1
Branch 25918: 1
Branch 25919: 1
Branch 25920: 1
Branch 25921: 1
Branch 25922: 1
Branch 25923: 1
Branch 25924: 1
Branch 25925: 1
Branch 25926: 1
Branch 25927: 1
Branch 25928: 1
Branch 25929: 1
Branch 25930: 1
Branch 25931: 1
Branch 25932: 1
Branch 25933: 1
Branch 25934: 1
Branch 25935: 1
Branch 25936: 1
Branch 25937: 1
Branch 25938: 1
Branch 25939: 1
Branch 25940: 1
Branch 25941: 1
Branch 25942: 1
Branch 25943: 1
Branch 25944: 1
Branch 25945: 1
Branch 25946: 1
Branch 25947: 1
Branch 25948: 1
Branch 25949: 1
Branch 25950: 1
Branch 25951: 1
Branch 25952: 1
Branch 25953: 1
Branch 25954: 1
Branch 25955: 1
Branch 25956: 1
Branch 25957: 1
Branch 25958: 1
Branch 25959: 1
Branch 25960: 1
Branch 25961: 1
Branch 25962: 1
Branch 25963: 1
Branch 25964: 1
Branch 25965: 1
Branch 25966: 1
Branch 25967: 1
Branch 25968: 1
Branch 25969: 1
Branch 25970: 1
Branch 25971: 1
Branch 25972: 1
Branch 25973: 1
Branch 25974: 1
Branch 25975: 1
Branch 25976: 1
Branch 25977: 1
Branch 25978: 1
Branch 25979: 1
Branch 25980: 1
Branch 25981: 1
Branch 25982: 1
Branch 25983: 1
Branch 25984: 1
Branch 25985: 1
Branch 25986: 1
Branch 25987: 1
Branch 25988: 1
Branch 25989: 1
Branch 25990: 1
Branch 25991: 1
Branch 25992: 1
Branch 25993: 1
Branch 25994: 1
Branch 25995: 1
Branch 25996: 1
Branch 25997: 1
Branch 25998: 1
Branch 25999: 1
Branch 26000: 1
Branch 26001: 1
Branch 26002: 1
Branch 26003: 1
Branch 26004: 1
Branch 26005: 1
Branch 26006: 1
Branch 26007: 1
Branch 26008: 1
Branch 26009: 1
Branch 26010: 1
Branch 26011: 1
Branch 26012: 1
Branch 26013: 1
Branch 26014: 1
Branch 26015: 1
Branch 26016: 1
Branch 26017: 1
Branch 26018: 1
Branch 26019: 1
Branch 26020: 1
Branch 26021: 1
Branch 26022: 1
Branch 26023: 1
Branch 26024: 1
Branch 26025: 1
Branch 26026: 1
Branch 26027: 1
Branch 26028: 1
Branch 26029: 1
Branch 26030: 1
Branch 26031: 1
Branch 26032: 1
Branch 26033: 1
Branch 26034: 1
Branch 26035: 1
Branch 26036: 1
Branch 26037: 1
Branch 26038: 1
Branch 26039: 1
Branch 26040: 1
Branch 26041: 1
Branch 26042: 1
Branch 26043: 1
Branch 26044: 1
Branch 26045: 1
Branch 26046: 1
Branch 26047: 1
Branch 26048: 1
Branch 26049: 1
Branch 26050: 1
Branch 26051: 1
Branch 26052: 1
Branch 26053: 1
Branch 26054: 1
Branch 26055: 1
Branch 26056: 1
Branch 26057: 1
Branch 26058: 1
Branch 26059: 1
Branch 26060: 1
Branch 26061: 1
Branch 26062: 1
Branch 26063: 1
Branch 26064: 1
Branch 26065: 1
Branch 26066: 1
Branch 26067: 1
Branch 26068: 1
Branch 26069: 1
Branch 26070: 1
Branch 26071: 1
Branch 26072: 1
Branch 26073: 1
Branch 26074: 1
Branch 26075: 1
Branch 26076: 1
Branch 26077: 1
Branch 26078: 1
Branch 26079: 1
Branch 26080: 1
Branch 26081: 1
Branch 26082: 1
Branch 26083: 1
Branch 26084: 1
Branch 26085: 1
Branch 26086: 1
Branch 26087: 1
Branch 26088: 1
Branch 26089: 1
Branch 26090: 1
Branch 26091: 1
Branch 26092: 1
Branch 26093: 1
Branch 26094: 1
Branch 26095: 1
Branch 26096: 1
Branch 26097: 1
Branch 26098: 1
Branch 26099: 1
Branch 26100: 1
Branch 26101: 1
Branch 26102: 1
Branch 26103: 1
Branch 26104: 1
Branch 26105: 1
Branch 26106: 1
Branch 26107: 1
Branch 26108: 1
Branch 26109: 1
Branch 26110: 1
Branch 26111: 1
Branch 26112: 1
Branch 26113: 1
Branch 26114: 1
Branch 26115: 1
Branch 26116: 1
Branch 26117: 1
Branch 26118: 1
Branch 26119: 1
Branch 26120: 1
Branch 26121: 1
Branch 26122: 1
Branch 26123: 1
Branch 26124: 1
Branch 26125: 1
Branch 26126: 1
Branch 26127: 1
Branch 26128: 1
Branch 26129: 1
Branch 26130: 1
Branch 26131: 1
Branch 26132: 1
Branch 26133: 1
Branch 26134: 1
Branch 26135: 1
Branch 26136: 1
Branch 26137: 1
Branch 26138: 1
Branch 26139: 1
Branch 26140: 1
Branch 26141: 1
Branch 26142: 1
Branch 26143: 1
Branch 26144: 1
Branch 26145: 1
Branch 26146: 1
Branch 26147: 1
Branch 26148: 1
Branch 26149: 1
Branch 26150: 1
Branch 26151: 1
Branch 26152: 1
Branch 26153: 1
Branch 26154: 1
Branch 26155: 1
Branch 26156: 1
Branch 26157: 1
Branch 26158: 1
Branch 26159: 1
Branch 26160: 1
Branch 26161: 1
Branch 26162: 1
Branch 26163: 1
Branch 26164: 1
Branch 26165: 1
Branch 26166: 1
Branch 26167: 1
Branch 26168: 1
Branch 26169: 1
Branch 26170: 1
Branch 26171: 1
Branch 26172: 1
Branch 26173: 1
Branch 26174: 1
Branch 26175: 1
Branch 26176: 1
Branch 26177: 1
Branch 26178: 1
Branch 26179: 1
Branch 26180: 1
Branch 26181: 1
Branch 26182: 1
Branch 26183: 1
Branch 26184: 1
Branch 26185: 1
Branch 26186: 1
Branch 26187: 1
Branch 26188: 1
Branch 26189: 1
Branch 26190: 1
Branch 26191: 1
Branch 26192: 1
Branch 26193: 1
Branch 26194: 1
Branch 26195: 1
Branch 26196: 1
Branch 26197: 1
Branch 26198: 1
Branch 26199: 1
Branch 26200: 1
Branch 26201: 1
Branch 26202: 1
Branch 26203: 1
Branch 26204: 1
Branch 26205: 1
Branch 26206: 1
Branch 26207: 1
Branch 26208: 1
Branch 26209: 1
Branch 26210: 1
Branch 26211: 1
Branch 26212: 1
Branch 26213: 1
Branch 26214: 1
Branch 26215: 1
Branch 26216: 1
Branch 26217: 1
Branch 26218: 1
Branch 26219: 1
Branch 26220: 1
Branch 26221: 1
Branch 26222: 1
Branch 26223: 1
Branch 26224: 1
Branch 26225: 1
Branch 26226: 1
Branch 26227: 1
Branch 26228: 1
Branch 26229: 1
Branch 26230: 1
Branch 26231: 1
Branch 26232: 1
Branch 26233: 1
Branch 26234: 1
Branch 26235: 1
Branch 26236: 1
Branch 26237: 1
Branch 26238: 1
Branch 26239: 1
Branch 26240: 1
Branch 26241: 1
Branch 26242: 1
Branch 26243: 1
Branch 26244: 1
Branch 26245: 1
Branch 26246: 1
Branch 26247: 1
Branch 26248: 1
Branch 26249: 1
Branch 26250: 1
Branch 26251: 1
Branch 26252: 1
Branch 26253: 1
Branch 26254: 1
Branch 26255: 1
Branch 26256: 1
Branch 26257: 1
Branch 26258: 1
Branch 26259: 1
Branch 26260: 1
Branch 26261: 1
Branch 26262: 1
Branch 26263: 1
Branch 26264: 1
Branch 26265: 1
Branch 26266: 1
Branch 26267: 1
Branch 26268: 1
Branch 26269: 1
Branch 26270: 1
Branch 26271: 1
Branch 26272: 1
Branch 26273: 1
Branch 26274: 1
Branch 26275: 1
Branch 26276: 1
Branch 26277: 1
Branch 26278: 1
Branch 26279: 1
Branch 26280: 1
Branch 26281: 1
Branch 26282: 1
Branch 26283: 1
Branch 26284: 1
Branch 26285: 1
Branch 26286: 1
Branch 26287: 1
Branch 26288: 1
Branch 26289: 1
Branch 26290: 1
Branch 26291: 1
Branch 26292: 1
Branch 26293: 1
Branch 26294: 1
Branch 26295: 1
Branch 26296: 1
Branch 26297: 1
Branch 26298: 1
Branch 26299: 1
Branch 26300: 1
Branch 26301: 1
Branch 26302: 1
Branch 26303: 1
Branch 26304: 1
Branch 26305: 1
Branch 26306: 1
Branch 26307: 1
Branch 26308: 1
Branch 26309: 1
Branch 26310: 1
Branch 26311: 1
Branch 26312: 1
Branch 26313: 1
Branch 26314: 1
Branch 26315: 1
Branch 26316: 1
Branch 26317: 1
Branch 26318: 1
Branch 26319: 1
Branch 26320: 1
Branch 26321: 1
Branch 26322: 1
Branch 26323: 1
Branch 26324: 1
Branch 26325: 1
Branch 26326: 1
Branch 26327: 1
Branch 26328: 1
Branch 26329: 1
Branch 26330: 1
Branch 26331: 1
Branch 26332: 1
Branch 26333: 1
Branch 26334: 1
Branch 26335: 1
Branch 26336: 1
Branch 26337: 1
Branch 26338: 1
Branch 26339: 1
Branch 26340: 1
Branch 26341: 1
Branch 26342: 1
Branch 26343: 1
Branch 26344: 1
Branch 26345: 1
Branch 26346: 1
Branch 26347: 1
Branch 26348: 1
Branch 26349: 1
Branch 26350: 1
Branch 26351: 1
Branch 26352: 1
Branch 26353: 1
Branch 26354: 1
Branch 26355: 1
Branch 26356: 1
Branch 26357: 1
Branch 26358: 1
Branch 26359: 1
Branch 26360: 1
Branch 26361: 1
Branch 26362: 1
Branch 26363: 1
Branch 26364: 1
Branch 26365: 1
Branch 26366: 1
Branch 26367: 1
Branch 26368: 1
Branch 26369: 1
Branch 26370: 1
Branch 26371: 1
Branch 26372: 1
Branch 26373: 1
Branch 26374: 1
Branch 26375: 1
Branch 26376: 1
Branch 26377: 1
Branch 26378: 1
Branch 26379: 1
Branch 26380: 1
Branch 26381: 1
Branch 26382: 1
Branch 26383: 1
Branch 26384: 1
Branch 26385: 1
Branch 26386: 1
Branch 26387: 1
Branch 26388: 1
Branch 26389: 1
Branch 26390: 1
Branch 26391: 1
Branch 26392: 1
Branch 26393: 1
Branch 26394: 1
Branch 26395: 1
Branch 26396: 1
Branch 26397: 1
Branch 26398: 1
Branch 26399: 1
Branch 26400: 1
Branch 26401: 1
Branch 26402: 1
Branch 26403: 1
Branch 26404: 1
Branch 26405: 1
Branch 26406: 1
Branch 26407: 1
Branch 26408: 1
Branch 26409: 1
Branch 26410: 1
Branch 26411: 1
Branch 26412: 1
Branch 26413: 1
Branch 26414: 1
Branch 26415: 1
Branch 26416: 1
Branch 26417: 1
Branch 26418: 1
Branch 26419: 1
Branch 26420: 1
Branch 26421: 1
Branch 26422: 1
Branch 26423: 1
Branch 26424: 1
Branch 26425: 1
Branch 26426: 1
Branch 26427: 1
Branch 26428: 1
Branch 26429: 1
Branch 26430: 1
Branch 26431: 1
Branch 26432: 1
Branch 26433: 1
Branch 26434: 1
Branch 26435: 1
Branch 26436: 1
Branch 26437: 1
Branch 26438: 1
Branch 26439: 1
Branch 26440: 1
Branch 26441: 1
Branch 26442: 1
Branch 26443: 1
Branch 26444: 1
Branch 26445: 1
Branch 26446: 1
Branch 26447: 1
Branch 26448: 1
Branch 26449: 1
Branch 26450: 1
Branch 26451: 1
Branch 26452: 1
Branch 26453: 1
Branch 26454: 1
Branch 26455: 1
Branch 26456: 1
Branch 26457: 1
Branch 26458: 1
Branch 26459: 1
Branch 26460: 1
Branch 26461: 1
Branch 26462: 1
Branch 26463: 1
Branch 26464: 1
Branch 26465: 1
Branch 26466: 1
Branch 26467: 1
Branch 26468: 1
Branch 26469: 1
Branch 26470: 1
Branch 26471: 1
Branch 26472: 1
Branch 26473: 1
Branch 26474: 1
Branch 26475: 1
Branch 26476: 1
Branch 26477: 1
Branch 26478: 1
Branch 26479: 1
Branch 26480: 1
Branch 26481: 1
Branch 26482: 1
Branch 26483: 1
Branch 26484: 1
Branch 26485: 1
Branch 26486: 1
Branch 26487: 1
Branch 26488: 1
Branch 26489: 1
Branch 26490: 1
Branch 26491: 1
Branch 26492: 1
Branch 26493: 1
Branch 26494: 1
Branch 26495: 1
Branch 26496: 1
Branch 26497: 1
Branch 26498: 1
Branch 26499: 1
Branch 26500: 1
Branch 26501: 1
Branch 26502: 1
Branch 26503: 1
Branch 26504: 1
Branch 26505: 1
Branch 26506: 1
Branch 26507: 1
Branch 26508: 1
Branch 26509: 1
Branch 26510: 1
Branch 26511: 1
Branch 26512: 1
Branch 26513: 1
Branch 26514: 1
Branch 26515: 1
Branch 26516: 1
Branch 26517: 1
Branch 26518: 1
Branch 26519: 1
Branch 26520: 1
Branch 26521: 1
Branch 26522: 1
Branch 26523: 1
Branch 26524: 1
Branch 26525: 1
Branch 26526: 1
Branch 26527: 1
Branch 26528: 1
Branch 26529: 1
Branch 26530: 1
Branch 26531: 1
Branch 26532: 1
Branch 26533: 1
Branch 26534: 1
Branch 26535: 1
Branch 26536: 1
Branch 26537: 1
Branch 26538: 1
Branch 26539: 1
Branch 26540: 1
Branch 26541: 1
Branch 26542: 1
Branch 26543: 1
Branch 26544: 1
Branch 26545: 1
Branch 26546: 1
Branch 26547: 1
Branch 26548: 1
Branch 26549: 1
Branch 26550: 1
Branch 26551: 1
Branch 26552: 1
Branch 26553: 1
Branch 26554: 1
Branch 26555: 1
Branch 26556: 1
Branch 26557: 1
Branch 26558: 1
Branch 26559: 1
Branch 26560: 1
Branch 26561: 1
Branch 26562: 1
Branch 26563: 1
Branch 26564: 1
Branch 26565: 1
Branch 26566: 1
Branch 26567: 1
Branch 26568: 1
Branch 26569: 1
Branch 26570: 1
Branch 26571: 1
Branch 26572: 1
Branch 26573: 1
Branch 26574: 1
Branch 26575: 1
Branch 26576: 1
Branch 26577: 1
Branch 26578: 1
Branch 26579: 1
Branch 26580: 1
Branch 26581: 1
Branch 26582: 1
Branch 26583: 1
Branch 26584: 1
Branch 26585: 1
Branch 26586: 1
Branch 26587: 1
Branch 26588: 1
Branch 26589: 1
Branch 26590: 1
Branch 26591: 1
Branch 26592: 1
Branch 26593: 1
Branch 26594: 1
Branch 26595: 1
Branch 26596: 1
Branch 26597: 1
Branch 26598: 1
Branch 26599: 1
Branch 26600: 1
Branch 26601: 1
Branch 26602: 1
Branch 26603: 1
Branch 26604: 1
Branch 26605: 1
Branch 26606: 1
Branch 26607: 1
Branch 26608: 1
Branch 26609: 1
Branch 26610: 1
Branch 26611: 1
Branch 26612: 1
Branch 26613: 1
Branch 26614: 1
Branch 26615: 1
Branch 26616: 1
Branch 26617: 1
Branch 26618: 1
Branch 26619: 1
Branch 26620: 1
Branch 26621: 1
Branch 26622: 1
Branch 26623: 1
Branch 26624: 1
Branch 26625: 1
Branch 26626: 1
Branch 26627: 1
Branch 26628: 1
Branch 26629: 1
Branch 26630: 1
Branch 26631: 1
Branch 26632: 1
Branch 26633: 1
Branch 26634: 1
Branch 26635: 1
Branch 26636: 1
Branch 26637: 1
Branch 26638: 1
Branch 26639: 1
Branch 26640: 1
Branch 26641: 1
Branch 26642: 1
Branch 26643: 1
Branch 26644: 1
Branch 26645: 1
Branch 26646: 1
Branch 26647: 1
Branch 26648: 1
Branch 26649: 1
Branch 26650: 1
Branch 26651: 1
Branch 26652: 1
Branch 26653: 1
Branch 26654: 1
Branch 26655: 1
Branch 26656: 1
Branch 26657: 1
Branch 26658: 1
Branch 26659: 1
Branch 26660: 1
Branch 26661: 1
Branch 26662: 1
Branch 26663: 1
Branch 26664: 1
Branch 26665: 1
Branch 26666: 1
Branch 26667: 1
Branch 26668: 1
Branch 26669: 1
Branch 26670: 1
Branch 26671: 1
Branch 26672: 1
Branch 26673: 1
Branch 26674: 1
Branch 26675: 1
Branch 26676: 1
Branch 26677: 1
Branch 26678: 1
Branch 26679: 1
Branch 26680: 1
Branch 26681: 1
Branch 26682: 1
Branch 26683: 1
Branch 26684: 1
Branch 26685: 1
Branch 26686: 1
Branch 26687: 1
Branch 26688: 1
Branch 26689: 1
Branch 26690: 1
Branch 26691: 1
Branch 26692: 1
Branch 26693: 1
Branch 26694: 1
Branch 26695: 1
Branch 26696: 1
Branch 26697: 1
Branch 26698: 1
Branch 26699: 1
Branch 26700: 1
Branch 26701: 1
Branch 26702: 1
Branch 26703: 1
Branch 26704: 1
Branch 26705: 1
Branch 26706: 1
Branch 26707: 1
Branch 26708: 1
Branch 26709: 1
Branch 26710: 1
Branch 26711: 1
Branch 26712: 1
Branch 26713: 1
Branch 26714: 1
Branch 26715: 1
Branch 26716: 1
Branch 26717: 1
Branch 26718: 1
Branch 26719: 1
Branch 26720: 1
Branch 26721: 1
Branch 26722: 1
Branch 26723: 1
Branch 26724: 1
Branch 26725: 1
Branch 26726: 1
Branch 26727: 1
Branch 26728: 1
Branch 26729: 1
Branch 26730: 1
Branch 26731: 1
Branch 26732: 1
Branch 26733: 1
Branch 26734: 1
Branch 26735: 1
Branch 26736: 1
Branch 26737: 1
Branch 26738: 1
Branch 26739: 1
Branch 26740: 1
Branch 26741: 1
Branch 26742: 1
Branch 26743: 1
Branch 26744: 1
Branch 26745: 1
Branch 26746: 1
Branch 26747: 1
Branch 26748: 1
Branch 26749: 1
Branch 26750: 1
Branch 26751: 1
Branch 26752: 1
Branch 26753: 1
Branch 26754: 1
Branch 26755: 1
Branch 26756: 1
Branch 26757: 1
Branch 26758: 1
Branch 26759: 1
Branch 26760: 1
Branch 26761: 1
Branch 26762: 1
Branch 26763: 1
Branch 26764: 1
Branch 26765: 1
Branch 26766: 1
Branch 26767: 1
Branch 26768: 1
Branch 26769: 1
Branch 26770: 1
Branch 26771: 1
Branch 26772: 1
Branch 26773: 1
Branch 26774: 1
Branch 26775: 1
Branch 26776: 1
Branch 26777: 1
Branch 26778: 1
Branch 26779: 1
Branch 26780: 1
Branch 26781: 1
Branch 26782: 1
Branch 26783: 1
Branch 26784: 1
Branch 26785: 1
Branch 26786: 1
Branch 26787: 1
Branch 26788: 1
Branch 26789: 1
Branch 26790: 1
Branch 26791: 1
Branch 26792: 1
Branch 26793: 1
Branch 26794: 1
Branch 26795: 1
Branch 26796: 1
Branch 26797: 1
Branch 26798: 1
Branch 26799: 1
Branch 26800: 1
Branch 26801: 1
Branch 26802: 1
Branch 26803: 1
Branch 26804: 1
Branch 26805: 1
Branch 26806: 1
Branch 26807: 1
Branch 26808: 1
Branch 26809: 1
Branch 26810: 1
Branch 26811: 1
Branch 26812: 1
Branch 26813: 1
Branch 26814: 1
Branch 26815: 1
Branch 26816: 1
Branch 26817: 1
Branch 26818: 1
Branch 26819: 1
Branch 26820: 1
Branch 26821: 1
Branch 26822: 1
Branch 26823: 1
Branch 26824: 1
Branch 26825: 1
Branch 26826: 1
Branch 26827: 1
Branch 26828: 1
Branch 26829: 1
Branch 26830: 1
Branch 26831: 1
Branch 26832: 1
Branch 26833: 1
Branch 26834: 1
Branch 26835: 1
Branch 26836: 1
Branch 26837: 1
Branch 26838: 1
Branch 26839: 1
Branch 26840: 1
Branch 26841: 1
Branch 26842: 1
Branch 26843: 1
Branch 26844: 1
Branch 26845: 1
Branch 26846: 1
Branch 26847: 1
Branch 26848: 1
Branch 26849: 1
Branch 26850: 1
Branch 26851: 1
Branch 26852: 1
Branch 26853: 1
Branch 26854: 1
Branch 26855: 1
Branch 26856: 1
Branch 26857: 1
Branch 26858: 1
Branch 26859: 1
Branch 26860: 1
Branch 26861: 1
Branch 26862: 1
Branch 26863: 1
Branch 26864: 1
Branch 26865: 1
Branch 26866: 1
Branch 26867: 1
Branch 26868: 1
Branch 26869: 1
Branch 26870: 1
Branch 26871: 1
Branch 26872: 1
Branch 26873: 1
Branch 26874: 1
Branch 26875: 1
Branch 26876: 1
Branch 26877: 1
Branch 26878: 1
Branch 26879: 1
Branch 26880: 1
Branch 26881: 1
Branch 26882: 1
Branch 26883: 1
Branch 26884: 1
Branch 26885: 1
Branch 26886: 1
Branch 26887: 1
Branch 26888: 1
Branch 26889: 1
Branch 26890: 1
Branch 26891: 1
Branch 26892: 1
Branch 26893: 1
Branch 26894: 1
Branch 26895: 1
Branch 26896: 1
Branch 26897: 1
Branch 26898: 1
Branch 26899: 1
Branch 26900: 1
Branch 26901: 1
Branch 26902: 1
Branch 26903: 1
Branch 26904: 1
Branch 26905: 1
Branch 26906: 1
Branch 26907: 1
Branch 26908: 1
Branch 26909: 1
Branch 26910: 1
Branch 26911: 1
Branch 26912: 1
Branch 26913: 1
Branch 26914: 1
Branch 26915: 1
Branch 26916: 1
Branch 26917: 1
Branch 26918: 1
Branch 26919: 1
Branch 26920: 1
Branch 26921: 1
Branch 26922: 1
Branch 26923: 1
Branch 26924: 1
Branch 26925: 1
Branch 26926: 1
Branch 26927: 1
Branch 26928: 1
Branch 26929: 1
Branch 26930: 1
Branch 26931: 1
Branch 26932: 1
Branch 26933: 1
Branch 26934: 1
Branch 26935: 1
Branch 26936: 1
Branch 26937: 1
Branch 26938: 1
Branch 26939: 1
Branch 26940: 1
Branch 26941: 1
Branch 26942: 1
Branch 26943: 1
Branch 26944: 1
Branch 26945: 1
Branch 26946: 1
Branch 26947: 1
Branch 26948: 1
Branch 26949: 1
Branch 26950: 1
Branch 26951: 1
Branch 26952: 1
Branch 26953: 1
Branch 26954: 1
Branch 26955: 1
Branch 26956: 1
Branch 26957: 1
Branch 26958: 1
Branch 26959: 1
Branch 26960: 1
Branch 26961: 1
Branch 26962: 1
Branch 26963: 1
Branch 26964: 1
Branch 26965: 1
Branch 26966: 1
Branch 26967: 1
Branch 26968: 1
Branch 26969: 1
Branch 26970: 1
Branch 26971: 1
Branch 26972: 1
Branch 26973: 1
Branch 26974: 1
Branch 26975: 1
Branch 26976: 1
Branch 26977: 1
Branch 26978: 1
Branch 26979: 1
Branch 26980: 1
Branch 26981: 1
Branch 26982: 1
Branch 26983: 1
Branch 26984: 1
Branch 26985: 1
Branch 26986: 1
Branch 26987: 1
Branch 26988: 1
Branch 26989: 1
Branch 26990: 1
Branch 26991: 1
Branch 26992: 1
Branch 26993: 1
Branch 26994: 1
Branch 26995: 1
Branch 26996: 1
Branch 26997: 1
Branch 26998: 1
Branch 26999: 1
Branch 27000: 1
Branch 27001: 1
Branch 27002: 1
Branch 27003: 1
Branch 27004: 1
Branch 27005: 1
Branch 27006: 1
Branch 27007: 1
Branch 27008: 1
Branch 27009: 1
Branch 27010: 1
Branch 27011: 1
Branch 27012: 1
Branch 27013: 1
Branch 27014: 1
Branch 27015: 1
Branch 27016: 1
Branch 27017: 1
Branch 27018: 1
Branch 27019: 1
Branch 27020: 1
Branch 27021: 1
Branch 27022: 1
Branch 27023: 1
Branch 27024: 1
Branch 27025: 1
Branch 27026: 1
Branch 27027: 1
Branch 27028: 1
Branch 27029: 1
Branch 27030: 1
Branch 27031: 1
Branch 27032: 1
Branch 27033: 1
Branch 27034: 1
Branch 27035: 1
Branch 27036: 1
Branch 27037: 1
Branch 27038: 1
Branch 27039: 1
Branch 27040: 1
Branch 27041: 1
Branch 27042: 1
Branch 27043: 1
Branch 27044: 1
Branch 27045: 1
Branch 27046: 1
Branch 27047: 1
Branch 27048: 1
Branch 27049: 1
Branch 27050: 1
Branch 27051: 1
Branch 27052: 1
Branch 27053: 1
Branch 27054: 1
Branch 27055: 1
Branch 27056: 1
Branch 27057: 1
Branch 27058: 1
Branch 27059: 1
Branch 27060: 1
Branch 27061: 1
Branch 27062: 1
Branch 27063: 1
Branch 27064: 1
Branch 27065: 1
Branch 27066: 1
Branch 27067: 1
Branch 27068: 1
Branch 27069: 1
Branch 27070: 1
Branch 27071: 1
Branch 27072: 1
Branch 27073: 1
Branch 27074: 1
Branch 27075: 1
Branch 27076: 1
Branch 27077: 1
Branch 27078: 1
Branch 27079: 1
Branch 27080: 1
Branch 27081: 1
Branch 27082: 1
Branch 27083: 1
Branch 27084: 1
Branch 27085: 1
Branch 27086: 1
Branch 27087: 1
Branch 27088: 1
Branch 27089: 1
Branch 27090: 1
Branch 27091: 1
Branch 27092: 1
Branch 27093: 1
Branch 27094: 1
Branch 27095: 1
Branch 27096: 1
Branch 27097: 1
Branch 27098: 1
Branch 27099: 1
Branch 27100: 1
Branch 27101: 1
Branch 27102: 1
Branch 27103: 1
Branch 27104: 1
Branch 27105: 1
Branch 27106: 1
Branch 27107: 1
Branch 27108: 1
Branch 27109: 1
Branch 27110: 1
Branch 27111: 1
Branch 27112: 1
Branch 27113: 1
Branch 27114: 1
Branch 27115: 1
Branch 27116: 1
Branch 27117: 1
Branch 27118: 1
Branch 27119: 1
Branch 27120: 1
Branch 27121: 1
Branch 27122: 1
Branch 27123: 1
Branch 27124: 1
Branch 27125: 1
Branch 27126: 1
Branch 27127: 1
Branch 27128: 1
Branch 27129: 1
Branch 27130: 1
Branch 27131: 1
Branch 27132: 1
Branch 27133: 1
Branch 27134: 1
Branch 27135: 1
Branch 27136: 1
Branch 27137: 1
Branch 27138: 1
Branch 27139: 1
Branch 27140: 1
Branch 27141: 1
Branch 27142: 1
Branch 27143: 1
Branch 27144: 1
Branch 27145: 1
Branch 27146: 1
Branch 27147: 1
Branch 27148: 1
Branch 27149: 1
Branch 27150: 1
Branch 27151: 1
Branch 27152: 1
Branch 27153: 1
Branch 27154: 1
Branch 27155: 1
Branch 27156: 1
Branch 27157: 1
Branch 27158: 1
Branch 27159: 1
Branch 27160: 1
Branch 27161: 1
Branch 27162: 1
Branch 27163: 1
Branch 27164: 1
Branch 27165: 1
Branch 27166: 1
Branch 27167: 1
Branch 27168: 1
Branch 27169: 1
Branch 27170: 1
Branch 27171: 1
Branch 27172: 1
Branch 27173: 1
Branch 27174: 1
Branch 27175: 1
Branch 27176: 1
Branch 27177: 1
Branch 27178: 1
Branch 27179: 1
Branch 27180: 1
Branch 27181: 1
Branch 27182: 1
Branch 27183: 1
Branch 27184: 1
Branch 27185: 1
Branch 27186: 1
Branch 27187: 1
Branch 27188: 1
Branch 27189: 1
Branch 27190: 1
Branch 27191: 1
Branch 27192: 1
Branch 27193: 1
Branch 27194: 1
Branch 27195: 1
Branch 27196: 1
Branch 27197: 1
Branch 27198: 1
Branch 27199: 1
Branch 27200: 1
Branch 27201: 1
Branch 27202: 1
Branch 27203: 1
Branch 27204: 1
Branch 27205: 1
Branch 27206: 1
Branch 27207: 1
Branch 27208: 1
Branch 27209: 1
Branch 27210: 1
Branch 27211: 1
Branch 27212: 1
Branch 27213: 1
Branch 27214: 1
Branch 27215: 1
Branch 27216: 1
Branch 27217: 1
Branch 27218: 1
Branch 27219: 1
Branch 27220: 1
Branch 27221: 1
Branch 27222: 1
Branch 27223: 1
Branch 27224: 1
Branch 27225: 1
Branch 27226: 1
Branch 27227: 1
Branch 27228: 1
Branch 27229: 1
Branch 27230: 1
Branch 27231: 1
Branch 27232: 1
Branch 27233: 1
Branch 27234: 1
Branch 27235: 1
Branch 27236: 1
Branch 27237: 1
Branch 27238: 1
Branch 27239: 1
Branch 27240: 1
Branch 27241: 1
Branch 27242: 1
Branch 27243: 1
Branch 27244: 1
Branch 27245: 1
Branch 27246: 1
Branch 27247: 1
Branch 27248: 1
Branch 27249: 1
Branch 27250: 1
Branch 27251: 1
Branch 27252: 1
Branch 27253: 1
Branch 27254: 1
Branch 27255: 1
Branch 27256: 1
Branch 27257: 1
Branch 27258: 1
Branch 27259: 1
Branch 27260: 1
Branch 27261: 1
Branch 27262: 1
Branch 27263: 1
Branch 27264: 1
Branch 27265: 1
Branch 27266: 1
Branch 27267: 1
Branch 27268: 1
Branch 27269: 1
Branch 27270: 1
Branch 27271: 1
Branch 27272: 1
Branch 27273: 1
Branch 27274: 1
Branch 27275: 1
Branch 27276: 1
Branch 27277: 1
Branch 27278: 1
Branch 27279: 1
Branch 27280: 1
Branch 27281: 1
Branch 27282: 1
Branch 27283: 1
Branch 27284: 1
Branch 27285: 1
Branch 27286: 1
Branch 27287: 1
Branch 27288: 1
Branch 27289: 1
Branch 27290: 1
Branch 27291: 1
Branch 27292: 1
Branch 27293: 1
Branch 27294: 1
Branch 27295: 1
Branch 27296: 1
Branch 27297: 1
Branch 27298: 1
Branch 27299: 1
Branch 27300: 1
Branch 27301: 1
Branch 27302: 1
Branch 27303: 1
Branch 27304: 1
Branch 27305: 1
Branch 27306: 1
Branch 27307: 1
Branch 27308: 1
Branch 27309: 1
Branch 27310: 1
Branch 27311: 1
Branch 27312: 1
Branch 27313: 1
Branch 27314: 1
Branch 27315: 1
Branch 27316: 1
Branch 27317: 1
Branch 27318: 1
Branch 27319: 1
Branch 27320: 1
Branch 27321: 1
Branch 27322: 1
Branch 27323: 1
Branch 27324: 1
Branch 27325: 1
Branch 27326: 1
Branch 27327: 1
Branch 27328: 1
Branch 27329: 1
Branch 27330: 1
Branch 27331: 1
Branch 27332: 1
Branch 27333: 1
Branch 27334: 1
Branch 27335: 1
Branch 27336: 1
Branch 27337: 1
Branch 27338: 1
Branch 27339: 1
Branch 27340: 1
Branch 27341: 1
Branch 27342: 1
Branch 27343: 1
Branch 27344: 1
Branch 27345: 1
Branch 27346: 1
Branch 27347: 1
Branch 27348: 1
Branch 27349: 1
Branch 27350: 1
Branch 27351: 1
Branch 27352: 1
Branch 27353: 1
Branch 27354: 1
Branch 27355: 1
Branch 27356: 1
Branch 27357: 1
Branch 27358: 1
Branch 27359: 1
Branch 27360: 1
Branch 27361: 1
Branch 27362: 1
Branch 27363: 1
Branch 27364: 1
Branch 27365: 1
Branch 27366: 1
Branch 27367: 1
Branch 27368: 1
Branch 27369: 1
Branch 27370: 1
Branch 27371: 1
Branch 27372: 1
Branch 27373: 1
Branch 27374: 1
Branch 27375: 1
Branch 27376: 1
Branch 27377: 1
Branch 27378: 1
Branch 27379: 1
Branch 27380: 1
Branch 27381: 1
Branch 27382: 1
Branch 27383: 1
Branch 27384: 1
Branch 27385: 1
Branch 27386: 1
Branch 27387: 1
Branch 27388: 1
Branch 27389: 1
Branch 27390: 1
Branch 27391: 1
Branch 27392: 1
Branch 27393: 1
Branch 27394: 1
Branch 27395: 1
Branch 27396: 1
Branch 27397: 1
Branch 27398: 1
Branch 27399: 1
Branch 27400: 1
Branch 27401: 1
Branch 27402: 1
Branch 27403: 1
Branch 27404: 1
Branch 27405: 1
Branch 27406: 1
Branch 27407: 1
Branch 27408: 1
Branch 27409: 1
Branch 27410: 1
Branch 27411: 1
Branch 27412: 1
Branch 27413: 1
Branch 27414: 1
Branch 27415: 1
Branch 27416: 1
Branch 27417: 1
Branch 27418: 1
Branch 27419: 1
Branch 27420: 1
Branch 27421: 1
Branch 27422: 1
Branch 27423: 1
Branch 27424: 1
Branch 27425: 1
Branch 27426: 1
Branch 27427: 1
Branch 27428: 1
Branch 27429: 1
Branch 27430: 1
Branch 27431: 1
Branch 27432: 1
Branch 27433: 1
Branch 27434: 1
Branch 27435: 1
Branch 27436: 1
Branch 27437: 1
Branch 27438: 1
Branch 27439: 1
Branch 27440: 1
Branch 27441: 1
Branch 27442: 1
Branch 27443: 1
Branch 27444: 1
Branch 27445: 1
Branch 27446: 1
Branch 27447: 1
Branch 27448: 1
Branch 27449: 1
Branch 27450: 1
Branch 27451: 1
Branch 27452: 1
Branch 27453: 1
Branch 27454: 1
Branch 27455: 1
Branch 27456: 1
Branch 27457: 1
Branch 27458: 1
Branch 27459: 1
Branch 27460: 1
Branch 27461: 1
Branch 27462: 1
Branch 27463: 1
Branch 27464: 1
Branch 27465: 1
Branch 27466: 1
Branch 27467: 1
Branch 27468: 1
Branch 27469: 1
Branch 27470: 1
Branch 27471: 1
Branch 27472: 1
Branch 27473: 1
Branch 27474: 1
Branch 27475: 1
Branch 27476: 1
Branch 27477: 1
Branch 27478: 1
Branch 27479: 1
Branch 27480: 1
Branch 27481: 1
Branch 27482: 1
Branch 27483: 1
Branch 27484: 1
Branch 27485: 1
Branch 27486: 1
Branch 27487: 1
Branch 27488: 1
Branch 27489: 1
Branch 27490: 1
Branch 27491: 1
Branch 27492: 1
Branch 27493: 1
Branch 27494: 1
Branch 27495: 1
Branch 27496: 1
Branch 27497: 1
Branch 27498: 1
Branch 27499: 1
Branch 27500: 1
Branch 27501: 1
Branch 27502: 1
Branch 27503: 1
Branch 27504: 1
Branch 27505: 1
Branch 27506: 1
Branch 27507: 1
Branch 27508: 1
Branch 27509: 1
Branch 27510: 1
Branch 27511: 1
Branch 27512: 1
Branch 27513: 1
Branch 27514: 1
Branch 27515: 1
Branch 27516: 1
Branch 27517: 1
Branch 27518: 1
Branch 27519: 1
Branch 27520: 1
Branch 27521: 1
Branch 27522: 1
Branch 27523: 1
Branch 27524: 1
Branch 27525: 1
Branch 27526: 1
Branch 27527: 1
Branch 27528: 1
Branch 27529: 1
Branch 27530: 1
Branch 27531: 1
Branch 27532: 1
Branch 27533: 1
Branch 27534: 1
Branch 27535: 1
Branch 27536: 1
Branch 27537: 1
Branch 27538: 1
Branch 27539: 1
Branch 27540: 1
Branch 27541: 1
Branch 27542: 1
Branch 27543: 1
Branch 27544: 1
Branch 27545: 1
Branch 27546: 1
Branch 27547: 1
Branch 27548: 1
Branch 27549: 1
Branch 27550: 1
Branch 27551: 1
Branch 27552: 1
Branch 27553: 1
Branch 27554: 1
Branch 27555: 1
Branch 27556: 1
Branch 27557: 1
Branch 27558: 1
Branch 27559: 1
Branch 27560: 1
Branch 27561: 1
Branch 27562: 1
Branch 27563: 1
Branch 27564: 1
Branch 27565: 1
Branch 27566: 1
Branch 27567: 1
Branch 27568: 1
Branch 27569: 1
Branch 27570: 1
Branch 27571: 1
Branch 27572: 1
Branch 27573: 1
Branch 27574: 1
Branch 27575: 1
Branch 27576: 1
Branch 27577: 1
Branch 27578: 1
Branch 27579: 1
Branch 27580: 1
Branch 27581: 1
Branch 27582: 1
Branch 27583: 1
Branch 27584: 1
Branch 27585: 1
Branch 27586: 1
Branch 27587: 1
Branch 27588: 1
Branch 27589: 1
Branch 27590: 1
Branch 27591: 1
Branch 27592: 1
Branch 27593: 1
Branch 27594: 1
Branch 27595: 1
Branch 27596: 1
Branch 27597: 1
Branch 27598: 1
Branch 27599: 1
Branch 27600: 1
Branch 27601: 1
Branch 27602: 1
Branch 27603: 1
Branch 27604: 1
Branch 27605: 1
Branch 27606: 1
Branch 27607: 1
Branch 27608: 1
Branch 27609: 1
Branch 27610: 1
Branch 27611: 1
Branch 27612: 1
Branch 27613: 1
Branch 27614: 1
Branch 27615: 1
Branch 27616: 1
Branch 27617: 1
Branch 27618: 1
Branch 27619: 1
Branch 27620: 1
Branch 27621: 1
Branch 27622: 1
Branch 27623: 1
Branch 27624: 1
Branch 27625: 1
Branch 27626: 1
Branch 27627: 1
Branch 27628: 1
Branch 27629: 1
Branch 27630: 1
Branch 27631: 1
Branch 27632: 1
Branch 27633: 1
Branch 27634: 1
Branch 27635: 1
Branch 27636: 1
Branch 27637: 1
Branch 27638: 1
Branch 27639: 1
Branch 27640: 1
Branch 27641: 1
Branch 27642: 1
Branch 27643: 1
Branch 27644: 1
Branch 27645: 1
Branch 27646: 1
Branch 27647: 1
Branch 27648: 1
Branch 27649: 1
Branch 27650: 1
Branch 27651: 1
Branch 27652: 1
Branch 27653: 1
Branch 27654: 1
Branch 27655: 1
Branch 27656: 1
Branch 27657: 1
Branch 27658: 1
Branch 27659: 1
Branch 27660: 1
Branch 27661: 1
Branch 27662: 1
Branch 27663: 1
Branch 27664: 1
Branch 27665: 1
Branch 27666: 1
Branch 27667: 1
Branch 27668: 1
Branch 27669: 1
Branch 27670: 1
Branch 27671: 1
Branch 27672: 1
Branch 27673: 1
Branch 27674: 1
Branch 27675: 1
Branch 27676: 1
Branch 27677: 1
Branch 27678: 1
Branch 27679: 1
Branch 27680: 1
Branch 27681: 1
Branch 27682: 1
Branch 27683: 1
Branch 27684: 1
Branch 27685: 1
Branch 27686: 1
Branch 27687: 1
Branch 27688: 1
Branch 27689: 1
Branch 27690: 1
Branch 27691: 1
Branch 27692: 1
Branch 27693: 1
Branch 27694: 1
Branch 27695: 1
Branch 27696: 1
Branch 27697: 1
Branch 27698: 1
Branch 27699: 1
Branch 27700: 1
Branch 27701: 1
Branch 27702: 1
Branch 27703: 1
Branch 27704: 1
Branch 27705: 1
Branch 27706: 1
Branch 27707: 1
Branch 27708: 1
Branch 27709: 1
Branch 27710: 1
Branch 27711: 1
Branch 27712: 1
Branch 27713: 1
Branch 27714: 1
Branch 27715: 1
Branch 27716: 1
Branch 27717: 1
Branch 27718: 1
Branch 27719: 1
Branch 27720: 1
Branch 27721: 1
Branch 27722: 1
Branch 27723: 1
Branch 27724: 1
Branch 27725: 1
Branch 27726: 1
Branch 27727: 1
Branch 27728: 1
Branch 27729: 1
Branch 27730: 1
Branch 27731: 1
Branch 27732: 1
Branch 27733: 1
Branch 27734: 1
Branch 27735: 1
Branch 27736: 1
Branch 27737: 1
Branch 27738: 1
Branch 27739: 1
Branch 27740: 1
Branch 27741: 1
Branch 27742: 1
Branch 27743: 1
Branch 27744: 1
Branch 27745: 1
Branch 27746: 1
Branch 27747: 1
Branch 27748: 1
Branch 27749: 1
Branch 27750: 1
Branch 27751: 1
Branch 27752: 1
Branch 27753: 1
Branch 27754: 1
Branch 27755: 1
Branch 27756: 1
Branch 27757: 1
Branch 27758: 1
Branch 27759: 1
Branch 27760: 1
Branch 27761: 1
Branch 27762: 1
Branch 27763: 1
Branch 27764: 1
Branch 27765: 1
Branch 27766: 1
Branch 27767: 1
Branch 27768: 1
Branch 27769: 1
Branch 27770: 1
Branch 27771: 1
Branch 27772: 1
Branch 27773: 1
Branch 27774: 1
Branch 27775: 1
Branch 27776: 1
Branch 27777: 1
Branch 27778: 1
Branch 27779: 1
Branch 27780: 1
Branch 27781: 1
Branch 27782: 1
Branch 27783: 1
Branch 27784: 1
Branch 27785: 1
Branch 27786: 1
Branch 27787: 1
Branch 27788: 1
Branch 27789: 1
Branch 27790: 1
Branch 27791: 1
Branch 27792: 1
Branch 27793: 1
Branch 27794: 1
Branch 27795: 1
Branch 27796: 1
Branch 27797: 1
Branch 27798: 1
Branch 27799: 1
Branch 27800: 1
Branch 27801: 1
Branch 27802: 1
Branch 27803: 1
Branch 27804: 1
Branch 27805: 1
Branch 27806: 1
Branch 27807: 1
Branch 27808: 1
Branch 27809: 1
Branch 27810: 1
Branch 27811: 1
Branch 27812: 1
Branch 27813: 1
Branch 27814: 1
Branch 27815: 1
Branch 27816: 1
Branch 27817: 1
Branch 27818: 1
Branch 27819: 1
Branch 27820: 1
Branch 27821: 1
Branch 27822: 1
Branch 27823: 1
Branch 27824: 1
Branch 27825: 1
Branch 27826: 1
Branch 27827: 1
Branch 27828: 1
Branch 27829: 1
Branch 27830: 1
Branch 27831: 1
Branch 27832: 1
Branch 27833: 1
Branch 27834: 1
Branch 27835: 1
Branch 27836: 1
Branch 27837: 1
Branch 27838: 1
Branch 27839: 1
Branch 27840: 1
Branch 27841: 1
Branch 27842: 1
Branch 27843: 1
Branch 27844: 1
Branch 27845: 1
Branch 27846: 1
Branch 27847: 1
Branch 27848: 1
Branch 27849: 1
Branch 27850: 1
Branch 27851: 1
Branch 27852: 1
Branch 27853: 1
Branch 27854: 1
Branch 27855: 1
Branch 27856: 1
Branch 27857: 1
Branch 27858: 1
Branch 27859: 1
Branch 27860: 1
Branch 27861: 1
Branch 27862: 1
Branch 27863: 1
Branch 27864: 1
Branch 27865: 1
Branch 27866: 1
Branch 27867: 1
Branch 27868: 1
Branch 27869: 1
Branch 27870: 1
Branch 27871: 1
Branch 27872: 1
Branch 27873: 1
Branch 27874: 1
Branch 27875: 1
Branch 27876: 1
Branch 27877: 1
Branch 27878: 1
Branch 27879: 1
Branch 27880: 1
Branch 27881: 1
Branch 27882: 1
Branch 27883: 1
Branch 27884: 1
Branch 27885: 1
Branch 27886: 1
Branch 27887: 1
Branch 27888: 1
Branch 27889: 1
Branch 27890: 1
Branch 27891: 1
Branch 27892: 1
Branch 27893: 1
Branch 27894: 1
Branch 27895: 1
Branch 27896: 1
Branch 27897: 1
Branch 27898: 1
Branch 27899: 1
Branch 27900: 1
Branch 27901: 1
Branch 27902: 1
Branch 27903: 1
Branch 27904: 1
Branch 27905: 1
Branch 27906: 1
Branch 27907: 1
Branch 27908: 1
Branch 27909: 1
Branch 27910: 1
Branch 27911: 1
Branch 27912: 1
Branch 27913: 1
Branch 27914: 1
Branch 27915: 1
Branch 27916: 1
Branch 27917: 1
Branch 27918: 1
Branch 27919: 1
Branch 27920: 1
Branch 27921: 1
Branch 27922: 1
Branch 27923: 1
Branch 27924: 1
Branch 27925: 1
Branch 27926: 1
Branch 27927: 1
Branch 27928: 1
Branch 27929: 1
Branch 27930: 1
Branch 27931: 1
Branch 27932: 1
Branch 27933: 1
Branch 27934: 1
Branch 27935: 1
Branch 27936: 1
Branch 27937: 1
Branch 27938: 1
Branch 27939: 1
Branch 27940: 1
Branch 27941: 1
Branch 27942: 1
Branch 27943: 1
Branch 27944: 1
Branch 27945: 1
Branch 27946: 1
Branch 27947: 1
Branch 27948: 1
Branch 27949: 1
Branch 27950: 1
Branch 27951: 1
Branch 27952: 1
Branch 27953: 1
Branch 27954: 1
Branch 27955: 1
Branch 27956: 1
Branch 27957: 1
Branch 27958: 1
Branch 27959: 1
Branch 27960: 1
Branch 27961: 1
Branch 27962: 1
Branch 27963: 1
Branch 27964: 1
Branch 27965: 1
Branch 27966: 1
Branch 27967: 1
Branch 27968: 1
Branch 27969: 1
Branch 27970: 1
Branch 27971: 1
Branch 27972: 1
Branch 27973: 1
Branch 27974: 1
Branch 27975: 1
Branch 27976: 1
Branch 27977: 1
Branch 27978: 1
Branch 27979: 1
Branch 27980: 1
Branch 27981: 1
Branch 27982: 1
Branch 27983: 1
Branch 27984: 1
Branch 27985: 1
Branch 27986: 1
Branch 27987: 1
Branch 27988: 1
Branch 27989: 1
Branch 27990: 1
Branch 27991: 1
Branch 27992: 1
Branch 27993: 1
Branch 27994: 1
Branch 27995: 1
Branch 27996: 1
Branch 27997: 1
Branch 27998: 1
Branch 27999: 1
Branch 28000: 1
Branch 28001: 1
Branch 28002: 1
Branch 28003: 1
Branch 28004: 1
Branch 28005: 1
Branch 28006: 1
Branch 28007: 1
Branch 28008: 1
Branch 28009: 1
Branch 28010: 1
Branch 28011: 1
Branch 28012: 1
Branch 28013: 1
Branch 28014: 1
Branch 28015: 1
Branch 28016: 1
Branch 28017: 1
Branch 28018: 1
Branch 28019: 1
Branch 28020: 1
Branch 28021: 1
Branch 28022: 1
Branch 28023: 1
Branch 28024: 1
Branch 28025: 1
Branch 28026: 1
Branch 28027: 1
Branch 28028: 1
Branch 28029: 1
Branch 28030: 1
Branch 28031: 1
Branch 28032: 1
Branch 28033: 1
Branch 28034: 1
Branch 28035: 1
Branch 28036: 1
Branch 28037: 1
Branch 28038: 1
Branch 28039: 1
Branch 28040: 1
Branch 28041: 1
Branch 28042: 1
Branch 28043: 1
Branch 28044: 1
Branch 28045: 1
Branch 28046: 1
Branch 28047: 1
Branch 28048: 1
Branch 28049: 1
Branch 28050: 1
Branch 28051: 1
Branch 28052: 1
Branch 28053: 1
Branch 28054: 1
Branch 28055: 1
Branch 28056: 1
Branch 28057: 1
Branch 28058: 1
Branch 28059: 1
Branch 28060: 1
Branch 28061: 1
Branch 28062: 1
Branch 28063: 1
Branch 28064: 1
Branch 28065: 1
Branch 28066: 1
Branch 28067: 1
Branch 28068: 1
Branch 28069: 1
Branch 28070: 1
Branch 28071: 1
Branch 28072: 1
Branch 28073: 1
Branch 28074: 1
Branch 28075: 1
Branch 28076: 1
Branch 28077: 1
Branch 28078: 1
Branch 28079: 1
Branch 28080: 1
Branch 28081: 1
Branch 28082: 1
Branch 28083: 1
Branch 28084: 1
Branch 28085: 1
Branch 28086: 1
Branch 28087: 1
Branch 28088: 1
Branch 28089: 1
Branch 28090: 1
Branch 28091: 1
Branch 28092: 1
Branch 28093: 1
Branch 28094: 1
Branch 28095: 1
Branch 28096: 1
Branch 28097: 1
Branch 28098: 1
Branch 28099: 1
Branch 28100: 1
Branch 28101: 1
Branch 28102: 1
Branch 28103: 1
Branch 28104: 1
Branch 28105: 1
Branch 28106: 1
Branch 28107: 1
Branch 28108: 1
Branch 28109: 1
Branch 28110: 1
Branch 28111: 1
Branch 28112: 1
Branch 28113: 1
Branch 28114: 1
Branch 28115: 1
Branch 28116: 1
Branch 28117: 1
Branch 28118: 1
Branch 28119: 1
Branch 28120: 1
Branch 28121: 1
Branch 28122: 1
Branch 28123: 1
Branch 28124: 1
Branch 28125: 1
Branch 28126: 1
Branch 28127: 1
Branch 28128: 1
Branch 28129: 1
Branch 28130: 1
Branch 28131: 1
Branch 28132: 1
Branch 28133: 1
Branch 28134: 1
Branch 28135: 1
Branch 28136: 1
Branch 28137: 1
Branch 28138: 1
Branch 28139: 1
Branch 28140: 1
Branch 28141: 1
Branch 28142: 1
Branch 28143: 1
Branch 28144: 1
Branch 28145: 1
Branch 28146: 1
Branch 28147: 1
Branch 28148: 1
Branch 28149: 1
Branch 28150: 1
Branch 28151: 1
Branch 28152: 1
Branch 28153: 1
Branch 28154: 1
Branch 28155: 1
Branch 28156: 1
Branch 28157: 1
Branch 28158: 1
Branch 28159: 1
Branch 28160: 1
Branch 28161: 1
Branch 28162: 1
Branch 28163: 1
Branch 28164: 1
Branch 28165: 1
Branch 28166: 1
Branch 28167: 1
Branch 28168: 1
Branch 28169: 1
Branch 28170: 1
Branch 28171: 1
Branch 28172: 1
Branch 28173: 1
Branch 28174: 1
Branch 28175: 1
Branch 28176: 1
Branch 28177: 1
Branch 28178: 1
Branch 28179: 1
Branch 28180: 1
Branch 28181: 1
Branch 28182: 1
Branch 28183: 1
Branch 28184: 1
Branch 28185: 1
Branch 28186: 1
Branch 28187: 1
Branch 28188: 1
Branch 28189: 1
Branch 28190: 1
Branch 28191: 1
Branch 28192: 1
Branch 28193: 1
Branch 28194: 1
Branch 28195: 1
Branch 28196: 1
Branch 28197: 1
Branch 28198: 1
Branch 28199: 1
Branch 28200: 1
Branch 28201: 1
Branch 28202: 1
Branch 28203: 1
Branch 28204: 1
Branch 28205: 1
Branch 28206: 1
Branch 28207: 1
Branch 28208: 1
Branch 28209: 1
Branch 28210: 1
Branch 28211: 1
Branch 28212: 1
Branch 28213: 1
Branch 28214: 1
Branch 28215: 1
Branch 28216: 1
Branch 28217: 1
Branch 28218: 1
Branch 28219: 1
Branch 28220: 1
Branch 28221: 1
Branch 28222: 1
Branch 28223: 1
Branch 28224: 1
Branch 28225: 1
Branch 28226: 1
Branch 28227: 1
Branch 28228: 1
Branch 28229: 1
Branch 28230: 1
Branch 28231: 1
Branch 28232: 1
Branch 28233: 1
Branch 28234: 1
Branch 28235: 1
Branch 28236: 1
Branch 28237: 1
Branch 28238: 1
Branch 28239: 1
Branch 28240: 1
Branch 28241: 1
Branch 28242: 1
Branch 28243: 1
Branch 28244: 1
Branch 28245: 1
Branch 28246: 1
Branch 28247: 1
Branch 28248: 1
Branch 28249: 1
Branch 28250: 1
Branch 28251: 1
Branch 28252: 1
Branch 28253: 1
Branch 28254: 1
Branch 28255: 1
Branch 28256: 1
Branch 28257: 1
Branch 28258: 1
Branch 28259: 1
Branch 28260: 1
Branch 28261: 1
Branch 28262: 1
Branch 28263: 1
Branch 28264: 1
Branch 28265: 1
Branch 28266: 1
Branch 28267: 1
Branch 28268: 1
Branch 28269: 1
Branch 28270: 1
Branch 28271: 1
Branch 28272: 1
Branch 28273: 1
Branch 28274: 1
Branch 28275: 1
Branch 28276: 1
Branch 28277: 1
Branch 28278: 1
Branch 28279: 1
Branch 28280: 1
Branch 28281: 1
Branch 28282: 1
Branch 28283: 1
Branch 28284: 1
Branch 28285: 1
Branch 28286: 1
Branch 28287: 1
Branch 28288: 1
Branch 28289: 1
Branch 28290: 1
Branch 28291: 1
Branch 28292: 1
Branch 28293: 1
Branch 28294: 1
Branch 28295: 1
Branch 28296: 1
Branch 28297: 1
Branch 28298: 1
Branch 28299: 1
Branch 28300: 1
Branch 28301: 1
Branch 28302: 1
Branch 28303: 1
Branch 28304: 1
Branch 28305: 1
Branch 28306: 1
Branch 28307: 1
Branch 28308: 1
Branch 28309: 1
Branch 28310: 1
Branch 28311: 1
Branch 28312: 1
Branch 28313: 1
Branch 28314: 1
Branch 28315: 1
Branch 28316: 1
Branch 28317: 1
Branch 28318: 1
Branch 28319: 1
Branch 28320: 1
Branch 28321: 1
Branch 28322: 1
Branch 28323: 1
Branch 28324: 1
Branch 28325: 1
Branch 28326: 1
Branch 28327: 1
Branch 28328: 1
Branch 28329: 1
Branch 28330: 1
Branch 28331: 1
Branch 28332: 1
Branch 28333: 1
Branch 28334: 1
Branch 28335: 1
Branch 28336: 1
Branch 28337: 1
Branch 28338: 1
Branch 28339: 1
Branch 28340: 1
Branch 28341: 1
Branch 28342: 1
Branch 28343: 1
Branch 28344: 1
Branch 28345: 1
Branch 28346: 1
Branch 28347: 1
Branch 28348: 1
Branch 28349: 1
Branch 28350: 1
Branch 28351: 1
Branch 28352: 1
Branch 28353: 1
Branch 28354: 1
Branch 28355: 1
Branch 28356: 1
Branch 28357: 1
Branch 28358: 1
Branch 28359: 1
Branch 28360: 1
Branch 28361: 1
Branch 28362: 1
Branch 28363: 1
Branch 28364: 1
Branch 28365: 1
Branch 28366: 1
Branch 28367: 1
Branch 28368: 1
Branch 28369: 1
Branch 28370: 1
Branch 28371: 1
Branch 28372: 1
Branch 28373: 1
Branch 28374: 1
Branch 28375: 1
Branch 28376: 1
Branch 28377: 1
Branch 28378: 1
Branch 28379: 1
Branch 28380: 1
Branch 28381: 1
Branch 28382: 1
Branch 28383: 1
Branch 28384: 1
Branch 28385: 1
Branch 28386: 1
Branch 28387: 1
Branch 28388: 1
Branch 28389: 1
Branch 28390: 1
Branch 28391: 1
Branch 28392: 1
Branch 28393: 1
Branch 28394: 1
Branch 28395: 1
Branch 28396: 1
Branch 28397: 1
Branch 28398: 1
Branch 28399: 1
Branch 28400: 1
Branch 28401: 1
Branch 28402: 1
Branch 28403: 1
Branch 28404: 1
Branch 28405: 1
Branch 28406: 1
Branch 28407: 1
Branch 28408: 1
Branch 28409: 1
Branch 28410: 1
Branch 28411: 1
Branch 28412: 1
Branch 28413: 1
Branch 28414: 1
Branch 28415: 1
Branch 28416: 1
Branch 28417: 1
Branch 28418: 1
Branch 28419: 1
Branch 28420: 1
Branch 28421: 1
Branch 28422: 1
Branch 28423: 1
Branch 28424: 1
Branch 28425: 1
Branch 28426: 1
Branch 28427: 1
Branch 28428: 1
Branch 28429: 1
Branch 28430: 1
Branch 28431: 1
Branch 28432: 1
Branch 28433: 1
Branch 28434: 1
Branch 28435: 1
Branch 28436: 1
Branch 28437: 1
Branch 28438: 1
Branch 28439: 1
Branch 28440: 1
Branch 28441: 1
Branch 28442: 1
Branch 28443: 1
Branch 28444: 1
Branch 28445: 1
Branch 28446: 1
Branch 28447: 1
Branch 28448: 1
Branch 28449: 1
Branch 28450: 1
Branch 28451: 1
Branch 28452: 1
Branch 28453: 1
Branch 28454: 1
Branch 28455: 1
Branch 28456: 1
Branch 28457: 1
Branch 28458: 1
Branch 28459: 1
Branch 28460: 1
Branch 28461: 1
Branch 28462: 1
Branch 28463: 1
Branch 28464: 1
Branch 28465: 1
Branch 28466: 1
Branch 28467: 1
Branch 28468: 1
Branch 28469: 1
Branch 28470: 1
Branch 28471: 1
Branch 28472: 1
Branch 28473: 1
Branch 28474: 1
Branch 28475: 1
Branch 28476: 1
Branch 28477: 1
Branch 28478: 1
Branch 28479: 1
Branch 28480: 1
Branch 28481: 1
Branch 28482: 1
Branch 28483: 1
Branch 28484: 1
Branch 28485: 1
Branch 28486: 1
Branch 28487: 1
Branch 28488: 1
Branch 28489: 1
Branch 28490: 1
Branch 28491: 1
Branch 28492: 1
Branch 28493: 1
Branch 28494: 1
Branch 28495: 1
Branch 28496: 1
Branch 28497: 1
Branch 28498: 1
Branch 28499: 1
Branch 28500: 1
Branch 28501: 1
Branch 28502: 1
Branch 28503: 1
Branch 28504: 1
Branch 28505: 1
Branch 28506: 1
Branch 28507: 1
Branch 28508: 1
Branch 28509: 1
Branch 28510: 1
Branch 28511: 1
Branch 28512: 1
Branch 28513: 1
Branch 28514: 1
Branch 28515: 1
Branch 28516: 1
Branch 28517: 1
Branch 28518: 1
Branch 28519: 1
Branch 28520: 1
Branch 28521: 1
Branch 28522: 1
Branch 28523: 1
Branch 28524: 1
Branch 28525: 1
Branch 28526: 1
Branch 28527: 1
Branch 28528: 1
Branch 28529: 1
Branch 28530: 1
Branch 28531: 1
Branch 28532: 1
Branch 28533: 1
Branch 28534: 1
Branch 28535: 1
Branch 28536: 1
Branch 28537: 1
Branch 28538: 1
Branch 28539: 1
Branch 28540: 1
Branch 28541: 1
Branch 28542: 1
Branch 28543: 1
Branch 28544: 1
Branch 28545: 1
Branch 28546: 1
Branch 28547: 1
Branch 28548: 1
Branch 28549: 1
Branch 28550: 1
Branch 28551: 1
Branch 28552: 1
Branch 28553: 1
Branch 28554: 1
Branch 28555: 1
Branch 28556: 1
Branch 28557: 1
Branch 28558: 1
Branch 28559: 1
Branch 28560: 1
Branch 28561: 1
Branch 28562: 1
Branch 28563: 1
Branch 28564: 1
Branch 28565: 1
Branch 28566: 1
Branch 28567: 1
Branch 28568: 1
Branch 28569: 1
Branch 28570: 1
Branch 28571: 1
Branch 28572: 1
Branch 28573: 1
Branch 28574: 1
Branch 28575: 1
Branch 28576: 1
Branch 28577: 1
Branch 28578: 1
Branch 28579: 1
Branch 28580: 1
Branch 28581: 1
Branch 28582: 1
Branch 28583: 1
Branch 28584: 1
Branch 28585: 1
Branch 28586: 1
Branch 28587: 1
Branch 28588: 1
Branch 28589: 1
Branch 28590: 1
Branch 28591: 1
Branch 28592: 1
Branch 28593: 1
Branch 28594: 1
Branch 28595: 1
Branch 28596: 1
Branch 28597: 1
Branch 28598: 1
Branch 28599: 1
Branch 28600: 1
Branch 28601: 1
Branch 28602: 1
Branch 28603: 1
Branch 28604: 1
Branch 28605: 1
Branch 28606: 1
Branch 28607: 1
Branch 28608: 1
Branch 28609: 1
Branch 28610: 1
Branch 28611: 1
Branch 28612: 1
Branch 28613: 1
Branch 28614: 1
Branch 28615: 1
Branch 28616: 1
Branch 28617: 1
Branch 28618: 1
Branch 28619: 1
Branch 28620: 1
Branch 28621: 1
Branch 28622: 1
Branch 28623: 1
Branch 28624: 1
Branch 28625: 1
Branch 28626: 1
Branch 28627: 1
Branch 28628: 1
Branch 28629: 1
Branch 28630: 1
Branch 28631: 1
Branch 28632: 1
Branch 28633: 1
Branch 28634: 1
Branch 28635: 1
Branch 28636: 1
Branch 28637: 1
Branch 28638: 1
Branch 28639: 1
Branch 28640: 1
Branch 28641: 1
Branch 28642: 1
Branch 28643: 1
Branch 28644: 1
Branch 28645: 1
Branch 28646: 1
Branch 28647: 1
Branch 28648: 1
Branch 28649: 1
Branch 28650: 1
Branch 28651: 1
Branch 28652: 1
Branch 28653: 1
Branch 28654: 1
Branch 28655: 1
Branch 28656: 1
Branch 28657: 1
Branch 28658: 1
Branch 28659: 1
Branch 28660: 1
Branch 28661: 1
Branch 28662: 1
Branch 28663: 1
Branch 28664: 1
Branch 28665: 1
Branch 28666: 1
Branch 28667: 1
Branch 28668: 1
Branch 28669: 1
Branch 28670: 1
Branch 28671: 1
Branch 28672: 1
Branch 28673: 1
Branch 28674: 1
Branch 28675: 1
Branch 28676: 1
Branch 28677: 1
Branch 28678: 1
Branch 28679: 1
Branch 28680: 1
Branch 28681: 1
Branch 28682: 1
Branch 28683: 1
Branch 28684: 1
Branch 28685: 1
Branch 28686: 1
Branch 28687: 1
Branch 28688: 1
Branch 28689: 1
Branch 28690: 1
Branch 28691: 1
Branch 28692: 1
Branch 28693: 1
Branch 28694: 1
Branch 28695: 1
Branch 28696: 1
Branch 28697: 1
Branch 28698: 1
Branch 28699: 1
Branch 28700: 1
Branch 28701: 1
Branch 28702: 1
Branch 28703: 1
Branch 28704: 1
Branch 28705: 1
Branch 28706: 1
Branch 28707: 1
Branch 28708: 1
Branch 28709: 1
Branch 28710: 1
Branch 28711: 1
Branch 28712: 1
Branch 28713: 1
Branch 28714: 1
Branch 28715: 1
Branch 28716: 1
Branch 28717: 1
Branch 28718: 1
Branch 28719: 1
Branch 28720: 1
Branch 28721: 1
Branch 28722: 1
Branch 28723: 1
Branch 28724: 1
Branch 28725: 1
Branch 28726: 1
Branch 28727: 1
Branch 28728: 1
Branch 28729: 1
Branch 28730: 1
Branch 28731: 1
Branch 28732: 1
Branch 28733: 1
Branch 28734: 1
Branch 28735: 1
Branch 28736: 1
Branch 28737: 1
Branch 28738: 1
Branch 28739: 1
Branch 28740: 1
Branch 28741: 1
Branch 28742: 1
Branch 28743: 1
Branch 28744: 1
Branch 28745: 1
Branch 28746: 1
Branch 28747: 1
Branch 28748: 1
Branch 28749: 1
Branch 28750: 1
Branch 28751: 1
Branch 28752: 1
Branch 28753: 1
Branch 28754: 1
Branch 28755: 1
Branch 28756: 1
Branch 28757: 1
Branch 28758: 1
Branch 28759: 1
Branch 28760: 1
Branch 28761: 1
Branch 28762: 1
Branch 28763: 1
Branch 28764: 1
Branch 28765: 1
Branch 28766: 1
Branch 28767: 1
Branch 28768: 1
Branch 28769: 1
Branch 28770: 1
Branch 28771: 1
Branch 28772: 1
Branch 28773: 1
Branch 28774: 1
Branch 28775: 1
Branch 28776: 1
Branch 28777: 1
Branch 28778: 1
Branch 28779: 1
Branch 28780: 1
Branch 28781: 1
Branch 28782: 1
Branch 28783: 1
Branch 28784: 1
Branch 28785: 1
Branch 28786: 1
Branch 28787: 1
Branch 28788: 1
Branch 28789: 1
Branch 28790: 1
Branch 28791: 1
Branch 28792: 1
Branch 28793: 1
Branch 28794: 1
Branch 28795: 1
Branch 28796: 1
Branch 28797: 1
Branch 28798: 1
Branch 28799: 1
Branch 28800: 1
Branch 28801: 1
Branch 28802: 1
Branch 28803: 1
Branch 28804: 1
Branch 28805: 1
Branch 28806: 1
Branch 28807: 1
Branch 28808: 1
Branch 28809: 1
Branch 28810: 1
Branch 28811: 1
Branch 28812: 1
Branch 28813: 1
Branch 28814: 1
Branch 28815: 1
Branch 28816: 1
Branch 28817: 1
Branch 28818: 1
Branch 28819: 1
Branch 28820: 1
Branch 28821: 1
Branch 28822: 1
Branch 28823: 1
Branch 28824: 1
Branch 28825: 1
Branch 28826: 1
Branch 28827: 1
Branch 28828: 1
Branch 28829: 1
Branch 28830: 1
Branch 28831: 1
Branch 28832: 1
Branch 28833: 1
Branch 28834: 1
Branch 28835: 1
Branch 28836: 1
Branch 28837: 1
Branch 28838: 1
Branch 28839: 1
Branch 28840: 1
Branch 28841: 1
Branch 28842: 1
Branch 28843: 1
Branch 28844: 1
Branch 28845: 1
Branch 28846: 1
Branch 28847: 1
Branch 28848: 1
Branch 28849: 1
Branch 28850: 1
Branch 28851: 1
Branch 28852: 1
Branch 28853: 1
Branch 28854: 1
Branch 28855: 1
Branch 28856: 1
Branch 28857: 1
Branch 28858: 1
Branch 28859: 1
Branch 28860: 1
Branch 28861: 1
Branch 28862: 1
Branch 28863: 1
Branch 28864: 1
Branch 28865: 1
Branch 28866: 1
Branch 28867: 1
Branch 28868: 1
Branch 28869: 1
Branch 28870: 1
Branch 28871: 1
Branch 28872: 1
Branch 28873: 1
Branch 28874: 1
Branch 28875: 1
Branch 28876: 1
Branch 28877: 1
Branch 28878: 1
Branch 28879: 1
Branch 28880: 1
Branch 28881: 1
Branch 28882: 1
Branch 28883: 1
Branch 28884: 1
Branch 28885: 1
Branch 28886: 1
Branch 28887: 1
Branch 28888: 1
Branch 28889: 1
Branch 28890: 1
Branch 28891: 1
Branch 28892: 1
Branch 28893: 1
Branch 28894: 1
Branch 28895: 1
Branch 28896: 1
Branch 28897: 1
Branch 28898: 1
Branch 28899: 1
Branch 28900: 1
Branch 28901: 1
Branch 28902: 1
Branch 28903: 1
Branch 28904: 1
Branch 28905: 1
Branch 28906: 1
Branch 28907: 1
Branch 28908: 1
Branch 28909: 1
Branch 28910: 1
Branch 28911: 1
Branch 28912: 1
Branch 28913: 1
Branch 28914: 1
Branch 28915: 1
Branch 28916: 1
Branch 28917: 1
Branch 28918: 1
Branch 28919: 1
Branch 28920: 1
Branch 28921: 1
Branch 28922: 1
Branch 28923: 1
Branch 28924: 1
Branch 28925: 1
Branch 28926: 1
Branch 28927: 1
Branch 28928: 1
Branch 28929: 1
Branch 28930: 1
Branch 28931: 1
Branch 28932: 1
Branch 28933: 1
Branch 28934: 1
Branch 28935: 1
Branch 28936: 1
Branch 28937: 1
Branch 28938: 1
Branch 28939: 1
Branch 28940: 1
Branch 28941: 1
Branch 28942: 1
Branch 28943: 1
Branch 28944: 1
Branch 28945: 1
Branch 28946: 1
Branch 28947: 1
Branch 28948: 1
Branch 28949: 1
Branch 28950: 1
Branch 28951: 1
Branch 28952: 1
Branch 28953: 1
Branch 28954: 1
Branch 28955: 1
Branch 28956: 1
Branch 28957: 1
Branch 28958: 1
Branch 28959: 1
Branch 28960: 1
Branch 28961: 1
Branch 28962: 1
Branch 28963: 1
Branch 28964: 1
Branch 28965: 1
Branch 28966: 1
Branch 28967: 1
Branch 28968: 1
Branch 28969: 1
Branch 28970: 1
Branch 28971: 1
Branch 28972: 1
Branch 28973: 1
Branch 28974: 1
Branch 28975: 1
Branch 28976: 1
Branch 28977: 1
Branch 28978: 1
Branch 28979: 1
Branch 28980: 1
Branch 28981: 1
Branch 28982: 1
Branch 28983: 1
Branch 28984: 1
Branch 28985: 1
Branch 28986: 1
Branch 28987: 1
Branch 28988: 1
Branch 28989: 1
Branch 28990: 1
Branch 28991: 1
Branch 28992: 1
Branch 28993: 1
Branch 28994: 1
Branch 28995: 1
Branch 28996: 1
Branch 28997: 1
Branch 28998: 1
Branch 28999: 1
Branch 29000: 1
Branch 29001: 1
Branch 29002: 1
Branch 29003: 1
Branch 29004: 1
Branch 29005: 1
Branch 29006: 1
Branch 29007: 1
Branch 29008: 1
Branch 29009: 1
Branch 29010: 1
Branch 29011: 1
Branch 29012: 1
Branch 29013: 1
Branch 29014: 1
Branch 29015: 1
Branch 29016: 1
Branch 29017: 1
Branch 29018: 1
Branch 29019: 1
Branch 29020: 1
Branch 29021: 1
Branch 29022: 1
Branch 29023: 1
Branch 29024: 1
Branch 29025: 1
Branch 29026: 1
Branch 29027: 1
Branch 29028: 1
Branch 29029: 1
Branch 29030: 1
Branch 29031: 1
Branch 29032: 1
Branch 29033: 1
Branch 29034: 1
Branch 29035: 1
Branch 29036: 1
Branch 29037: 1
Branch 29038: 1
Branch 29039: 1
Branch 29040: 1
Branch 29041: 1
Branch 29042: 1
Branch 29043: 1
Branch 29044: 1
Branch 29045: 1
Branch 29046: 1
Branch 29047: 1
Branch 29048: 1
Branch 29049: 1
Branch 29050: 1
Branch 29051: 1
Branch 29052: 1
Branch 29053: 1
Branch 29054: 1
Branch 29055: 1
Branch 29056: 1
Branch 29057: 1
Branch 29058: 1
Branch 29059: 1
Branch 29060: 1
Branch 29061: 1
Branch 29062: 1
Branch 29063: 1
Branch 29064: 1
Branch 29065: 1
Branch 29066: 1
Branch 29067: 1
Branch 29068: 1
Branch 29069: 1
Branch 29070: 1
Branch 29071: 1
Branch 29072: 1
Branch 29073: 1
Branch 29074: 1
Branch 29075: 1
Branch 29076: 1
Branch 29077: 1
Branch 29078: 1
Branch 29079: 1
Branch 29080: 1
Branch 29081: 1
Branch 29082: 1
Branch 29083: 1
Branch 29084: 1
Branch 29085: 1
Branch 29086: 1
Branch 29087: 1
Branch 29088: 1
Branch 29089: 1
Branch 29090: 1
Branch 29091: 1
Branch 29092: 1
Branch 29093: 1
Branch 29094: 1
Branch 29095: 1
Branch 29096: 1
Branch 29097: 1
Branch 29098: 1
Branch 29099: 1
Branch 29100: 1
Branch 29101: 1
Branch 29102: 1
Branch 29103: 1
Branch 29104: 1
Branch 29105: 1
Branch 29106: 1
Branch 29107: 1
Branch 29108: 1
Branch 29109: 1
Branch 29110: 1
Branch 29111: 1
Branch 29112: 1
Branch 29113: 1
Branch 29114: 1
Branch 29115: 1
Branch 29116: 1
Branch 29117: 1
Branch 29118: 1
Branch 29119: 1
Branch 29120: 1
Branch 29121: 1
Branch 29122: 1
Branch 29123: 1
Branch 29124: 1
Branch 29125: 1
Branch 29126: 1
Branch 29127: 1
Branch 29128: 1
Branch 29129: 1
Branch 29130: 1
Branch 29131: 1
Branch 29132: 1
Branch 29133: 1
Branch 29134: 1
Branch 29135: 1
Branch 29136: 1
Branch 29137: 1
Branch 29138: 1
Branch 29139: 1
Branch 29140: 1
Branch 29141: 1
Branch 29142: 1
Branch 29143: 1
Branch 29144: 1
Branch 29145: 1
Branch 29146: 1
Branch 29147: 1
Branch 29148: 1
Branch 29149: 1
Branch 29150: 1
Branch 29151: 1
Branch 29152: 1
Branch 29153: 1
Branch 29154: 1
Branch 29155: 1
Branch 29156: 1
Branch 29157: 1
Branch 29158: 1
Branch 29159: 1
Branch 29160: 1
Branch 29161: 1
Branch 29162: 1
Branch 29163: 1
Branch 29164: 1
Branch 29165: 1
Branch 29166: 1
Branch 29167: 1
Branch 29168: 1
Branch 29169: 1
Branch 29170: 1
Branch 29171: 1
Branch 29172: 1
Branch 29173: 1
Branch 29174: 1
Branch 29175: 1
Branch 29176: 1
Branch 29177: 1
Branch 29178: 1
Branch 29179: 1
Branch 29180: 1
Branch 29181: 1
Branch 29182: 1
Branch 29183: 1
Branch 29184: 1
Branch 29185: 1
Branch 29186: 1
Branch 29187: 1
Branch 29188: 1
Branch 29189: 1
Branch 29190: 1
Branch 29191: 1
Branch 29192: 1
Branch 29193: 1
Branch 29194: 1
Branch 29195: 1
Branch 29196: 1
Branch 29197: 1
Branch 29198: 1
Branch 29199: 1
Branch 29200: 1
Branch 29201: 1
Branch 29202: 1
Branch 29203: 1
Branch 29204: 1
Branch 29205: 1
Branch 29206: 1
Branch 29207: 1
Branch 29208: 1
Branch 29209: 1
Branch 29210: 1
Branch 29211: 1
Branch 29212: 1
Branch 29213: 1
Branch 29214: 1
Branch 29215: 1
Branch 29216: 1
Branch 29217: 1
Branch 29218: 1
Branch 29219: 1
Branch 29220: 1
Branch 29221: 1
Branch 29222: 1
Branch 29223: 1
Branch 29224: 1
Branch 29225: 1
Branch 29226: 1
Branch 29227: 1
Branch 29228: 1
Branch 29229: 1
Branch 29230: 1
Branch 29231: 1
Branch 29232: 1
Branch 29233: 1
Branch 29234: 1
Branch 29235: 1
Branch 29236: 1
Branch 29237: 1
Branch 29238: 1
Branch 29239: 1
Branch 29240: 1
Branch 29241: 1
Branch 29242: 1
Branch 29243: 1
Branch 29244: 1
Branch 29245: 1
Branch 29246: 1
Branch 29247: 1
Branch 29248: 1
Branch 29249: 1
Branch 29250: 1
Branch 29251: 1
Branch 29252: 1
Branch 29253: 1
Branch 29254: 1
Branch 29255: 1
Branch 29256: 1
Branch 29257: 1
Branch 29258: 1
Branch 29259: 1
Branch 29260: 1
Branch 29261: 1
Branch 29262: 1
Branch 29263: 1
Branch 29264: 1
Branch 29265: 1
Branch 29266: 1
Branch 29267: 1
Branch 29268: 1
Branch 29269: 1
Branch 29270: 1
Branch 29271: 1
Branch 29272: 1
Branch 29273: 1
Branch 29274: 1
Branch 29275: 1
Branch 29276: 1
Branch 29277: 1
Branch 29278: 1
Branch 29279: 1
Branch 29280: 1
Branch 29281: 1
Branch 29282: 1
Branch 29283: 1
Branch 29284: 1
Branch 29285: 1
Branch 29286: 1
Branch 29287: 1
Branch 29288: 1
Branch 29289: 1
Branch 29290: 1
Branch 29291: 1
Branch 29292: 1
Branch 29293: 1
Branch 29294: 1
Branch 29295: 1
Branch 29296: 1
Branch 29297: 1
Branch 29298: 1
Branch 29299: 1
Branch 29300: 1
Branch 29301: 1
Branch 29302: 1
Branch 29303: 1
Branch 29304: 1
Branch 29305: 1
Branch 29306: 1
Branch 29307: 1
Branch 29308: 1
Branch 29309: 1
Branch 29310: 1
Branch 29311: 1
Branch 29312: 1
Branch 29313: 1
Branch 29314: 1
Branch 29315: 1
Branch 29316: 1
Branch 29317: 1
Branch 29318: 1
Branch 29319: 1
Branch 29320: 1
Branch 29321: 1
Branch 29322: 1
Branch 29323: 1
Branch 29324: 1
Branch 29325: 1
Branch 29326: 1
Branch 29327: 1
Branch 29328: 1
Branch 29329: 1
Branch 29330: 1
Branch 29331: 1
Branch 29332: 1
Branch 29333: 1
Branch 29334: 1
Branch 29335: 1
Branch 29336: 1
Branch 29337: 1
Branch 29338: 1
Branch 29339: 1
Branch 29340: 1
Branch 29341: 1
Branch 29342: 1
Branch 29343: 1
Branch 29344: 1
Branch 29345: 1
Branch 29346: 1
Branch 29347: 1
Branch 29348: 1
Branch 29349: 1
Branch 29350: 1
Branch 29351: 1
Branch 29352: 1
Branch 29353: 1
Branch 29354: 1
Branch 29355: 1
Branch 29356: 1
Branch 29357: 1
Branch 29358: 1
Branch 29359: 1
Branch 29360: 1
Branch 29361: 1
Branch 29362: 1
Branch 29363: 1
Branch 29364: 1
Branch 29365: 1
Branch 29366: 1
Branch 29367: 1
Branch 29368: 1
Branch 29369: 1
Branch 29370: 1
Branch 29371: 1
Branch 29372: 1
Branch 29373: 1
Branch 29374: 1
Branch 29375: 1
Branch 29376: 1
Branch 29377: 1
Branch 29378: 1
Branch 29379: 1
Branch 29380: 1
Branch 29381: 1
Branch 29382: 1
Branch 29383: 1
Branch 29384: 1
Branch 29385: 1
Branch 29386: 1
Branch 29387: 1
Branch 29388: 1
Branch 29389: 1
Branch 29390: 1
Branch 29391: 1
Branch 29392: 1
Branch 29393: 1
Branch 29394: 1
Branch 29395: 1
Branch 29396: 1
Branch 29397: 1
Branch 29398: 1
Branch 29399: 1
Branch 29400: 1
Branch 29401: 1
Branch 29402: 1
Branch 29403: 1
Branch 29404: 1
Branch 29405: 1
Branch 29406: 1
Branch 29407: 1
Branch 29408: 1
Branch 29409: 1
Branch 29410: 1
Branch 29411: 1
Branch 29412: 1
Branch 29413: 1
Branch 29414: 1
Branch 29415: 1
Branch 29416: 1
Branch 29417: 1
Branch 29418: 1
Branch 29419: 1
Branch 29420: 1
Branch 29421: 1
Branch 29422: 1
Branch 29423: 1
Branch 29424: 1
Branch 29425: 1
Branch 29426: 1
Branch 29427: 1
Branch 29428: 1
Branch 29429: 1
Branch 29430: 1
Branch 29431: 1
Branch 29432: 1
Branch 29433: 1
Branch 29434: 1
Branch 29435: 1
Branch 29436: 1
Branch 29437: 1
Branch 29438: 1
Branch 29439: 1
Branch 29440: 1
Branch 29441: 1
Branch 29442: 1
Branch 29443: 1
Branch 29444: 1
Branch 29445: 1
Branch 29446: 1
Branch 29447: 1
Branch 29448: 1
Branch 29449: 1
Branch 29450: 1
Branch 29451: 1
Branch 29452: 1
Branch 29453: 1
Branch 29454: 1
Branch 29455: 1
Branch 29456: 1
Branch 29457: 1
Branch 29458: 1
Branch 29459: 1
Branch 29460: 1
Branch 29461: 1
Branch 29462: 1
Branch 29463: 1
Branch 29464: 1
Branch 29465: 1
Branch 29466: 1
Branch 29467: 1
Branch 29468: 1
Branch 29469: 1
Branch 29470: 1
Branch 29471: 1
Branch 29472: 1
Branch 29473: 1
Branch 29474: 1
Branch 29475: 1
Branch 29476: 1
Branch 29477: 1
Branch 29478: 1
Branch 29479: 1
Branch 29480: 1
Branch 29481: 1
Branch 29482: 1
Branch 29483: 1
Branch 29484: 1
Branch 29485: 1
Branch 29486: 1
Branch 29487: 1
Branch 29488: 1
Branch 29489: 1
Branch 29490: 1
Branch 29491: 1
Branch 29492: 1
Branch 29493: 1
Branch 29494: 1
Branch 29495: 1
Branch 29496: 1
Branch 29497: 1
Branch 29498: 1
Branch 29499: 1
Branch 29500: 1
Branch 29501: 1
Branch 29502: 1
Branch 29503: 1
Branch 29504: 1
Branch 29505: 1
Branch 29506: 1
Branch 29507: 1
Branch 29508: 1
Branch 29509: 1
Branch 29510: 1
Branch 29511: 1
Branch 29512: 1
Branch 29513: 1
Branch 29514: 1
Branch 29515: 1
Branch 29516: 1
Branch 29517: 1
Branch 29518: 1
Branch 29519: 1
Branch 29520: 1
Branch 29521: 1
Branch 29522: 1
Branch 29523: 1
Branch 29524: 1
Branch 29525: 1
Branch 29526: 1
Branch 29527: 1
Branch 29528: 1
Branch 29529: 1
Branch 29530: 1
Branch 29531: 1
Branch 29532: 1
Branch 29533: 1
Branch 29534: 1
Branch 29535: 1
Branch 29536: 1
Branch 29537: 1
Branch 29538: 1
Branch 29539: 1
Branch 29540: 1
Branch 29541: 1
Branch 29542: 1
Branch 29543: 1
Branch 29544: 1
Branch 29545: 1
Branch 29546: 1
Branch 29547: 1
Branch 29548: 1
Branch 29549: 1
Branch 29550: 1
Branch 29551: 1
Branch 29552: 1
Branch 29553: 1
Branch 29554: 1
Branch 29555: 1
Branch 29556: 1
Branch 29557: 1
Branch 29558: 1
Branch 29559: 1
Branch 29560: 1
Branch 29561: 1
Branch 29562: 1
Branch 29563: 1
Branch 29564: 1
Branch 29565: 1
Branch 29566: 1
Branch 29567: 1
Branch 29568: 1
Branch 29569: 1
Branch 29570: 1
Branch 29571: 1
Branch 29572: 1
Branch 29573: 1
Branch 29574: 1
Branch 29575: 1
Branch 29576: 1
Branch 29577: 1
Branch 29578: 1
Branch 29579: 1
Branch 29580: 1
Branch 29581: 1
Branch 29582: 1
Branch 29583: 1
Branch 29584: 1
Branch 29585: 1
Branch 29586: 1
Branch 29587: 1
Branch 29588: 1
Branch 29589: 1
Branch 29590: 1
Branch 29591: 1
Branch 29592: 1
Branch 29593: 1
Branch 29594: 1
Branch 29595: 1
Branch 29596: 1
Branch 29597: 1
Branch 29598: 1
Branch 29599: 1
Branch 29600: 1
Branch 29601: 1
Branch 29602: 1
Branch 29603: 1
Branch 29604: 1
Branch 29605: 1
Branch 29606: 1
Branch 29607: 1
Branch 29608: 1
Branch 29609: 1
Branch 29610: 1
Branch 29611: 1
Branch 29612: 1
Branch 29613: 1
Branch 29614: 1
Branch 29615: 1
Branch 29616: 1
Branch 29617: 1
Branch 29618: 1
Branch 29619: 1
Branch 29620: 1
Branch 29621: 1
Branch 29622: 1
Branch 29623: 1
Branch 29624: 1
Branch 29625: 1
Branch 29626: 1
Branch 29627: 1
Branch 29628: 1
Branch 29629: 1
Branch 29630: 1
Branch 29631: 1
Branch 29632: 1
Branch 29633: 1
Branch 29634: 1
Branch 29635: 1
Branch 29636: 1
Branch 29637: 1
Branch 29638: 1
Branch 29639: 1
Branch 29640: 1
Branch 29641: 1
Branch 29642: 1
Branch 29643: 1
Branch 29644: 1
Branch 29645: 1
Branch 29646: 1
Branch 29647: 1
Branch 29648: 1
Branch 29649: 1
Branch 29650: 1
Branch 29651: 1
Branch 29652: 1
Branch 29653: 1
Branch 29654: 1
Branch 29655: 1
Branch 29656: 1
Branch 29657: 1
Branch 29658: 1
Branch 29659: 1
Branch 29660: 1
Branch 29661: 1
Branch 29662: 1
Branch 29663: 1
Branch 29664: 1
Branch 29665: 1
Branch 29666: 1
Branch 29667: 1
Branch 29668: 1
Branch 29669: 1
Branch 29670: 1
Branch 29671: 1
Branch 29672: 1
Branch 29673: 1
Branch 29674: 1
Branch 29675: 1
Branch 29676: 1
Branch 29677: 1
Branch 29678: 1
Branch 29679: 1
Branch 29680: 1
Branch 29681: 1
Branch 29682: 1
Branch 29683: 1
Branch 29684: 1
Branch 29685: 1
Branch 29686: 1
Branch 29687: 1
Branch 29688: 1
Branch 29689: 1
Branch 29690: 1
Branch 29691: 1
Branch 29692: 1
Branch 29693: 1
Branch 29694: 1
Branch 29695: 1
Branch 29696: 1
Branch 29697: 1
Branch 29698: 1
Branch 29699: 1
Branch 29700: 1
Branch 29701: 1
Branch 29702: 1
Branch 29703: 1
Branch 29704: 1
Branch 29705: 1
Branch 29706: 1
Branch 29707: 1
Branch 29708: 1
Branch 29709: 1
Branch 29710: 1
Branch 29711: 1
Branch 29712: 1
Branch 29713: 1
Branch 29714: 1
Branch 29715: 1
Branch 29716: 1
Branch 29717: 1
Branch 29718: 1
Branch 29719: 1
Branch 29720: 1
Branch 29721: 1
Branch 29722: 1
Branch 29723: 1
Branch 29724: 1
Branch 29725: 1
Branch 29726: 1
Branch 29727: 1
Branch 29728: 1
Branch 29729: 1
Branch 29730: 1
Branch 29731: 1
Branch 29732: 1
Branch 29733: 1
Branch 29734: 1
Branch 29735: 1
Branch 29736: 1
Branch 29737: 1
Branch 29738: 1
Branch 29739: 1
Branch 29740: 1
Branch 29741: 1
Branch 29742: 1
Branch 29743: 1
Branch 29744: 1
Branch 29745: 1
Branch 29746: 1
Branch 29747: 1
Branch 29748: 1
Branch 29749: 1
Branch 29750: 1
Branch 29751: 1
Branch 29752: 1
Branch 29753: 1
Branch 29754: 1
Branch 29755: 1
Branch 29756: 1
Branch 29757: 1
Branch 29758: 1
Branch 29759: 1
Branch 29760: 1
Branch 29761: 1
Branch 29762: 1
Branch 29763: 1
Branch 29764: 1
Branch 29765: 1
Branch 29766: 1
Branch 29767: 1
Branch 29768: 1
Branch 29769: 1
Branch 29770: 1
Branch 29771: 1
Branch 29772: 1
Branch 29773: 1
Branch 29774: 1
Branch 29775: 1
Branch 29776: 1
Branch 29777: 1
Branch 29778: 1
Branch 29779: 1
Branch 29780: 1
Branch 29781: 1
Branch 29782: 1
Branch 29783: 1
Branch 29784: 1
Branch 29785: 1
Branch 29786: 1
Branch 29787: 1
Branch 29788: 1
Branch 29789: 1
Branch 29790: 1
Branch 29791: 1
Branch 29792: 1
Branch 29793: 1
Branch 29794: 1
Branch 29795: 1
Branch 29796: 1
Branch 29797: 1
Branch 29798: 1
Branch 29799: 1
Branch 29800: 1
Branch 29801: 1
Branch 29802: 1
Branch 29803: 1
Branch 29804: 1
Branch 29805: 1
Branch 29806: 1
Branch 29807: 1
Branch 29808: 1
Branch 29809: 1
Branch 29810: 1
Branch 29811: 1
Branch 29812: 1
Branch 29813: 1
Branch 29814: 1
Branch 29815: 1
Branch 29816: 1
Branch 29817: 1
Branch 29818: 1
Branch 29819: 1
Branch 29820: 1
Branch 29821: 1
Branch 29822: 1
Branch 29823: 1
Branch 29824: 1
Branch 29825: 1
Branch 29826: 1
Branch 29827: 1
Branch 29828: 1
Branch 29829: 1
Branch 29830: 1
Branch 29831: 1
Branch 29832: 1
Branch 29833: 1
Branch 29834: 1
Branch 29835: 1
Branch 29836: 1
Branch 29837: 1
Branch 29838: 1
Branch 29839: 1
Branch 29840: 1
Branch 29841: 1
Branch 29842: 1
Branch 29843: 1
Branch 29844: 1
Branch 29845: 1
Branch 29846: 1
Branch 29847: 1
Branch 29848: 1
Branch 29849: 1
Branch 29850: 1
Branch 29851: 1
Branch 29852: 1
Branch 29853: 1
Branch 29854: 1
Branch 29855: 1
Branch 29856: 1
Branch 29857: 1
Branch 29858: 1
Branch 29859: 1
Branch 29860: 1
Branch 29861: 1
Branch 29862: 1
Branch 29863: 1
Branch 29864: 1
Branch 29865: 1
Branch 29866: 1
Branch 29867: 1
Branch 29868: 1
Branch 29869: 1
Branch 29870: 1
Branch 29871: 1
Branch 29872: 1
Branch 29873: 1
Branch 29874: 1
Branch 29875: 1
Branch 29876: 1
Branch 29877: 1
Branch 29878: 1
Branch 29879: 1
Branch 29880: 1
Branch 29881: 1
Branch 29882: 1
Branch 29883: 1
Branch 29884: 1
Branch 29885: 1
Branch 29886: 1
Branch 29887: 1
Branch 29888: 1
Branch 29889: 1
Branch 29890: 1
Branch 29891: 1
Branch 29892: 1
Branch 29893: 1
Branch 29894: 1
Branch 29895: 1
Branch 29896: 1
Branch 29897: 1
Branch 29898: 1
Branch 29899: 1
Branch 29900: 1
Branch 29901: 1
Branch 29902: 1
Branch 29903: 1
Branch 29904: 1
Branch 29905: 1
Branch 29906: 1
Branch 29907: 1
Branch 29908: 1
Branch 29909: 1
Branch 29910: 1
Branch 29911: 1
Branch 29912: 1
Branch 29913: 1
Branch 29914: 1
Branch 29915: 1
Branch 29916: 1
Branch 29917: 1
Branch 29918: 1
Branch 29919: 1
Branch 29920: 1
Branch 29921: 1
Branch 29922: 1
Branch 29923: 1
Branch 29924: 1
Branch 29925: 1
Branch 29926: 1
Branch 29927: 1
Branch 29928: 1
Branch 29929: 1
Branch 29930: 1
Branch 29931: 1
Branch 29932: 1
Branch 29933: 1
Branch 29934: 1
Branch 29935: 1
Branch 29936: 1
Branch 29937: 1
Branch 29938: 1
Branch 29939: 1
Branch 29940: 1
Branch 29941: 1
Branch 29942: 1
Branch 29943: 1
Branch 29944: 1
Branch 29945: 1
Branch 29946: 1
Branch 29947: 1
Branch 29948: 1
Branch 29949: 1
Branch 29950: 1
Branch 29951: 1
Branch 29952: 1
Branch 29953: 1
Branch 29954: 1
Branch 29955: 1
Branch 29956: 1
Branch 29957: 1
Branch 29958: 1
Branch 29959: 1
Branch 29960: 1
Branch 29961: 1
Branch 29962: 1
Branch 29963: 1
Branch 29964: 1
Branch 29965: 1
Branch 29966: 1
Branch 29967: 1
Branch 29968: 1
Branch 29969: 1
Branch 29970: 1
Branch 29971: 1
Branch 29972: 1
Branch 29973: 1
Branch 29974: 1
Branch 29975: 1
Branch 29976: 1
Branch 29977: 1
Branch 29978: 1
Branch 29979: 1
Branch 29980: 1
Branch 29981: 1
Branch 29982: 1
Branch 29983: 1
Branch 29984: 1
Branch 29985: 1
Branch 29986: 1
Branch 29987: 1
Branch 29988: 1
Branch 29989: 1
Branch 29990: 1
Branch 29991: 1
Branch 29992: 1
Branch 29993: 1
Branch 29994: 1
Branch 29995: 1
Branch 29996: 1
Branch 29997: 1
Branch 29998: 1
Branch 29999: 1
Branch 30000: 1
Branch 30001: 1
Branch 30002: 1
Branch 30003: 1
Branch 30004: 1
Branch 30005: 1
Branch 30006: 1
Branch 30007: 1
Branch 30008: 1
Branch 30009: 1
Branch 30010: 1
Branch 30011: 1
Branch 30012: 1
Branch 30013: 1
Branch 30014: 1
Branch 30015: 1
Branch 30016: 1
Branch 30017: 1
Branch 30018: 1
Branch 30019: 1
Branch 30020: 1
Branch 30021: 1
Branch 30022: 1
Branch 30023: 1
Branch 30024: 1
Branch 30025: 1
Branch 30026: 1
Branch 30027: 1
Branch 30028: 1
Branch 30029: 1
Branch 30030: 1
Branch 30031: 1
Branch 30032: 1
Branch 30033: 1
Branch 30034: 1
Branch 30035: 1
Branch 30036: 1
Branch 30037: 1
Branch 30038: 1
Branch 30039: 1
Branch 30040: 1
Branch 30041: 1
Branch 30042: 1
Branch 30043: 1
Branch 30044: 1
Branch 30045: 1
Branch 30046: 1
Branch 30047: 1
Branch 30048: 1
Branch 30049: 1
Branch 30050: 1
Branch 30051: 1
Branch 30052: 1
Branch 30053: 1
Branch 30054: 1
Branch 30055: 1
Branch 30056: 1
Branch 30057: 1
Branch 30058: 1
Branch 30059: 1
Branch 30060: 1
Branch 30061: 1
Branch 30062: 1
Branch 30063: 1
Branch 30064: 1
Branch 30065: 1
Branch 30066: 1
Branch 30067: 1
Branch 30068: 1
Branch 30069: 1
Branch 30070: 1
Branch 30071: 1
Branch 30072: 1
Branch 30073: 1
Branch 30074: 1
Branch 30075: 1
Branch 30076: 1
Branch 30077: 1
Branch 30078: 1
Branch 30079: 1
Branch 30080: 1
Branch 30081: 1
Branch 30082: 1
Branch 30083: 1
Branch 30084: 1
Branch 30085: 1
Branch 30086: 1
Branch 30087: 1
Branch 30088: 1
Branch 30089: 1
Branch 30090: 1
Branch 30091: 1
Branch 30092: 1
Branch 30093: 1
Branch 30094: 1
Branch 30095: 1
Branch 30096: 1
Branch 30097: 1
Branch 30098: 1
Branch 30099: 1
Branch 30100: 1
Branch 30101: 1
Branch 30102: 1
Branch 30103: 1
Branch 30104: 1
Branch 30105: 1
Branch 30106: 1
Branch 30107: 1
Branch 30108: 1
Branch 30109: 1
Branch 30110: 1
Branch 30111: 1
Branch 30112: 1
Branch 30113: 1
Branch 30114: 1
Branch 30115: 1
Branch 30116: 1
Branch 30117: 1
Branch 30118: 1
Branch 30119: 1
Branch 30120: 1
Branch 30121: 1
Branch 30122: 1
Branch 30123: 1
Branch 30124: 1
Branch 30125: 1
Branch 30126: 1
Branch 30127: 1
Branch 30128: 1
Branch 30129: 1
Branch 30130: 1
Branch 30131: 1
Branch 30132: 1
Branch 30133: 1
Branch 30134: 1
Branch 30135: 1
Branch 30136: 1
Branch 30137: 1
Branch 30138: 1
Branch 30139: 1
Branch 30140: 1
Branch 30141: 1
Branch 30142: 1
Branch 30143: 1
Branch 30144: 1
Branch 30145: 1
Branch 30146: 1
Branch 30147: 1
Branch 30148: 1
Branch 30149: 1
Branch 30150: 1
Branch 30151: 1
Branch 30152: 1
Branch 30153: 1
Branch 30154: 1
Branch 30155: 1
Branch 30156: 1
Branch 30157: 1
Branch 30158: 1
Branch 30159: 1
Branch 30160: 1
Branch 30161: 1
Branch 30162: 1
Branch 30163: 1
Branch 30164: 1
Branch 30165: 1
Branch 30166: 1
Branch 30167: 1
Branch 30168: 1
Branch 30169: 1
Branch 30170: 1
Branch 30171: 1
Branch 30172: 1
Branch 30173: 1
Branch 30174: 1
Branch 30175: 1
Branch 30176: 1
Branch 30177: 1
Branch 30178: 1
Branch 30179: 1
Branch 30180: 1
Branch 30181: 1
Branch 30182: 1
Branch 30183: 1
Branch 30184: 1
Branch 30185: 1
Branch 30186: 1
Branch 30187: 1
Branch 30188: 1
Branch 30189: 1
Branch 30190: 1
Branch 30191: 1
Branch 30192: 1
Branch 30193: 1
Branch 30194: 1
Branch 30195: 1
Branch 30196: 1
Branch 30197: 1
Branch 30198: 1
Branch 30199: 1
Branch 30200: 1
Branch 30201: 1
Branch 30202: 1
Branch 30203: 1
Branch 30204: 1
Branch 30205: 1
Branch 30206: 1
Branch 30207: 1
Branch 30208: 1
Branch 30209: 1
Branch 30210: 1
Branch 30211: 1
Branch 30212: 1
Branch 30213: 1
Branch 30214: 1
Branch 30215: 1
Branch 30216: 1
Branch 30217: 1
Branch 30218: 1
Branch 30219: 1
Branch 30220: 1
Branch 30221: 1
Branch 30222: 1
Branch 30223: 1
Branch 30224: 1
Branch 30225: 1
Branch 30226: 1
Branch 30227: 1
Branch 30228: 1
Branch 30229: 1
Branch 30230: 1
Branch 30231: 1
Branch 30232: 1
Branch 30233: 1
Branch 30234: 1
Branch 30235: 1
Branch 30236: 1
Branch 30237: 1
Branch 30238: 1
Branch 30239: 1
Branch 30240: 1
Branch 30241: 1
Branch 30242: 1
Branch 30243: 1
Branch 30244: 1
Branch 30245: 1
Branch 30246: 1
Branch 30247: 1
Branch 30248: 1
Branch 30249: 1
Branch 30250: 1
Branch 30251: 1
Branch 30252: 1
Branch 30253: 1
Branch 30254: 1
Branch 30255: 1
Branch 30256: 1
Branch 30257: 1
Branch 30258: 1
Branch 30259: 1
Branch 30260: 1
Branch 30261: 1
Branch 30262: 1
Branch 30263: 1
Branch 30264: 1
Branch 30265: 1
Branch 30266: 1
Branch 30267: 1
Branch 30268: 1
Branch 30269: 1
Branch 30270: 1
Branch 30271: 1
Branch 30272: 1
Branch 30273: 1
Branch 30274: 1
Branch 30275: 1
Branch 30276: 1
Branch 30277: 1
Branch 30278: 1
Branch 30279: 1
Branch 30280: 1
Branch 30281: 1
Branch 30282: 1
Branch 30283: 1
Branch 30284: 1
Branch 30285: 1
Branch 30286: 1
Branch 30287: 1
Branch 30288: 1
Branch 30289: 1
Branch 30290: 1
Branch 30291: 1
Branch 30292: 1
Branch 30293: 1
Branch 30294: 1
Branch 30295: 1
Branch 30296: 1
Branch 30297: 1
Branch 30298: 1
Branch 30299: 1
Branch 30300: 1
Branch 30301: 1
Branch 30302: 1
Branch 30303: 1
Branch 30304: 1
Branch 30305: 1
Branch 30306: 1
Branch 30307: 1
Branch 30308: 1
Branch 30309: 1
Branch 30310: 1
Branch 30311: 1
Branch 30312: 1
Branch 30313: 1
Branch 30314: 1
Branch 30315: 1
Branch 30316: 1
Branch 30317: 1
Branch 30318: 1
Branch 30319: 1
Branch 30320: 1
Branch 30321: 1
Branch 30322: 1
Branch 30323: 1
Branch 30324: 1
Branch 30325: 1
Branch 30326: 1
Branch 30327: 1
Branch 30328: 1
Branch 30329: 1
Branch 30330: 1
Branch 30331: 1
Branch 30332: 1
Branch 30333: 1
Branch 30334: 1
Branch 30335: 1
Branch 30336: 1
Branch 30337: 1
Branch 30338: 1
Branch 30339: 1
Branch 30340: 1
Branch 30341: 1
Branch 30342: 1
Branch 30343: 1
Branch 30344: 1
Branch 30345: 1
Branch 30346: 1
Branch 30347: 1
Branch 30348: 1
Branch 30349: 1
Branch 30350: 1
Branch 30351: 1
Branch 30352: 1
Branch 30353: 1
Branch 30354: 1
Branch 30355: 1
Branch 30356: 1
Branch 30357: 1
Branch 30358: 1
Branch 30359: 1
Branch 30360: 1
Branch 30361: 1
Branch 30362: 1
Branch 30363: 1
Branch 30364: 1
Branch 30365: 1
Branch 30366: 1
Branch 30367: 1
Branch 30368: 1
Branch 30369: 1
Branch 30370: 1
Branch 30371: 1
Branch 30372: 1
Branch 30373: 1
Branch 30374: 1
Branch 30375: 1
Branch 30376: 1
Branch 30377: 1
Branch 30378: 1
Branch 30379: 1
Branch 30380: 1
Branch 30381: 1
Branch 30382: 1
Branch 30383: 1
Branch 30384: 1
Branch 30385: 1
Branch 30386: 1
Branch 30387: 1
Branch 30388: 1
Branch 30389: 1
Branch 30390: 1
Branch 30391: 1
Branch 30392: 1
Branch 30393: 1
Branch 30394: 1
Branch 30395: 1
Branch 30396: 1
Branch 30397: 1
Branch 30398: 1
Branch 30399: 1
Branch 30400: 1
Branch 30401: 1
Branch 30402: 1
Branch 30403: 1
Branch 30404: 1
Branch 30405: 1
Branch 30406: 1
Branch 30407: 1
Branch 30408: 1
Branch 30409: 1
Branch 30410: 1
Branch 30411: 1
Branch 30412: 1
Branch 30413: 1
Branch 30414: 1
Branch 30415: 1
Branch 30416: 1
Branch 30417: 1
Branch 30418: 1
Branch 30419: 1
Branch 30420: 1
Branch 30421: 1
Branch 30422: 1
Branch 30423: 1
Branch 30424: 1
Branch 30425: 1
Branch 30426: 1
Branch 30427: 1
Branch 30428: 1
Branch 30429: 1
Branch 30430: 1
Branch 30431: 1
Branch 30432: 1
Branch 30433: 1
Branch 30434: 1
Branch 30435: 1
Branch 30436: 1
Branch 30437: 1
Branch 30438: 1
Branch 30439: 1
Branch 30440: 1
Branch 30441: 1
Branch 30442: 1
Branch 30443: 1
Branch 30444: 1
Branch 30445: 1
Branch 30446: 1
Branch 30447: 1
Branch 30448: 1
Branch 30449: 1
Branch 30450: 1
Branch 30451: 1
Branch 30452: 1
Branch 30453: 1
Branch 30454: 1
Branch 30455: 1
Branch 30456: 1
Branch 30457: 1
Branch 30458: 1
Branch 30459: 1
Branch 30460: 1
Branch 30461: 1
Branch 30462: 1
Branch 30463: 1
Branch 30464: 1
Branch 30465: 1
Branch 30466: 1
Branch 30467: 1
Branch 30468: 1
Branch 30469: 1
Branch 30470: 1
Branch 30471: 1
Branch 30472: 1
Branch 30473: 1
Branch 30474: 1
Branch 30475: 1
Branch 30476: 1
Branch 30477: 1
Branch 30478: 1
Branch 30479: 1
Branch 30480: 1
Branch 30481: 1
Branch 30482: 1
Branch 30483: 1
Branch 30484: 1
Branch 30485: 1
Branch 30486: 1
Branch 30487: 1
Branch 30488: 1
Branch 30489: 1
Branch 30490: 1
Branch 30491: 1
Branch 30492: 1
Branch 30493: 1
Branch 30494: 1
Branch 30495: 1
Branch 30496: 1
Branch 30497: 1
Branch 30498: 1
Branch 30499: 1
Branch 30500: 1
Branch 30501: 1
Branch 30502: 1
Branch 30503: 1
Branch 30504: 1
Branch 30505: 1
Branch 30506: 1
Branch 30507: 1
Branch 30508: 1
Branch 30509: 1
Branch 30510: 1
Branch 30511: 1
Branch 30512: 1
Branch 30513: 1
Branch 30514: 1
Branch 30515: 1
Branch 30516: 1
Branch 30517: 1
Branch 30518: 1
Branch 30519: 1
Branch 30520: 1
Branch 30521: 1
Branch 30522: 1
Branch 30523: 1
Branch 30524: 1
Branch 30525: 1
Branch 30526: 1
Branch 30527: 1
Branch 30528: 1
Branch 30529: 1
Branch 30530: 1
Branch 30531: 1
Branch 30532: 1
Branch 30533: 1
Branch 30534: 1
Branch 30535: 1
Branch 30536: 1
Branch 30537: 1
Branch 30538: 1
Branch 30539: 1
Branch 30540: 1
Branch 30541: 1
Branch 30542: 1
Branch 30543: 1
Branch 30544: 1
Branch 30545: 1
Branch 30546: 1
Branch 30547: 1
Branch 30548: 1
Branch 30549: 1
Branch 30550: 1
Branch 30551: 1
Branch 30552: 1
Branch 30553: 1
Branch 30554: 1
Branch 30555: 1
Branch 30556: 1
Branch 30557: 1
Branch 30558: 1
Branch 30559: 1
Branch 30560: 1
Branch 30561: 1
Branch 30562: 1
Branch 30563: 1
Branch 30564: 1
Branch 30565: 1
Branch 30566: 1
Branch 30567: 1
Branch 30568: 1
Branch 30569: 1
Branch 30570: 1
Branch 30571: 1
Branch 30572: 1
Branch 30573: 1
Branch 30574: 1
Branch 30575: 1
Branch 30576: 1
Branch 30577: 1
Branch 30578: 1
Branch 30579: 1
Branch 30580: 1
Branch 30581: 1
Branch 30582: 1
Branch 30583: 1
Branch 30584: 1
Branch 30585: 1
Branch 30586: 1
Branch 30587: 1
Branch 30588: 1
Branch 30589: 1
Branch 30590: 1
Branch 30591: 1
Branch 30592: 1
Branch 30593: 1
Branch 30594: 1
Branch 30595: 1
Iteration 1
CondTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            tmp = ((void *)0);
        else if (strcmp(x, "N0") == 0)
            tmp = n0;
        else if (strcmp(x, "N1") == 0)
            tmp = n1;
        else if (strcmp(x, "N2") == 0)
            tmp = n2;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            tmp = ((void *)0);
        else if (strcmp(x, "N0") == 0)
            tmp = n0;
        else if (strcmp(x, "N1") == 0)
            tmp = n1;
        else if (strcmp(x, "N2") == 0)
            tmp = n2;
        }

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}
else if (__get_mutant()==1) {
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}
else if (__get_mutant()==1) {
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((strcmp(x, "N2") == 0) && !(__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}
}
else if (__get_mutant()==1) {
{
    if ((strcmp(x, "N2") == 0) || (__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}
}

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else 
//Patch 0:
{
    if ((strcmp(x, "N2") == 0) && !(__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else 
//Patch 0:
{
    if ((strcmp(x, "N2") == 0) || (__is_neg(16, &(n1), sizeof (n1), &(n2), sizeof (n2), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n0), sizeof (n0), &(node), sizeof (node), &(f), sizeof (f), &(list), sizeof (list), &(n2->name), sizeof (n2->name), &(n1->name), sizeof (n1->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev), &(n2->next), sizeof (n2->next), &(n2->prev), sizeof (n2->prev))))
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        //prophet generated patch
        if (__get_mutant()==0) {
        if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
            node = tmp;
            status = status + 1;
        } else if (status == 1) {
            node->prev = tmp;
            status = status + 1;
        } else if (status == 2) {
            node->next = tmp;
            status = 0;
            list->size = list->size + 1;
            if (list->header == ((void *)0))
                list->header = node;
        }
        }
        else if (__get_mutant()==1) {
        if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
            node = tmp;
            status = status + 1;
        } else if (status == 1) {
            node->prev = tmp;
            status = status + 1;
        } else if (status == 2) {
            node->next = tmp;
            status = 0;
            list->size = list->size + 1;
            if (list->header == ((void *)0))
                list->header = node;
        }
        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node = tmp;
            }
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
else if (__get_mutant()==1) {
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node->prev = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node->prev = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node->prev = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node->prev = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node->prev = tmp;
            }
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
else if (__get_mutant()==1) {
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node->next = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node->next = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node->next = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node->next = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node->next = tmp;
            }
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                list->header = node;
            }
            else if (__get_mutant()==1) {
            if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                list->header = node;
            }

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    //prophet generated patch
    if (__get_mutant()==0) {
    scanf("%d ", res);
    }
    else if (__get_mutant()==1) {
    scanf("%d ", res);
    }
    else if (__get_mutant()==2) {
    scanf("%d ", res);
    }
    else if (__get_mutant()==3) {
    strchr("%d ", res);
    }
    else if (__get_mutant()==4) {
    strchr("%d ", res);
    }
    else if (__get_mutant()==5) {
    wctomb("%d ", res);
    }

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
scanf("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
strchr("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
wctomb("%d ", res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    //prophet generated patch
    if (__get_mutant()==0) {
    if (!(__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 1;
    return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 2;
    return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 20;
    return 0;
    }
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if (!(__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
return 0;

//CodeSeg 1:
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
return 0;

//CodeSeg 1:
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
return 0;

//CodeSeg 1:
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
CondTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;

  //      int cond = ((cnt2 <= (*list)->size) && (p != NULL));
        //BUG comment it out for correct version
//        cond = (cnt2 < (*list)->size);

        while (cnt2< (*list)->size) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           // p = l->next;// BUG LISTERR3
           p = p->next;

          // cond = ((cnt2 <= (*list)->size) && (p!=NULL));
            //BUG comment out for correct version
          // cond = (cnt2 < (*list)->size);
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    
//Patch 0:
if ((__is_neg(10, &(res), sizeof (res), &(list), sizeof (list), &(f), sizeof (f), &(node), sizeof (node), &(status), sizeof (status), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
return 0;

//CodeSeg 1:
}

Testing negative cases!
Testing 1 (with abstract condition)
Iteration 0
Generate a candidate with schema id: 38
Total cnt of passed cond schemas: 6
Total cnt of cond schemas: 88
Counter: 132
Batcher Size:0
The found score 9994963.000000 is greater than current score 4995.000000!
Terminate current session!
Generate a candidate with schema id: 38
Total cnt of passed cond schemas: 6
Total cnt of cond schemas: 88
The first schema id that generates patch: 38
Found a fix! Store to: __fixed_prog.c
Repair process ends successfully!
Total 3189 different repair schemas!!!!
Total 6782 different repair candidate templates for scoring!!!
Total number of compiles: 43
Total number of test eval: 432
