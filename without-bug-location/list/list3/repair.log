Initialize the program!
Verify Test Cases
All passed!
Done Verification
Generating repair candidates!
Processing prog.c
Total 3024 different repair schemas!!!!
Total 6377 different repair candidate templates for scoring!!!
Trying different candidates!
BasicTester pointer: 0xb768660
StringConstTester pointer: 0xb6d9ae8
CondTester pointer: 0xb64cc30
Counter: 1
Batcher Size:0
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((l == p) && !(__abst_hole(l, p, list, res, cnt2, (*list)->size, cnt1, l->next, (*list)->header, l->prev, l->name))) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((l == p) && !(__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 1
Counter: 2
Batcher Size:1
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((l == p) || (__abst_hole(l, p, list, res, cnt2, (*list)->size, cnt1, l->next, (*list)->header, l->prev, l->name))) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((l == p) || (__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 2
Counter: 3
Batcher Size:2
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:106
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N1") == 0) && !(__abst_hole(n0, n1, tmp, n2, status, node, f, n1->name, list, n0->name, argv, argc, n0->next, n0->prev, n1->next, n1->prev)))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 3
Counter: 4
Batcher Size:3
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:106
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N1") == 0) || (__abst_hole(n0, n1, tmp, n2, status, node, f, n1->name, list, n0->name, argv, argc, n0->next, n0->prev, n1->next, n1->prev)))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 4
Counter: 5
Batcher Size:4
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:104
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N0") == 0) && !(__abst_hole(n0, tmp, n1, n2, f, status, node, n0->name, list, argv, argc, n0->next, n0->prev)))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 5
Counter: 6
Batcher Size:5
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:104
--Src File: prog.c
Fragment 0:
{
    if ((strcmp(x, "N0") == 0) || (__abst_hole(n0, tmp, n1, n2, f, status, node, n0->name, list, argv, argc, n0->next, n0->prev)))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}


CondTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 6
Counter: 7
Batcher Size:6
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:102
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "NULL") == 0) && !(__abst_hole(tmp, n0, f, n1, n2, status, node, list, argv, argc)))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;


CondTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 7
Counter: 8
Batcher Size:7
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:102
--Src File: prog.c
Fragment 0:
if ((strcmp(x, "NULL") == 0) || (__abst_hole(tmp, n0, f, n1, n2, status, node, list, argv, argc)))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;


CondTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 8
Counter: 9
Batcher Size:8
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((res == 1) && !(__abst_hole(res, cnt1, list, l)))
    return res;


CondTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 9
Counter: 10
Batcher Size:9
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:56
--Src File: prog.c
Fragment 0:
if ((res == 1) || (__abst_hole(res, cnt1, list, l)))
    return res;


CondTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 10
Counter: 11
Batcher Size:10
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:124
--Src File: prog.c
Fragment 0:
if ((list->header == ((void *)0)) && !(__abst_hole(list, list->header, node, list->size, status, tmp, node->next, f, node->prev, n2, n1, n0, argv, argc, node->name)))
    list->header = node;


CondTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 11
Counter: 12
Batcher Size:11
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:124
--Src File: prog.c
Fragment 0:
if ((list->header == ((void *)0)) || (__abst_hole(list, list->header, node, list->size, status, tmp, node->next, f, node->prev, n2, n1, n0, argv, argc, node->name)))
    list->header = node;


CondTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 12
Counter: 13
Batcher Size:12
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:120
--Src File: prog.c
Fragment 0:
{
    if ((status == 2) && !(__abst_hole(status, node, tmp, node->next, list, node->prev, f, n2, n1, n0, argv, argc, node->name))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 13
Counter: 14
Batcher Size:13
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:120
--Src File: prog.c
Fragment 0:
{
    if ((status == 2) || (__abst_hole(status, node, tmp, node->next, list, node->prev, f, n2, n1, n0, argv, argc, node->name))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 14
Counter: 15
Batcher Size:14
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:111
--Src File: prog.c
Fragment 0:
if ((status == 0) || (__abst_hole(status, node, tmp, n2, n1, node->prev, n0, node->next, list, f, argv, argc, node->name))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}


CondTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 15
Counter: 16
Batcher Size:15
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:115
--Src File: prog.c
Fragment 0:
{
    if ((status == 1) && !(__abst_hole(status, node, tmp, node->prev, n2, node->next, list, n1, n0, f, argv, argc, node->name))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 16
Counter: 17
Batcher Size:16
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:115
--Src File: prog.c
Fragment 0:
{
    if ((status == 1) || (__abst_hole(status, node, tmp, node->prev, n2, node->next, list, n1, n0, f, argv, argc, node->name))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}


CondTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 17
Counter: 18
Batcher Size:17
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:111
--Src File: prog.c
Fragment 0:
if ((status == 0) && !(__abst_hole(status, node, tmp, n2, n1, node->prev, n0, node->next, list, f, argv, argc, node->name))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}


CondTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 18
Counter: 19
Batcher Size:18
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((sz > (*list)->size) && !(__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;


CondTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 19
Counter: 20
Batcher Size:19
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((sz > (*list)->size) || (__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;


CondTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 20
Counter: 21
Batcher Size:20
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((argc < 2) && !(__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 21
Counter: 22
Batcher Size:21
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:77
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) && !(__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 22
Counter: 23
Batcher Size:22
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:77
--Src File: prog.c
Fragment 0:
if ((f == ((void *)0)) || (__abst_hole(f, argv, argc)))
    return 0;


CondTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 23
Counter: 24
Batcher Size:23
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((argc < 2) || (__abst_hole(argc, argv)))
    return 0;


CondTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 24
Counter: 25
Batcher Size:24
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') && !(__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    continue;


CondTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 25
Counter: 26
Batcher Size:25
Preprocess the following candidate with CondTester:
Priority 20000
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((x[0] == '"') || (__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    continue;


CondTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 26
Counter: 27
Batcher Size:26
Preprocess the following candidate with CondTester:
Priority 12480
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt1, (*list)->size, l, l->next, (*list)->header, res, l->prev, l->name)))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


CondTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 27
Counter: 28
Batcher Size:27
Preprocess the following candidate with CondTester:
Priority 12480
At location prog.c:39
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, cnt1, (*list)->size, l, l->next, (*list)->header, res, l->prev, l->name)))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


CondTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 28
Counter: 29
Batcher Size:28
Preprocess the following candidate with CondTester:
Priority 12449
At location prog.c:22
--Src File: prog.c
Fragment 0:
if ((__abst_hole(n, (*n)->next, (*n)->prev, (*n)->name)))
    return;
*n = malloc(sizeof(struct Node));


CondTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 29
Counter: 30
Batcher Size:29
Preprocess the following candidate with CondTester:
Priority 12438
At location prog.c:29
--Src File: prog.c
Fragment 0:
if ((__abst_hole(t, (*t)->header, (*t)->size)))
    return;
*t = malloc(sizeof(struct List));


CondTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 30
Counter: 31
Batcher Size:30
Preprocess the following candidate with CondTester:
Priority 12431
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 1;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 31
Counter: 32
Batcher Size:31
Preprocess the following candidate with CondTester:
Priority 12431
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 2;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 32
Counter: 33
Batcher Size:32
Preprocess the following candidate with CondTester:
Priority 12431
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 20;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 33
Counter: 34
Batcher Size:33
Preprocess the following candidate with CondTester:
Priority 12431
At location prog.c:75
--Src File: prog.c
Fragment 0:
if ((__abst_hole(argc, argv)))
    return 0;
if (argc < 2)
    return 0;


CondTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 34
Counter: 35
Batcher Size:34
Preprocess the following candidate with CondTester:
Priority 9997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    return 0;
sz = sz + 1;


CondTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 35
Counter: 36
Batcher Size:35
Preprocess the following candidate with CondTester:
Priority 9997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    return 1;
sz = sz + 1;


CondTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 36
Counter: 37
Batcher Size:36
Preprocess the following candidate with CondTester:
Priority 9997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if ((__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    break;
sz = sz + 1;


CondTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 37
Counter: 38
Batcher Size:37
Preprocess the following candidate with CondTester:
Priority 9984
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, cnt1, l->next, (*list)->header, l->prev, l->name)))
    return 0;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 38
Counter: 39
Batcher Size:38
Preprocess the following candidate with CondTester:
Priority 9984
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, cnt1, l->next, (*list)->header, l->prev, l->name)))
    return 1;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 39
Counter: 40
Batcher Size:39
Preprocess the following candidate with CondTester:
Priority 9984
At location prog.c:45
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l, p, list, res, cnt2, (*list)->size, cnt1, l->next, (*list)->header, l->prev, l->name)))
    break;
if (l == p) {
    res = 1;
    return res;
}


CondTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 40
Counter: 41
Batcher Size:40
Preprocess the following candidate with CondTester:
Priority 9983
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, p, cnt2, (*list)->size, l, res, cnt1, l->next, (*list)->header, l->prev, l->name)))
    return 0;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }


CondTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 41
Counter: 42
Batcher Size:41
Preprocess the following candidate with CondTester:
Priority 9983
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, p, cnt2, (*list)->size, l, res, cnt1, l->next, (*list)->header, l->prev, l->name)))
    return 1;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }


CondTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 42
Counter: 43
Batcher Size:42
Preprocess the following candidate with CondTester:
Priority 9983
At location prog.c:44
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, p, cnt2, (*list)->size, l, res, cnt1, l->next, (*list)->header, l->prev, l->name)))
    break;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }


CondTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 43
Counter: 44
Batcher Size:43
Preprocess the following candidate with CondTester:
Priority 9973
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 0;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 44
Counter: 45
Batcher Size:44
Preprocess the following candidate with CondTester:
Priority 9973
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 1;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 45
Counter: 46
Batcher Size:45
Preprocess the following candidate with CondTester:
Priority 9973
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 2;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 46
Counter: 47
Batcher Size:46
Preprocess the following candidate with CondTester:
Priority 9973
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    break;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 47
Counter: 48
Batcher Size:47
Preprocess the following candidate with CondTester:
Priority 9973
At location prog.c:99
--Src File: prog.c
Fragment 0:
if ((__abst_hole(f, n0, n2, n1, status, node, list, argv, argc)))
    return 20;
if (x[0] == '"')
    continue;


CondTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 48
Counter: 49
Batcher Size:48
Preprocess the following candidate with CondTester:
Priority 9969
At location prog.c:121
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    break;
node->next = tmp;


CondTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 49
Counter: 50
Batcher Size:49
Preprocess the following candidate with CondTester:
Priority 9969
At location prog.c:121
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 0;
node->next = tmp;


CondTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 50
Counter: 51
Batcher Size:50
Preprocess the following candidate with CondTester:
Priority 9969
At location prog.c:121
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 1;
node->next = tmp;


CondTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 51
Counter: 52
Batcher Size:51
Preprocess the following candidate with CondTester:
Priority 9969
At location prog.c:121
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 2;
node->next = tmp;


CondTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 52
Counter: 53
Batcher Size:52
Preprocess the following candidate with CondTester:
Priority 9969
At location prog.c:121
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->next, status, list, node->prev, f, n2, n1, n0, argv, argc, node->name)))
    return 20;
node->next = tmp;


CondTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 53
Counter: 54
Batcher Size:53
Preprocess the following candidate with CondTester:
Priority 9960
At location prog.c:116
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 0;
node->prev = tmp;


CondTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 54
Counter: 55
Batcher Size:54
Preprocess the following candidate with CondTester:
Priority 9960
At location prog.c:116
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 1;
node->prev = tmp;


CondTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 55
Counter: 56
Batcher Size:55
Preprocess the following candidate with CondTester:
Priority 9960
At location prog.c:116
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 2;
node->prev = tmp;


CondTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 56
Counter: 57
Batcher Size:56
Preprocess the following candidate with CondTester:
Priority 9960
At location prog.c:116
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    return 20;
node->prev = tmp;


CondTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 57
Counter: 58
Batcher Size:57
Preprocess the following candidate with CondTester:
Priority 9960
At location prog.c:116
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, node->prev, status, node->next, list, n2, n1, n0, f, argv, argc, node->name)))
    break;
node->prev = tmp;


CondTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 58
Counter: 59
Batcher Size:58
Preprocess the following candidate with CondTester:
Priority 9958
At location prog.c:112
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 0;
node = tmp;


CondTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 59
Counter: 60
Batcher Size:59
Preprocess the following candidate with CondTester:
Priority 9958
At location prog.c:112
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 1;
node = tmp;


CondTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 60
Counter: 61
Batcher Size:60
Preprocess the following candidate with CondTester:
Priority 9958
At location prog.c:112
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 2;
node = tmp;


CondTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 61
Counter: 62
Batcher Size:61
Preprocess the following candidate with CondTester:
Priority 9958
At location prog.c:112
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    return 20;
node = tmp;


CondTester, a patch instance with id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 62
Counter: 63
Batcher Size:62
Preprocess the following candidate with CondTester:
Priority 9958
At location prog.c:112
--Src File: prog.c
Fragment 0:
if ((__abst_hole(node, tmp, status, n2, node->prev, n1, n0, node->next, list, f, argv, argc, node->name)))
    break;
node = tmp;


CondTester, a patch instance with id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 63
Counter: 64
Batcher Size:63
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 64
Counter: 65
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 65
Counter: 66
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 7500
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 66
Counter: 67
Batcher Size:66
Preprocess the following candidate with StringConstTester:
Priority 7485
At location prog.c:132
--Src File: prog.c
Fragment 0:
printf((__abst_hole()), res);


StringConstTester, a patch instance with id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf(("%d##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Spawn 1 instances, now Total 67
Counter: 68
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 68
Counter: 69
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 69
Counter: 70
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 70
Counter: 71
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 71
Counter: 72
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 72
Counter: 73
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 73
Counter: 74
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 74
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
        return 0;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
        return 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==2) {
    cnt1 = (0);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==3) {
    l = (l);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==4) {
    res = 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==5) {
    res = (res);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==6) {
    res = (cnt1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==7) {
    res = (0);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==8) {
    res = (1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==9) {
    l = (l)->next;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
CondTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if ((__is_neg(9, &(list), sizeof (list), &(cnt1), sizeof (cnt1), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
BasicTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
BasicTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (0);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
res = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
BasicTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = (l)->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Counter: 75
Batcher Size:64
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 75
Counter: 76
Batcher Size:65
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 76
Counter: 77
Batcher Size:66
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 77
Counter: 78
Batcher Size:67
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 78
Counter: 79
Batcher Size:68
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 79
Counter: 80
Batcher Size:69
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 80
Counter: 81
Batcher Size:70
Preprocess the following candidate with BasicTester:
Priority 7480
At location prog.c:39
--Src File: prog.c
Fragment 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }


BasicTester, a patch instance with id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 81
Counter: 82
Batcher Size:71
Preprocess the following candidate with BasicTester:
Priority 7449
At location prog.c:22
--Src File: prog.c
Fragment 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 82
Counter: 83
Batcher Size:72
Preprocess the following candidate with BasicTester:
Priority 7449
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 83
Counter: 84
Batcher Size:73
Preprocess the following candidate with BasicTester:
Priority 7449
At location prog.c:22
--Src File: prog.c
Fragment 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));


BasicTester, a patch instance with id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 84
Counter: 85
Batcher Size:74
Preprocess the following candidate with BasicTester:
Priority 7438
At location prog.c:29
--Src File: prog.c
Fragment 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 85
Counter: 86
Batcher Size:75
Preprocess the following candidate with BasicTester:
Priority 7438
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 86
Counter: 87
Batcher Size:76
Preprocess the following candidate with BasicTester:
Priority 7438
At location prog.c:29
--Src File: prog.c
Fragment 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));


BasicTester, a patch instance with id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 87
Counter: 88
Batcher Size:77
Preprocess the following candidate with BasicTester:
Priority 7431
At location prog.c:75
--Src File: prog.c
Fragment 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;


BasicTester, a patch instance with id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 88
Counter: 89
Batcher Size:78
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:65
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 0;
    return 0;
}


CondTester, a patch instance with id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 89
Counter: 90
Batcher Size:79
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:65
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 1;
    return 0;
}


CondTester, a patch instance with id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 1;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 90
Counter: 91
Batcher Size:80
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:65
--Src File: prog.c
Fragment 0:
{
    if ((__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        break;
    return 0;
}


CondTester, a patch instance with id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        break;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 91
Counter: 92
Batcher Size:81
Preprocess the following candidate with CondTester:
Priority 5000
At location prog.c:65
--Src File: prog.c
Fragment 0:
{
    if (!(__abst_hole(list, sz, (*list)->size, l1, (*list)->header, res, cnt1, l)))
        return 0;
}


CondTester, a patch instance with id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 92
Counter: 93
Batcher Size:82
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 93
Counter: 94
Batcher Size:83
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 1;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 94
Counter: 95
Batcher Size:84
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:64
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    break;
if (sz > (*list)->size)
    return 0;


CondTester, a patch instance with id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 95
Counter: 96
Batcher Size:85
Preprocess the following candidate with CondTester:
Priority 4999
At location prog.c:64
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(list, sz, (*list)->size, l1, l1->next, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    if (sz > (*list)->size)
        return 0;


CondTester, a patch instance with id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    if (sz > (*list)->size)
        return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 96
Counter: 97
Batcher Size:86
Preprocess the following candidate with BasicTester:
Priority 4999
At location prog.c:64
--Src File: prog.c
Fragment 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;


BasicTester, a patch instance with id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 97
Counter: 98
Batcher Size:87
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:63
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    l1 = l1->next;


CondTester, a patch instance with id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 98
Counter: 99
Batcher Size:88
Preprocess the following candidate with BasicTester:
Priority 4998
At location prog.c:63
--Src File: prog.c
Fragment 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;


BasicTester, a patch instance with id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 99
Counter: 100
Batcher Size:89
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:63
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 0;
l1 = l1->next;


CondTester, a patch instance with id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 100
Counter: 101
Batcher Size:90
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:63
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    return 1;
l1 = l1->next;


CondTester, a patch instance with id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 101
Counter: 102
Batcher Size:91
Preprocess the following candidate with CondTester:
Priority 4998
At location prog.c:63
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, l1->next, list, sz, (*list)->size, (*list)->header, res, cnt1, l, l1->prev, l1->name)))
    break;
l1 = l1->next;


CondTester, a patch instance with id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 102
Counter: 103
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = (res);
sz = sz + 1;


BasicTester, a patch instance with id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 103
Counter: 104
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = (sz);
sz = sz + 1;


BasicTester, a patch instance with id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 104
Counter: 105
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = sz + 1;
sz = sz + 1;


BasicTester, a patch instance with id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = sz + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 105
Counter: 106
Batcher Size:95
Preprocess the following candidate with CondTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(sz, l1, l1->next, list, res, cnt1, l, l1->prev, l1->name)))
    sz = sz + 1;


CondTester, a patch instance with id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 106
Counter: 107
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l1 = (l);
sz = sz + 1;


BasicTester, a patch instance with id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 107
Counter: 108
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = (1);
sz = sz + 1;


BasicTester, a patch instance with id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 108
Counter: 109
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = 1;
sz = sz + 1;


BasicTester, a patch instance with id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 109
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        sz = sz + 1;
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        sz = sz + 1;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        sz = sz + 1;
        }
        else if (__get_mutant()==3) {
        sz = (res);
        sz = sz + 1;
        }
        else if (__get_mutant()==4) {
        sz = (sz);
        sz = sz + 1;
        }
        else if (__get_mutant()==5) {
        sz = sz + 1;
        sz = sz + 1;
        }
        else if (__get_mutant()==6) {
        if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            sz = sz + 1;
        }
        else if (__get_mutant()==7) {
        l1 = (l);
        sz = sz + 1;
        }
        else if (__get_mutant()==8) {
        res = (1);
        sz = sz + 1;
        }
        else if (__get_mutant()==9) {
        res = 1;
        sz = sz + 1;
        }
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
CondTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
CondTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if ((__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Strange error or non-deterministic behavior!
BasicTester, Testing instance id 26:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 27:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = sz + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 75:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (!(__is_neg(9, &(sz), sizeof (sz), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
BasicTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Counter: 110
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = (1);
sz = sz + 1;


BasicTester, a patch instance with id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 110
Counter: 111
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = (cnt1);
sz = sz + 1;


BasicTester, a patch instance with id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 111
Counter: 112
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
sz = (0);
sz = sz + 1;


BasicTester, a patch instance with id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 112
Counter: 113
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = (cnt1);
sz = sz + 1;


BasicTester, a patch instance with id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 113
Counter: 114
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = (res);
sz = sz + 1;


BasicTester, a patch instance with id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 114
Counter: 115
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = (sz);
sz = sz + 1;


BasicTester, a patch instance with id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 115
Counter: 116
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l1 = (l)->next;
sz = sz + 1;


BasicTester, a patch instance with id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 116
Counter: 117
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l1 = l1->next;
sz = sz + 1;


BasicTester, a patch instance with id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = l1->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 117
Counter: 118
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
newNode(&(l1));
sz = sz + 1;


BasicTester, a patch instance with id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
newNode(&(l1));
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 118
Counter: 119
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
res = (0);
sz = sz + 1;


BasicTester, a patch instance with id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 119
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        sz = (1);
        sz = sz + 1;
        }
        else if (__get_mutant()==1) {
        sz = (cnt1);
        sz = sz + 1;
        }
        else if (__get_mutant()==2) {
        sz = (0);
        sz = sz + 1;
        }
        else if (__get_mutant()==3) {
        res = (cnt1);
        sz = sz + 1;
        }
        else if (__get_mutant()==4) {
        res = (res);
        sz = sz + 1;
        }
        else if (__get_mutant()==5) {
        res = (sz);
        sz = sz + 1;
        }
        else if (__get_mutant()==6) {
        l1 = (l)->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==7) {
        l1 = l1->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==8) {
        newNode(&(l1));
        sz = sz + 1;
        }
        else if (__get_mutant()==9) {
        res = (0);
        sz = sz + 1;
        }
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 34:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
sz = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 35:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 36:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = l1->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
newNode(&(l1));
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
BasicTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
res = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Counter: 120
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
newNode(&(l));
sz = sz + 1;


BasicTester, a patch instance with id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
newNode(&(l));
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 120
Counter: 121
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l1 = (l1);
sz = sz + 1;


BasicTester, a patch instance with id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 121
Counter: 122
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l1 = (l1)->next;
sz = sz + 1;


BasicTester, a patch instance with id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 122
Counter: 123
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = (0);
sz = sz + 1;


BasicTester, a patch instance with id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 123
Counter: 124
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if (res == 1)
    return res;
sz = sz + 1;


BasicTester, a patch instance with id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (res == 1)
    return res;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 124
Counter: 125
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l = (l)->next;
sz = sz + 1;


BasicTester, a patch instance with id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 125
Counter: 126
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l = (l1)->next;
sz = sz + 1;


BasicTester, a patch instance with id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 126
Counter: 127
Batcher Size:96
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l = l->next;
sz = sz + 1;


BasicTester, a patch instance with id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = l->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 127
Counter: 128
Batcher Size:97
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l = (l1);
sz = sz + 1;


BasicTester, a patch instance with id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 128
Counter: 129
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if (sz != (*list)->size)
    return 1;
sz = sz + 1;


BasicTester, a patch instance with id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (sz != (*list)->size)
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 129
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        newNode(&(l));
        sz = sz + 1;
        }
        else if (__get_mutant()==1) {
        l1 = (l1);
        sz = sz + 1;
        }
        else if (__get_mutant()==2) {
        l1 = (l1)->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==3) {
        cnt1 = (0);
        sz = sz + 1;
        }
        else if (__get_mutant()==4) {
        if (res == 1)
            return res;
        sz = sz + 1;
        }
        else if (__get_mutant()==5) {
        l = (l)->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==6) {
        l = (l1)->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==7) {
        l = l->next;
        sz = sz + 1;
        }
        else if (__get_mutant()==8) {
        l = (l1);
        sz = sz + 1;
        }
        else if (__get_mutant()==9) {
        if (sz != (*list)->size)
            return 1;
        sz = sz + 1;
        }
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
newNode(&(l));
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l1 = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (0);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (res == 1)
    return res;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1)->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = l->next;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (sz != (*list)->size)
    return 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
Counter: 130
Batcher Size:89
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
if (sz > (*list)->size)
    return 0;
sz = sz + 1;


BasicTester, a patch instance with id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (sz > (*list)->size)
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 130
Counter: 131
Batcher Size:90
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
l = (l);
sz = sz + 1;


BasicTester, a patch instance with id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 131
Counter: 132
Batcher Size:91
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = (1);
sz = sz + 1;


BasicTester, a patch instance with id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 132
Counter: 133
Batcher Size:92
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = (cnt1);
sz = sz + 1;


BasicTester, a patch instance with id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 133
Counter: 134
Batcher Size:93
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = (sz);
sz = sz + 1;


BasicTester, a patch instance with id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 134
Counter: 135
Batcher Size:94
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = cnt1 + 1;
sz = sz + 1;


BasicTester, a patch instance with id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = cnt1 + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 135
Counter: 136
Batcher Size:95
Preprocess the following candidate with BasicTester:
Priority 4997
At location prog.c:62
--Src File: prog.c
Fragment 0:
cnt1 = (res);
sz = sz + 1;


BasicTester, a patch instance with id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 136
Counter: 137
Batcher Size:96
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, sz, list, l1->next, res, cnt1, l, l1->prev, l1->name)))
    return 0;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }


CondTester, a patch instance with id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 137
Counter: 138
Batcher Size:97
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:61
--Src File: prog.c
Fragment 0:
if ((__abst_hole(l1, sz, list, l1->next, res, cnt1, l, l1->prev, l1->name)))
    return 1;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }


CondTester, a patch instance with id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 138
Counter: 139
Batcher Size:98
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:61
--Src File: prog.c
Fragment 0:
memset((*list), 0, sizeof (*((*list))));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }


BasicTester, a patch instance with id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 139
Counter: 140
Batcher Size:99
Preprocess the following candidate with CondTester:
Priority 4996
At location prog.c:61
--Src File: prog.c
Fragment 0:
if (!(__abst_hole(l1, sz, list, l1->next, res, cnt1, l, l1->prev, l1->name)))
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }


CondTester, a patch instance with id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if (!(__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 140
Counter: 141
Batcher Size:100
Preprocess the following candidate with BasicTester:
Priority 4996
At location prog.c:61
--Src File: prog.c
Fragment 0:
memset(l1, 0, sizeof (*(l1)));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }


BasicTester, a patch instance with id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 141
Counter: 142
Batcher Size:101
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, l1, (*list)->header, res, l1->next, (*list)->size, cnt1, l, l1->prev, l1->name)))
    return 0;
int sz = 0;


CondTester, a patch instance with id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    
//Patch 0:
if ((__is_neg(10, &(list), sizeof (list), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l1->next), sizeof (l1->next), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
int sz = 0;

//CodeSeg 1:
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 142
CondTester, Testing instance id 79:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    
//Patch 0:
if ((__is_neg(10, &(list), sizeof (list), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l1->next), sizeof (l1->next), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
int sz = 0;

//CodeSeg 1:
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Counter: 143
Batcher Size:101
Preprocess the following candidate with CondTester:
Priority 4995
At location prog.c:60
--Src File: prog.c
Fragment 0:
if ((__abst_hole(list, l1, (*list)->header, res, l1->next, (*list)->size, cnt1, l, l1->prev, l1->name)))
    return 1;
int sz = 0;


CondTester, a patch instance with id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    
//Patch 0:
if ((__is_neg(10, &(list), sizeof (list), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l1->next), sizeof (l1->next), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
int sz = 0;

//CodeSeg 1:
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Spawn 1 instances, now Total 143
CondTester, Testing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    
//Patch 0:
if ((__is_neg(10, &(list), sizeof (list), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l1->next), sizeof (l1->next), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
int sz = 0;

//CodeSeg 1:
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Postprocessing instance id 80:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    
//Patch 0:
if ((__is_neg(10, &(list), sizeof (list), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(l1->next), sizeof (l1->next), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
int sz = 0;

//CodeSeg 1:
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l != 0
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 4994920.000000
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     //prophet generated patch
     if (__get_mutant()==0) {
     if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
         return;
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==1) {
     (*n)->name = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==2) {
     *n = malloc(sizeof(struct Node));
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==3) {
     (*n)->prev = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
     else if (__get_mutant()==4) {
     (*n)->next = ((void *)0);
     *n = malloc(sizeof(struct Node));
     }
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 28:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
if ((__is_neg(4, &(n), sizeof (n), &((*n)->next), sizeof ((*n)->next), &((*n)->prev), sizeof ((*n)->prev), &((*n)->name), sizeof ((*n)->name))))
    return;
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
BasicTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->name = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
*n = malloc(sizeof(struct Node));
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->prev = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     
//Patch 0:
(*n)->next = ((void *)0);
*n = malloc(sizeof(struct Node));

//CodeSeg 1:
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
        return;
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==1) {
    (*t)->header = ((void *)0);
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==2) {
    *t = malloc(sizeof(struct List));
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==3) {
    (*t)->size = (0);
    *t = malloc(sizeof(struct List));
    }
    else if (__get_mutant()==4) {
    (*t)->size = 0;
    *t = malloc(sizeof(struct List));
    }
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 29:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
if ((__is_neg(3, &(t), sizeof (t), &((*t)->header), sizeof ((*t)->header), &((*t)->size), sizeof ((*t)->size))))
    return;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->header = ((void *)0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
*t = malloc(sizeof(struct List));
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = (0);
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    
//Patch 0:
(*t)->size = 0;
*t = malloc(sizeof(struct List));

//CodeSeg 1:
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    //prophet generated patch
    if (__get_mutant()==0) {
    l = l->next;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==1) {
    newNode(&(l));
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==2) {
    if (res == 1)
        return res;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==3) {
    cnt1 = cnt1 + 1;
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==4) {
    cnt1 = (cnt1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==5) {
    cnt1 = (res);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
    else if (__get_mutant()==6) {
    cnt1 = (1);
    while (cnt1 < (*list)->size)
        {
            struct Node *p = l->next;
            int cnt2 = cnt1 + 1;
            while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
                {
                    if (l == p) {
                        res = 1;
                        return res;
                    }
                    cnt2++;
                    p = l->next;
                }
            l = l->next;
            cnt1 = cnt1 + 1;
        }
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
l = l->next;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
newNode(&(l));
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
if (res == 1)
    return res;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = cnt1 + 1;
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (cnt1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (res);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    
//Patch 0:
cnt1 = (1);
while (cnt1 < (*list)->size)
    {
        struct Node *p = l->next;
        int cnt2 = cnt1 + 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }

//CodeSeg 1:
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        //prophet generated patch
        if (__get_mutant()==0) {
        if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 0;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        }
        else if (__get_mutant()==1) {
        if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            return 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
            break;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 40:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 42:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Postprocessing instance id 41:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(p), sizeof (p), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(l), sizeof (l), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
    {
        if (l == p) {
            res = 1;
            return res;
        }
        cnt2++;
        p = l->next;
    }

//CodeSeg 1:
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->prev != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr res == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->prev == 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr p != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr l->next != 0
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt2 == 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt2 != 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr (*list)->size == 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr (*list)->size != 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt2 == 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt2 != 2
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 != 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Initial synthesize failed, final attempt
Final attempt 1/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        //prophet generated patch
        if (((0)))
            return 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Final attempt 2/2 with expr int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        //prophet generated patch
        if (((1)))
            return 1;
        while ((cnt2 <= (*list)->size) && (p != ((void *)0)))
            {
                if (l == p) {
                    res = 1;
                    return res;
                }
                cnt2++;
                p = l->next;
            }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying Negative cases!
Trying Positive cases!
Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((l == p) && !(__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==1) {
            if ((l == p) || (__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                return 0;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                return 1;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
                break;
            if (l == p) {
                res = 1;
                return res;
            }
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((l == p) && !(__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((l == p) || (__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 37:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 0;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
CondTester, Testing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 39:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    break;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Iteration 5
Branch 0: 1
Branch 1: 1
CondTester, Postprocessing instance id 1:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((l == p) || (__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name)))) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Trying a synthesis expr 1
Verifing Negative cases!
Verifying positive cases
Failed positive case 5
Not passed!
Trying a synthesis expr cnt1 != 0
Verifing Negative cases!
Verifying positive cases
Passed Positive Cases
Passed!
Passed with updated best score 19999999.000000
CondTester, Postprocessing instance id 38:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            
//Patch 0:
if ((__is_neg(11, &(l), sizeof (l), &(p), sizeof (p), &(list), sizeof (list), &(res), sizeof (res), &(cnt2), sizeof (cnt2), &((*list)->size), sizeof ((*list)->size), &(cnt1), sizeof (cnt1), &(l->next), sizeof (l->next), &((*list)->header), sizeof ((*list)->header), &(l->prev), sizeof (l->prev), &(l->name), sizeof (l->name))))
    return 1;
if (l == p) {
    res = 1;
    return res;
}

//CodeSeg 1:
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
            return res;
        }
        else if (__get_mutant()==1) {
        if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
            return res;
        }

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 8:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) && !(__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 9:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        
//Patch 0:
if ((res == 1) || (__is_neg(4, &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(list), sizeof (list), &(l), sizeof (l))))
    return res;

//CodeSeg 1:

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
        return 0;
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }
    }
    else if (__get_mutant()==1) {
    if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
        return 1;
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }
    }
    else if (__get_mutant()==2) {
    memset((*list), 0, sizeof (*((*list))));
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }
    }
    else if (__get_mutant()==3) {
    if (!(__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
        while (l1 != ((void *)0))
            {
                sz = sz + 1;
                l1 = l1->next;
                if (sz > (*list)->size)
                    return 0;
            }
    }
    else if (__get_mutant()==4) {
    memset(l1, 0, sizeof (*(l1)));
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 76:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
BasicTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Testing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if (!(__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
BasicTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
CondTester, Postprocessing instance id 77:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if ((__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
while (l1 != ((void *)0))
    {
        sz = sz + 1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
CondTester, Postprocessing instance id 78:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    
//Patch 0:
if (!(__is_neg(9, &(l1), sizeof (l1), &(sz), sizeof (sz), &(list), sizeof (list), &(l1->next), sizeof (l1->next), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    while (l1 != ((void *)0))
        {
            sz = sz + 1;
            l1 = l1->next;
            if (sz > (*list)->size)
                return 0;
        }

//CodeSeg 1:

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if (sz > (*list)->size)
            return 0;
        sz = sz + 1;
        }
        else if (__get_mutant()==1) {
        l = (l);
        sz = sz + 1;
        }
        else if (__get_mutant()==2) {
        cnt1 = (1);
        sz = sz + 1;
        }
        else if (__get_mutant()==3) {
        cnt1 = (cnt1);
        sz = sz + 1;
        }
        else if (__get_mutant()==4) {
        cnt1 = (sz);
        sz = sz + 1;
        }
        else if (__get_mutant()==5) {
        cnt1 = cnt1 + 1;
        sz = sz + 1;
        }
        else if (__get_mutant()==6) {
        cnt1 = (res);
        sz = sz + 1;
        }
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
BasicTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
if (sz > (*list)->size)
    return 0;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
l = (l);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (cnt1);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (sz);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = cnt1 + 1;
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
BasicTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        
//Patch 0:
cnt1 = (res);
sz = sz + 1;

//CodeSeg 1:
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        //prophet generated patch
        if (__get_mutant()==0) {
        if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            l1 = l1->next;
        }
        else if (__get_mutant()==1) {
        memset(l1, 0, sizeof (*(l1)));
        l1 = l1->next;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        l1 = l1->next;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        l1 = l1->next;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        l1 = l1->next;
        }
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 71:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if (!(__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 5
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
BasicTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
memset(l1, 0, sizeof (*(l1)));
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Passed Negative Cases
Testing positive cases!
Failed positive case 5
CondTester, Testing instance id 72:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
CondTester, Testing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Postprocessing instance id 73:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
CondTester, Postprocessing instance id 74:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        
//Patch 0:
if ((__is_neg(11, &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
l1 = l1->next;

//CodeSeg 1:
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        }
        else if (__get_mutant()==1) {
        if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 0;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            return 1;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            break;
        if (sz > (*list)->size)
            return 0;
        }
        else if (__get_mutant()==5) {
        if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
            if (sz > (*list)->size)
                return 0;
        }
        else if (__get_mutant()==6) {
        memset((*list), 0, sizeof (*((*list))));
        if (sz > (*list)->size)
            return 0;
        }
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 18:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) && !(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
CondTester, Testing instance id 19:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((sz > (*list)->size) || (__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 67:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 0;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Iteration 3
Branch 0: 1
CondTester, Testing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 70:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if (!(__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    if (sz > (*list)->size)
        return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 1
Branch 10: 1
Branch 11: 0
BasicTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
memset((*list), 0, sizeof (*((*list))));
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
CondTester, Postprocessing instance id 68:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    return 1;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
CondTester, Postprocessing instance id 69:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        
//Patch 0:
if ((__is_neg(11, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &(l1->next), sizeof (l1->next), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l), &(l1->prev), sizeof (l1->prev), &(l1->name), sizeof (l1->name))))
    break;
if (sz > (*list)->size)
    return 0;

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            //prophet generated patch
            if (__get_mutant()==0) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 0;
                return 0;
            }
            }
            else if (__get_mutant()==1) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 1;
                return 0;
            }
            }
            else if (__get_mutant()==2) {
            {
                if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    break;
                return 0;
            }
            }
            else if (__get_mutant()==3) {
            {
                if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
                    return 0;
            }
            }
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 63:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 1;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        break;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 66:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if (!(__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 4
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 1
Branch 6: 1
Branch 7: 1
Branch 8: 1
Branch 9: 0
CondTester, Postprocessing instance id 64:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        return 1;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
CondTester, Postprocessing instance id 65:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            
//Patch 0:
{
    if ((__is_neg(8, &(list), sizeof (list), &(sz), sizeof (sz), &((*list)->size), sizeof ((*list)->size), &(l1), sizeof (l1), &((*list)->header), sizeof ((*list)->header), &(res), sizeof (res), &(cnt1), sizeof (cnt1), &(l), sizeof (l))))
        break;
    return 0;
}

//CodeSeg 1:
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    }
    else if (__get_mutant()==2) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 1;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==3) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 2;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==4) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 20;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==5) {
    if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
        return 0;
    if (argc < 2)
        return 0;
    }
    else if (__get_mutant()==6) {
    if (argc < 2)
        return 0;
    if (argc < 2)
        return 0;
    }
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 20:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) && !(__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((argc < 2) || (__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 30:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 1;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 31:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 2;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 32:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 20;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 33:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if ((__is_neg(2, &(argc), sizeof (argc), &(argv), sizeof (argv))))
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
BasicTester, Testing instance id 23:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    
//Patch 0:
if (argc < 2)
    return 0;
if (argc < 2)
    return 0;

//CodeSeg 1:
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    //prophet generated patch
    if (__get_mutant()==0) {
    if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }
    else if (__get_mutant()==1) {
    if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
        return 0;
    }

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 21:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) && !(__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Testing instance id 22:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    
//Patch 0:
if ((f == ((void *)0)) || (__is_neg(3, &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;

//CodeSeg 1:

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==1) {
        if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            continue;
        }
        else if (__get_mutant()==2) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 0;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==3) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 1;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==4) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 2;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==5) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            break;
        if (x[0] == '"')
            continue;
        }
        else if (__get_mutant()==6) {
        if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            return 20;
        if (x[0] == '"')
            continue;
        }

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 24:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') && !(__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 25:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((x[0] == '"') || (__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Branch 5: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 0
Branch 5: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 1
Branch 5: 0
Iteration 7
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 1
Branch 5: 1
Iteration 8
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Branch 4: 0
Branch 5: 0
Iteration 9
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Branch 4: 0
Branch 5: 1
CondTester, Testing instance id 43:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 0;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 7
Branch 0: 0
Branch 1: 1
Iteration 8
Branch 0: 1
CondTester, Testing instance id 44:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 1;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 7
Branch 0: 0
Branch 1: 1
Iteration 8
Branch 0: 1
CondTester, Testing instance id 45:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 2;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 7
Branch 0: 0
Branch 1: 1
Iteration 8
Branch 0: 1
CondTester, Testing instance id 46:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    break;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 7
Branch 0: 0
Branch 1: 1
Iteration 8
Branch 0: 1
CondTester, Testing instance id 47:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        
//Patch 0:
if ((__is_neg(9, &(f), sizeof (f), &(n0), sizeof (n0), &(n2), sizeof (n2), &(n1), sizeof (n1), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    return 20;
if (x[0] == '"')
    continue;

//CodeSeg 1:

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 0
Branch 7: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 0
Branch 6: 1
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Branch 5: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 7
Branch 0: 0
Branch 1: 1
Iteration 8
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        //prophet generated patch
        if (__get_mutant()==0) {
        if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            tmp = ((void *)0);
        else if (strcmp(x, "N0") == 0)
            tmp = n0;
        else if (strcmp(x, "N1") == 0)
            tmp = n1;
        else if (strcmp(x, "N2") == 0)
            tmp = n2;
        }
        else if (__get_mutant()==1) {
        if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
            tmp = ((void *)0);
        else if (strcmp(x, "N0") == 0)
            tmp = n0;
        else if (strcmp(x, "N1") == 0)
            tmp = n1;
        else if (strcmp(x, "N2") == 0)
            tmp = n2;
        }

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 6:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) && !(__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
CondTester, Testing instance id 7:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        
//Patch 0:
if ((strcmp(x, "NULL") == 0) || (__is_neg(10, &(tmp), sizeof (tmp), &(n0), sizeof (n0), &(f), sizeof (f), &(n1), sizeof (n1), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc))))
    tmp = ((void *)0);
else if (strcmp(x, "N0") == 0)
    tmp = n0;
else if (strcmp(x, "N1") == 0)
    tmp = n1;
else if (strcmp(x, "N2") == 0)
    tmp = n2;

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 0
Iteration 3
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Branch 4: 1
Iteration 4
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 5
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 1
Iteration 6
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Branch 4: 0
Iteration 7
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 0
Branch 4: 1
Iteration 8
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 0
Iteration 9
Branch 0: 0
Branch 1: 1
Branch 2: 0
Branch 3: 1
Branch 4: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}
else if (__get_mutant()==1) {
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 4:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) && !(__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 1
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 4
Branch 0: 1
CondTester, Testing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Postprocessing instance id 5:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else 
//Patch 0:
{
    if ((strcmp(x, "N0") == 0) || (__is_neg(13, &(n0), sizeof (n0), &(tmp), sizeof (tmp), &(n1), sizeof (n1), &(n2), sizeof (n2), &(f), sizeof (f), &(status), sizeof (status), &(node), sizeof (node), &(n0->name), sizeof (n0->name), &(list), sizeof (list), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev))))
        tmp = n0;
    else if (strcmp(x, "N1") == 0)
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}
else if (__get_mutant()==1) {
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}
}

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 2:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) && !(__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 3:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else 
//Patch 0:
{
    if ((strcmp(x, "N1") == 0) || (__is_neg(16, &(n0), sizeof (n0), &(n1), sizeof (n1), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(status), sizeof (status), &(node), sizeof (node), &(f), sizeof (f), &(n1->name), sizeof (n1->name), &(list), sizeof (list), &(n0->name), sizeof (n0->name), &(argv), sizeof (argv), &(argc), sizeof (argc), &(n0->next), sizeof (n0->next), &(n0->prev), sizeof (n0->prev), &(n1->next), sizeof (n1->next), &(n1->prev), sizeof (n1->prev))))
        tmp = n1;
    else if (strcmp(x, "N2") == 0)
        tmp = n2;
}

//CodeSeg 1:

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        //prophet generated patch
        if (__get_mutant()==0) {
        if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
            node = tmp;
            status = status + 1;
        } else if (status == 1) {
            node->prev = tmp;
            status = status + 1;
        } else if (status == 2) {
            node->next = tmp;
            status = 0;
            list->size = list->size + 1;
            if (list->header == ((void *)0))
                list->header = node;
        }
        }
        else if (__get_mutant()==1) {
        if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
            node = tmp;
            status = status + 1;
        } else if (status == 1) {
            node->prev = tmp;
            status = status + 1;
        } else if (status == 2) {
            node->next = tmp;
            status = 0;
            list->size = list->size + 1;
            if (list->header == ((void *)0))
                list->header = node;
        }
        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 1
Branch 0: 0
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 2
Branch 0: 0
Branch 1: 0
Branch 2: 1
Branch 3: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 17:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 3
Branch 0: 0
Branch 1: 1
Branch 2: 1
Branch 3: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 0
Branch 3: 1
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
Branch 4: 1
Branch 5: 0
CondTester, Postprocessing instance id 14:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        
//Patch 0:
if ((status == 0) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(n2), sizeof (n2), &(n1), sizeof (n1), &(node->prev), sizeof (node->prev), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
    node = tmp;
    status = status + 1;
} else if (status == 1) {
    node->prev = tmp;
    status = status + 1;
} else if (status == 2) {
    node->next = tmp;
    status = 0;
    list->size = list->size + 1;
    if (list->header == ((void *)0))
        list->header = node;
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node = tmp;
            }
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 58:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 59:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 60:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 61:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 62:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(status), sizeof (status), &(n2), sizeof (n2), &(node->prev), sizeof (node->prev), &(n1), sizeof (n1), &(n0), sizeof (n0), &(node->next), sizeof (node->next), &(list), sizeof (list), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node = tmp;

//CodeSeg 1:
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
else if (__get_mutant()==1) {
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Branch 2: 0
Iteration 2
Branch 0: 0
Branch 1: 1
Branch 2: 1
Iteration 3
Branch 0: 1
Branch 1: 0
Branch 2: 0
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 1
Iteration 5
Branch 0: 1
Branch 1: 1
Branch 2: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 16:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 0
Iteration 3
Branch 0: 1
Branch 1: 0
Branch 2: 0
Branch 3: 1
Iteration 4
Branch 0: 1
Branch 1: 0
Branch 2: 1
Branch 3: 0
Iteration 5
Branch 0: 1
Branch 1: 0
Branch 2: 1
Branch 3: 1
Iteration 6
Branch 0: 1
Branch 1: 1
Branch 2: 0
Branch 3: 0
Iteration 7
Branch 0: 1
Branch 1: 1
Branch 2: 0
Branch 3: 1
Iteration 8
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 0
Iteration 9
Branch 0: 1
Branch 1: 1
Branch 2: 1
Branch 3: 1
CondTester, Postprocessing instance id 15:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else 
//Patch 0:
{
    if ((status == 1) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->prev = tmp;
        status = status + 1;
    } else if (status == 2) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node->prev = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node->prev = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node->prev = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node->prev = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node->prev = tmp;
            }
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 53:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 54:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 55:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 56:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 57:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->prev), sizeof (node->prev), &(status), sizeof (status), &(node->next), sizeof (node->next), &(list), sizeof (list), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(f), sizeof (f), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->prev = tmp;

//CodeSeg 1:
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else //prophet generated patch
if (__get_mutant()==0) {
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
else if (__get_mutant()==1) {
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}
}
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
Branch 1: 0
Iteration 3
Branch 0: 1
Branch 1: 1
Branch 2: 0
Passed in iteration!
Passed Negative Cases wiht CondTestder!
Testing positive cases!
Passed Positive Cases
Collect values for post processing!
Passed!
CondTester, Testing instance id 13:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) || (__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Not caught by the negative case, give up!
CondTester, Postprocessing instance id 12:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else 
//Patch 0:
{
    if ((status == 2) && !(__is_neg(13, &(status), sizeof (status), &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name)))) {
        node->next = tmp;
        status = 0;
        list->size = list->size + 1;
        if (list->header == ((void *)0))
            list->header = node;
    }
}

//CodeSeg 1:
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Postprocessing failed!
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                break;
            node->next = tmp;
            }
            else if (__get_mutant()==1) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 0;
            node->next = tmp;
            }
            else if (__get_mutant()==2) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 1;
            node->next = tmp;
            }
            else if (__get_mutant()==3) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 2;
            node->next = tmp;
            }
            else if (__get_mutant()==4) {
            if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                return 20;
            node->next = tmp;
            }
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 48:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    break;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 49:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 0;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 50:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 1;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 51:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 2;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
CondTester, Testing instance id 52:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            
//Patch 0:
if ((__is_neg(13, &(node), sizeof (node), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(status), sizeof (status), &(list), sizeof (list), &(node->prev), sizeof (node->prev), &(f), sizeof (f), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    return 20;
node->next = tmp;

//CodeSeg 1:
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Branch 1: 0
Iteration 1
Branch 0: 0
Branch 1: 1
Iteration 2
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            //prophet generated patch
            if (__get_mutant()==0) {
            if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                list->header = node;
            }
            else if (__get_mutant()==1) {
            if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
                list->header = node;
            }

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Merged code building succ, going to invoke tester!
CondTester, Testing instance id 10:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) && !(__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
Branch 1: 0
Iteration 2
Branch 0: 1
Branch 1: 1
CondTester, Testing instance id 11:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            
//Patch 0:
if ((list->header == ((void *)0)) || (__is_neg(15, &(list), sizeof (list), &(list->header), sizeof (list->header), &(node), sizeof (node), &(list->size), sizeof (list->size), &(status), sizeof (status), &(tmp), sizeof (tmp), &(node->next), sizeof (node->next), &(f), sizeof (f), &(node->prev), sizeof (node->prev), &(n2), sizeof (n2), &(n1), sizeof (n1), &(n0), sizeof (n0), &(argv), sizeof (argv), &(argc), sizeof (argc), &(node->name), sizeof (node->name))))
    list->header = node;

//CodeSeg 1:

        }
    }

    fclose(f);
    int res = repOK(&list);
    printf("%d ", res);

    return 0;
}

Testing negative cases!
Testing 2 (with abstract condition)
Iteration 0
Branch 0: 0
Iteration 1
Branch 0: 1
a batched test job starts!
Building merged code:
src_file: prog.c
full src: int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    //prophet generated patch
    if (__get_mutant()==0) {
    printf(("%d##uni*##"), res);
    }

    return 0;
}

Merged code building succ, going to invoke tester!
StringConstTester, Testing instance id 0:
//src_file:prog.c
//Total frags: 1
//CodeSeg 0:
int __get_mutant(); int __is_neg(int, ...); int __abst_hole(); 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Node {
    struct Node* next;
    struct Node* prev;
    char* name;
};

struct List {
    struct Node* header;
    int size;
};

int repOK (struct List** t);
void newNode(struct Node** n);
void newList(struct List** t);

void newNode(struct Node** n) {
     *n = malloc (sizeof (struct Node));
    (*n)->next = NULL;
    (*n)->prev = NULL;
    (*n)->name = NULL;
}

void newList(struct List** t) {
    *t = malloc(sizeof (struct List));
    (*t)->header = NULL;
    (*t)->size = 0;
}


int repOK (struct List** list) {
    struct Node* l = (*list)->header;
    int cnt1 = 0;
    int res = 0;
    while (cnt1 < (*list)->size) {
       struct  Node* p = l->next;
        int cnt2 = cnt1+1;


        while ((cnt2 <= (*list)->size) && (p != NULL)) {
            if (l==p) {
                res = 1;
                return res;
            }
            cnt2++;
           p = l->next;// BUG LISTERR3

        }
        l = l->next;
        cnt1 = cnt1 + 1;
    }
        if (res == 1)
            return res;

    struct Node* l1 = (*list)->header;
    int sz=0;
    while (l1!=NULL) {
        sz = sz+1;
        l1 = l1->next;
        if (sz > (*list)->size)
            return 0;
    }

    if (sz != (*list)->size)
        return 1;
    return 0;
}


int main(int argc, char* argv[]) {
    if (argc<2) return 0;
    FILE *f = fopen(argv[1],"r");
    if (f==NULL)
        return 0;

    char x[20];
    int status = 0;
    struct List* list ;
    newList(&list);

struct Node* n0;
struct Node* n1;
struct Node* n2;
newNode(&n0);
n0->name = "N0";
newNode(&n1);
n1->name = "N1";
newNode(&n2);
n2->name = "N2";



  struct Node* node=NULL;
    while (fscanf(f,"%s",x)==1) {
        if (x[0] == '"')  continue;

        struct Node* tmp=NULL;
        if (strcmp(x,"NULL")==0)
            tmp = NULL;
        else if (strcmp(x,"N0")==0)
            tmp = n0;
        else if (strcmp(x,"N1")==0)
            tmp = n1;
        else if (strcmp(x,"N2")==0)
            tmp = n2;

        if (status==0) {
            node = tmp;
            status = status +1;
        }
        else if (status == 1) {
            node->prev = tmp;
            status = status +1;
        }

        else if (status ==2) {
            node->next = tmp;
            status =0;
            list->size = list->size +1;
            if (list->header==NULL)
                list->header = node;

        }
    }

    fclose(f);
    int res = repOK(&list);
    
//Patch 0:
printf(("%d##uni*##"), res);

//CodeSeg 1:

    return 0;
}

Testing negative cases!
Generate a candidate with schema id: 143
Generate a candidate with schema id: 2
Total cnt of passed cond schemas: 16
Total cnt of cond schemas: 81
Counter: 144
Batcher Size:0
The found score 19999999.000000 is greater than current score 4994.000000!
Terminate current session!
Generate a candidate with schema id: 143
Generate a candidate with schema id: 2
Total cnt of passed cond schemas: 16
Total cnt of cond schemas: 81
The first schema id that generates patch: 2
Found a fix! Store to: __fixed_prog.c
Found a fix! Store to: __fixed_prog.c-1
Repair process ends successfully!
Total 3024 different repair schemas!!!!
Total 6377 different repair candidate templates for scoring!!!
Total number of compiles: 53
Total number of test eval: 531
